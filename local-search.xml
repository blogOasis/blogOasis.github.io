<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>什么是幸福</title>
    <link href="/post/a2a3666c.html"/>
    <url>/post/a2a3666c.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题的引出：为什么要说这个话题"><a href="#问题的引出：为什么要说这个话题" class="headerlink" title="问题的引出：为什么要说这个话题"></a>问题的引出：为什么要说这个话题</h2><p>我在很多地方都提到过幸福这个概念，但是对于什么是幸福以及人如何获得幸福感，没有做过类似的探讨。前两天看视频的时候，听到博主讲到一本书，将幸福分为体验式幸福和反思式幸福。这个概念引发了我对自身经历的思考，让我重新审视幸福的本质及其在我们生活中的意义。</p><h2 id="体验式幸福"><a href="#体验式幸福" class="headerlink" title="体验式幸福"></a>体验式幸福</h2><p>体验式幸福的定义是指个体在当下行为或活动中所感受到的即时快乐和愉悦感。它具有以下特点:</p><ol><li><strong>短暂性</strong>: 是一种暂时性的体验，具有波动性。</li><li><strong>外显性</strong>: 通常表现为可观察到的情绪反应。</li><li><strong>感官刺激</strong>: 多与消费、社交、旅行、美食等活动相关。</li><li><strong>阈值递增</strong>: 随着体验次数和强度的增加,快感可能会逐渐减弱。</li></ol><p>体验式幸福的例子包括：购物时的兴奋、旅行中的新鲜感、美食带来的满足感等。</p><p>以我自身为例，体验式幸福有过如下时刻：</p><ul><li>买平板：大一刚买平板，第一次使用苹果产品的新鲜感 + apple pencil 超强压感，好几天爱不释手。</li><li>买显示器：第一次看到4k显示器时，被超高清晰度所震撼的那一刻。</li><li>买主机：苦于轻薄本有限的游戏性能，花费许多时间去测试设置集合。最后下决心买一台主机，到手后各种尝试探索，新鲜感，将每个硬件的参数都记下来，多次回家都在行李箱中塞下主机带回去。</li><li>玩游戏时被精美的画面所打动。</li><li>看剧时，被紧张刺激的情节和清晰的画质所牵动</li><li>许久粗茶淡饭，突然吃到很好吃的东西</li></ul><h3 id="反思式幸福"><a href="#反思式幸福" class="headerlink" title="反思式幸福"></a>反思式幸福</h3><p>反思式幸福（也称回顾式幸福）是个体对自身经历和成就的反思与评价所产生的持久性幸福感。它的特点包括：</p><ol><li><strong>持久性</strong>: 是一种相对稳定和长期的幸福体验。</li><li><strong>内在性</strong>: 源于内心的情感驱动和对生活意义的感知。</li><li><strong>延展性</strong>: 不局限于当下,可以延伸到过去和未来。</li><li><strong>自我联系</strong>: 与个人的自我认同和价值观密切相关。</li></ol><p>反思式幸福的例子包括:完成一项艺术创作后的成就感、建立深厚人际关系带来的满足感、实现长期目标后的自我肯定等。</p><p>在我身上，反思式幸福有如下时刻：</p><ul><li>一直日常思考大学教育，突然看到了一本以论文的严谨风格进行论述的书。在阅读时激动于与书中观点不谋而合，在阅读后也回味无穷。属于是自己已经有一定程度的思考，而刚好又碰到了一本能够系统论述、总结的书籍，将原本的思考提升广度与深度。当时便对友人断言：这可能在我一辈子中也很难出现几次。</li><li>之前看到一些技术类的视频，完全沉浸在其中（甚至看两到三遍），理清其内在逻辑并完全理解的满足感，还会迫不及待地与朋友分享。</li><li>看iPhone发布会时，被乔布斯在当时看来的各种创新所打动，包括后台管理，滑动屏幕，需要时才出现的键盘等概念。</li><li>这个幸福分类本身，也激发了我的思考，体会到一种满足感。</li><li>与朋友的深度思考与话题讨论</li></ul><h2 id="如何看待并获得这两种幸福"><a href="#如何看待并获得这两种幸福" class="headerlink" title="如何看待并获得这两种幸福"></a>如何看待并获得这两种幸福</h2><p>认识到幸福的这两种形式后，不应将它们简单地划分优劣。体验式幸福虽然短暂，但它为我们的日常生活增添了色彩和活力，每一个小的体验都是真真切切的。反思式幸福虽然需要自己的努力，但也赋予了生活的意义和深度，推动我们不断成长和进步。</p><p>有句话叫“金钱可以买来幸福”，在这样的二分类下，金钱确实可以在一定程度上购买体验式幸福，比如选择更好的旅行方式、享受高品质的生活体验。在当今社会，我们似乎更容易追求体验式幸福。消费主义文化不断刺激我们追求即时满足，社交媒体上充斥着各种”快乐”的展示。但过度追求这种短暂的快感可能导致我们忽视了更有价值的反思和成长。所以也需要有意识地培养反思的习惯，这并不意味着要放弃生活中的小确幸，而是在享受当下的同时，留出时间和空间进行思考、探索自己人生的意义。可以是每天花些时间回顾自己的所学所感，或是定期与朋友进行深度交流，又或是通过阅读、写作等方式促进自我反思。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>幸福是一个复杂而多元的概念。体验式幸福和反思式幸福各有其特点和价值，共同构成了我们的人生体验。真正的幸福不仅仅是一系列愉快经历的累加，更是对这些经历的思考和内化。在追求幸福的道路上，我们既要珍惜当下的美好时刻，也要不断反思和成长，才能获得更持久、更有意义的幸福。</p><p>该图片由<a href="https://pixabay.com/zh/users/dariuszsankowski-1441456/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1130742">Dariusz Sankowski</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=1130742">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
      <tag>幸福</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>列车人生-从校园到社会的蜕变之旅</title>
    <link href="/post/c2691f11.html"/>
    <url>/post/c2691f11.html</url>
    
    <content type="html"><![CDATA[<h1 id="列车人生-从校园到社会的蜕变之旅"><a href="#列车人生-从校园到社会的蜕变之旅" class="headerlink" title="列车人生: 从校园到社会的蜕变之旅"></a>列车人生: 从校园到社会的蜕变之旅</h1><p>在这个初夏的毕业季，偶然发现了Netflix出品的电视剧《雪国列车》，并伴随我完成了毕业前的最后一段时光。这部改编自同名电影的剧集，以其独特的反乌托邦世界观和深刻的社会阶级批判，给我留下了深刻的印象。然而，让我感触最深的并非剧情本身，而是它与我当前人生阶段的奇妙共鸣。</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/snowpiercer.jpg" alt="snowpiercer"></p><h2 id="系统的异化：从雪国列车到现实社会"><a href="#系统的异化：从雪国列车到现实社会" class="headerlink" title="系统的异化：从雪国列车到现实社会"></a>系统的异化：从雪国列车到现实社会</h2><p>《雪国列车》中的封闭世界是一个极端的缩影，展现了社会系统对人的异化。由于资源有限，乘客被分为一等人，二等人，三等人和末等人，所有的乘客被迫适应这个狭小而严酷的环境，但为了生存，他们也都形成了各自阶层下独特的生存方式和价值观。即使在这么艰难的环境下，当听到可以走出列车去寻找新的伊甸园的声音时，依旧有人对于列车恋恋不舍。这让我想起了《肖申克的救赎》中的图书管理员布鲁克斯。他在监狱中度过了大半生，当重获自由时，却无法适应外界的生活，最终选择了自杀。这个悲剧性的结局同样揭示了体制对人的异化力量。</p><p>在现实生活中，我们也常常被各种系统所塑造。从学校到职场，每个环境都有其特定的规则和期望。我们不知不觉中被这些系统同化，形成特定的思维模式和行为习惯。当我们需要离开熟悉的环境时，往往会感到不适和迷茫。这种感受，与《雪国列车》中那些面临离开列车选择的乘客何其相似。</p><h2 id="从校园到社会：场域与习性的剧变"><a href="#从校园到社会：场域与习性的剧变" class="headerlink" title="从校园到社会：场域与习性的剧变"></a>从校园到社会：场域与习性的剧变</h2><p>法国社会学家布迪厄提出的“场域”和“习性”概念，为我们理解人生转折期的挑战提供了很好的视角。场域是指特定的社会环境，而习性则是个人在长期生活中形成的思维和行为模式。当我们从一个场域转换到另一个场域时，原有的习性往往会与新环境产生冲突。列车就是一个特殊的场域，而各个阶层乘客们的行为习惯则是在这个场域中形成的习性。</p><p>回到现实，从高中到大学，再从大学到社会，每一次转换都是一次巨大的挑战。高中时期，我们习惯于被动接受知识，有明确的学习目标和固定的作息时间。进入大学后，突然面对自主安排时间、主动学习的要求，许多人会感到无所适从。这也使得不少名校的学子在四年甚至七年的学习生活中无法找到前进的方向。</p><p>而从大学步入社会，则面临着更大的挑战：在大学里，我们享受着相对自由和庇护的环境，习惯了老师和学校各种政策的兜底，习惯了宿舍的集体生活，众人的谈笑风生，习惯了方便的基础设施，有固定的学习生活节奏。但迈入社会，不仅要适应新的工作环境，还要学会独立生活，处理各种琐碎的日常事务。这种转变不仅仅是物理环境的变化，更是一种生活方式和思维模式的彻底转变。</p><p>就我自己而言，由于很早就开始实习，加上大四没课，因此很早对学院失去了强烈的归属感，每每听到同班同学、课堂作业对我来说都有种陌生感与割裂感。我也在长时间的实习生活中逐步养成了工作需要的一些思维。但是由于自己仍是学生，因此住宿等所有生活类的习性都还是适应着学校这样的一个场域。直到临近毕业开始租房，并在随后独自搬家，整理东西时，才又一次在生活上体会到场域的剧变。租房意味着我以后再也无法去图书馆接水；也没有人会在宿舍里每天打扫；基础设施比如门锁空调坏了也只能自己找人去修，而不是直接和宿管阿姨说一声就行；再也无法体会到上床下桌的感觉；etc。</p><h2 id="青春易逝：花有重开日，人无再少年"><a href="#青春易逝：花有重开日，人无再少年" class="headerlink" title="青春易逝：花有重开日，人无再少年"></a>青春易逝：花有重开日，人无再少年</h2><p>这种对过去的怀念，与《雪国列车》中那些不愿离开列车的乘客有着异曲同工之妙。他们害怕失去已经适应的生活方式，就像我害怕失去青春岁月的单纯和美好，失去好不容易构建起来的人际关系。然而，生命的列车永远向前，我们也必须学会在怀念过去的同时，勇敢地面对未来。</p><h2 id="拥抱变化：聚焦当下，展望未来"><a href="#拥抱变化：聚焦当下，展望未来" class="headerlink" title="拥抱变化：聚焦当下，展望未来"></a>拥抱变化：聚焦当下，展望未来</h2><p>面对即将到来的变化，我亦曾感到忐忑和不安。但《雪国列车》的结局给了我启示：<strong>所有人都害怕不确定性，但无论是选择留在列车上还是前往新的伊甸园，重要的是我们如何看待这种改变。</strong></p><p>大学里的美好回忆应该被珍惜，但不能被它们所束缚。大学生活给予我的友谊、知识和经历，将永远是宝贵的精神财富。同时，也要聚焦当下，珍惜拥有的每一个机会和小幸运。对于未来，应该保持希望和憧憬，就像剧中那些选择离开列车的人一样，勇敢地迎接未知的挑战。</p><p>人生就像一趟列车，不断地驶向未知的方向。场域在变，习性也必须随之调整。从校园到社会，从学生到职场人，这个转变过程可能会充满挑战和不适。但正如《雪国列车》中的角色们在极端环境中也能找到生存的意义一样，我们也要学会在新的环境中寻找自己的价值和乐趣。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>没有人能永远在18岁，但永远有人在18岁；没有人可以永远在青春，但永远有人正值青春；没有人可以永远在大学校园里多姿多彩，但永远有人在大学校园里面青春洋溢。因此，当外部的场域变换，并且自己无法控制的时候，我们只能改变自己的习性，并努力适应场域的变化。过去之事可以怀念，但只应该被当作成美好的回忆，不应该成为我们聚焦当下的阻力。</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>观后感</tag>
      
      <tag>电视剧</tag>
      
      <tag>美剧</tag>
      
      <tag>乌托邦</tag>
      
      <tag>习性和场域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入探讨git与ssh config (多个git账户配置与连接)</title>
    <link href="/post/800844d7.html"/>
    <url>/post/800844d7.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用Git和GitHub &#x2F; Gitlab进行项目管理和代码托管时，开发者可能会遇到需要同时管理多个GitHub账户的情况。这种需求可能源于个人和工作项目之间的区分，或者参与多个组织的开发工作。然而，Git和SSH的默认配置并不直接支持轻松切换多个账户，这就需要一些额外的配置和策略来解决。</p><p>对于笔者，同时需要连接到github和gitlab，于是在ssh下面的config文件进行了配置。</p><h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>在进行github连接的时候，首先在<code>~/.ssh/config</code>配置了如下内容：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github<br>  HostName github.com<br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>  IdentityFile abc (a private key)<br></code></pre></td></tr></table></figure><p>运行情况：</p><ol><li><code>ssh -T github</code>, 成功</li><li><code>ssh -T git@github.com</code>，成功</li><li><code>git clone git@github.com:myusername/repo.git</code> (这个仓库是一个私有仓库)，失败。报错信息：</li></ol>  <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">git<span class="hljs-comment">@github.com: Permission denied (publickey).fatal: Could not read from remote repository.</span><br><span class="hljs-comment">Please make sure you have the correct access rights and the repository exists</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将.ssh&#x2F;configHost改为<code>github.com</code>, 情况3成功</li></ol><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><code>Host github</code>定义了一个SSH配置的别名<code>github</code>，这意味着当你使用SSH或Git命令与GitHub通信时，可以使用这个别名来<strong>引用整个配置块</strong>。即别名Host &#x3D; HostName + User + IdentifyFile。</p><p>基于这个原因，我们就理解了下面的图：</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20240410125934423.png" alt="image-20240410125934423" style="zoom:50%;" /><p>当<strong>直接通过ssh连接的时候，SSH可以通过Host找到HostName，也可以根据HostName找到同级下面的key</strong>，所以成功。</p><p>但是，</p><p>在使用<code>git clone</code>命令时，如果直接使用<code>git@github.com:USER/REPOSITORY.git</code>这样的URL，相当于提供了完整主机名，Git客户端内部会调用SSH客户端(而且用户名都是git)，此时SSH客户端，也会根据<code>~/.ssh/config</code>中的配置来尝试解析主机名<code>github.com</code>。如果找不到有关github.com的配置，就会报错。此时不会根据github.com找到同级的identify Key。</p><p>其实是合理的，因为如果像下面这样，有两个github账户，那么一个别名1，一个别名2，也无法找到需要哪个key，也就无法决定使用哪个账户clone。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># github1</span><br>Host github1<br>  HostName github.com<br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>  IdentityFile abc<br><span class="hljs-comment"># github2</span><br>Host github2<br>  HostName github.com<br>  <span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>  IdentityFile def<br></code></pre></td></tr></table></figure><p>所以必须手动提供这个别名，也就是必须改为<code>git@github:USER/REPO.git</code>。 这样的话，git里的ssh就可以从上到下找到正确的key</p><h2 id="问题回溯"><a href="#问题回溯" class="headerlink" title="问题回溯"></a>问题回溯</h2><p>谈到这里，我们就会发现，情况3失败是正常的，因为可能有多个github账户，于是现在问题变成了，情况2为什么可以？</p><p><code>ssh -vT git@github.com</code>，查看debug输出，发现其实这样能成功，无非是ssh把我本地的两个key都尝试提供了，然后第二个key刚好能连上。。。</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20240410132928617.png" alt="image-20240410132928617" style="zoom:50%;" /><p>甚至进一步<code>ssh -vT git@github</code>，发现也会同时尝试两个key，只不过是优先使用匹配到的key连接。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>别名 &#x3D;&#x3D; 下面的所有配置块总和</li><li>当通过 ssh 直接连接的时候，优先查看是否匹配到了config文件中的某一行<ol><li>如果在config文件中找不到，会尝试本地所有的key</li><li>(注意) 即使在config文件中找到，也会尝试所有key，但是优先尝试匹配到的key （体现了ssh客户端本身的兼容性</li></ol></li><li>当通过 git 调用 ssh 的时候，由于git权限更加严格，因此不会尝试所有的key，而是严格匹配config文件。所以使用git连接多个账户时，无法使用标准URL，而是必须替换为别名。</li><li>另外git还有个<code>gitconfig</code>文件，允许使用从Github仓库页面复制的标准url。可以免去把 github.com 改为自定义主机名的麻烦。</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>或许之后再研究下gitconfig</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://gist.github.com/oanhnn/80a89405ab9023894df7">https://gist.github.com/oanhnn/80a89405ab9023894df7</a></li><li><a href="https://zian999.github.io/zh/posts/2020/20200122-generate_ssh_key_and_ssh_config/">https://zian999.github.io/zh/posts/2020/20200122-generate_ssh_key_and_ssh_config/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Developer</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python @property decorator</title>
    <link href="/post/6541701.html"/>
    <url>/post/6541701.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>遇到 <code>@property</code> 属性相关的问题，详情为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 可以工作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abc&quot;</span><br>        <span class="hljs-comment"># print(type(self.get_a_array))</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.get_a_array:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str is not in array&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str is in array&quot;</span>)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_a_array</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;xyz&quot;</span>]<br>    <br><span class="hljs-comment">## 报错：TypeError: argument of type &#x27;property&#x27; is not iterable</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;abc&quot;</span><br>        <span class="hljs-comment"># print(type(cls.get_a_array))</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cls.get_a_array:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str is not in array&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;str is in array&quot;</span>)<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_a_array</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;xyz&quot;</span>]<br></code></pre></td></tr></table></figure><p>可以看到唯一的区别在于调用该属性的位置：一个在实例方法内，一个在类方法中。</p><p>加上类型的输出，得到类B中 <code>get_a_array</code> 属性为 <code>list</code>，而类A中<code>get_a_array</code>属性为<code>&lt;class &#39;property&#39;&gt;</code>，因此查阅相关文献，书写博客</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Python中，<code>@property</code>装饰器是一种用于创建只读属性的方法。它允许类的方法被当作属性来访问，这意味着你可以像访问数据属性一样访问这些方法，而不需要在方法名后加上括号。这种机制提供了一种更加优雅的方式来实现对类内部数据的封装和访问控制。</p><p>当你在类定义中使用<code>@property</code>装饰器时，你实际上是在创建一个描述符（descriptor）。描述符是Python中的一种协议，它允许对象自定义它们的属性访问。具体来说，当你使用<code>@property</code>装饰一个方法时，Python会创建一个属性对象，这个对象有一个<code>__get__</code>方法，该方法在访问属性时被调用。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@property</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_a_array</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>:<br>    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;xyz&quot;</span>]<br></code></pre></td></tr></table></figure><p>这里，<code>get_a_array</code>被定义为一个只读属性，它的值是一个列表<code>[&quot;abc&quot;, &quot;xyz&quot;]</code>。在类的实例上访问这个属性时，Python会自动调用<code>__get__</code>方法，返回方法的返回值。因此，在实例方法中，<code>get_a_array</code>的类型是<code>list</code>，因为实际上访问的是方法的返回值。</p><p>然而，在类方法中，情况有所不同。当直接通过类访问<code>get_a_array</code>时，实际上访问的是<strong>属性对象本身</strong>，而不是属性的值。这是因为在这种情况下，没有实例来调用<code>__get__</code>方法。因此，在类方法中，<code>get_a_array</code>的类型是<code>property</code>。</p><p>这种行为的根本原因在于描述符协议的工作方式。描述符协议定义了对象如何通过<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>方法来控制对其属性的访问。当属性被访问时，如果存在相应的描述符方法，Python会调用这些方法。在<code>@property</code>的情况下，只定义了<code>__get__</code>方法，这使得属性成为只读的。当通过实例访问属性时，<code>__get__</code>方法被调用，返回方法的返回值。但是，当通过类访问属性时，没有实例来调用<code>__get__</code>方法，因此你直接访问的是属性对象本身。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结来说，<code>@property</code>装饰器的行为依赖于它是如何被访问的——通过实例还是通过类。</p><p>这解释了为什么在实例方法中<code>get_a_array</code>的类型是<code>list</code>，而在类方法中其类型是<code>property</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>家庭网络设备与拓扑</title>
    <link href="/post/3e2ea961.html"/>
    <url>/post/3e2ea961.html</url>
    
    <content type="html"><![CDATA[<h2 id="拓扑"><a href="#拓扑" class="headerlink" title="拓扑"></a>拓扑</h2><p>ISP —&gt; 光猫 —&gt; 路由器 —&gt; 家用设备</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>internet service provider</p><p>运营商，比如中国移动 &#x2F; 联通 &#x2F; 电信</p><p>ISP的网线首先连接到光猫。网线通常是光纤，利用光的<strong>全反射</strong>不衰减特性进行传输信号。</p><p>光纤的布局通常是FTTH，全称光纤入户，一种光纤布局方式，将光纤直接引入用户的家庭或办公室，不作具体介绍。</p><h2 id="光猫"><a href="#光猫" class="headerlink" title="光猫"></a>光猫</h2><p>功能：实现光纤内光信号 和 数字信号的相互转换</p><p>（高级光猫也会有路由器功能，详细看下面路由器部分）</p><h3 id="概念区分：调制解调器"><a href="#概念区分：调制解调器" class="headerlink" title="概念区分：调制解调器"></a>概念区分：调制解调器</h3><p>传输介质：</p><ul><li>调制解调器通常用于通过电话线（DSL调制解调器）或有线电视线（电缆调制解调器）等传统的铜线传输数据</li><li>光猫使用光纤</li></ul><p>技术原理：</p><ul><li>调制解调器是基于调制解调技术（相关概念：调幅、调频、调相，分别通过调整载波信号的幅度、频率、相位来表示数字信号的变化。解调是逆过程）</li><li>光猫是基于光电转换技术</li></ul><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>光猫一般再连接一个路由器。</p><p>这里需要补充一个前提条件：典型家用路由器一般同时具备了内网IP和公网IP。这个前提条件等价于视频中的将LAN口抽象出一个交换机的操作。</p><h3 id="WAN口"><a href="#WAN口" class="headerlink" title="WAN口"></a>WAN口</h3><p>WAN &#x3D; <strong>Wide Area Network port</strong></p><p>光猫一般连接路由器的WAN口（路由器上颜色独一无二的口），通过这个连接，WAN口获取了公网IP。根据视频内容，两种方式：</p><ol><li>路由器通过PPPoE拨号，获取运营商的公网IP</li><li>光猫拨号，路由器得到光猫分配的内网IP</li></ol><p>Anyway结论是WAN口获取到了公网IP。</p><h3 id="LAN口"><a href="#LAN口" class="headerlink" title="LAN口"></a>LAN口</h3><p>LAN口连接家庭的其他设备（有线连接）。这里便需要上面提到的：典型家用路由器有内网IP和公网IP。我们需要用到内网IP。</p><p>为什么需要路由器的内网IP？</p><ul><li>管理维护方便</li><li>网络结构简单：从家庭外看，只看到了路由器</li><li>ipv4不够用</li></ul><p>如何获取内网IP？</p><p>路由器的内网IP自己设置。一般是192.168.0.1。下图是我家路由器的LAN口IP，可以手动设置</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20240207222433426.png" alt="image-20240207222433426" style="zoom:50%;" /><h3 id="内外转换-—-NAT"><a href="#内外转换-—-NAT" class="headerlink" title="内外转换 — NAT"></a>内外转换 — NAT</h3><p>现在我们路由器有了公网IP和内网IP，需要在二者之间进行转换。</p><p>（note：可能存在多个公网IP — 我拉了多个网线；多个内网IP — 多个路由器）</p><p>NAT定义：在私有网络（如家庭网络或企业内部网络）和公共网络（如互联网）之间转换 IP 地址。</p><p>动机：</p><ol><li>IPv4不够</li><li>隐藏内部网络结构，防火墙</li></ol><p><strong>NAT 类型</strong>：</p><ul><li><strong>静态 NAT</strong>：手动配置静态映射，将内部 IP 地址与公共 IP 地址进行一对一的映射。适用于需要固定映射的场景。</li><li><strong>动态 NAT</strong>：根据内部设备的使用情况动态分配公共 IP 地址。适用于需要动态分配 IP 地址的场景。</li><li><strong>PAT（端口地址转换）</strong>：通过使用不同的端口号来区分内部设备，允许多个内部设备共享单个公共 IP 地址。家庭最常用</li></ul><p>注意：NAT允许级联，NAT一次之后再NAT。一层层封装</p><h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><p>家庭内连接到网络的设备。手机，iPad，电脑，笔记本</p><p>查看IP 命令行：终端输入 <code>ipconfig</code></p><h3 id="获取IP"><a href="#获取IP" class="headerlink" title="获取IP"></a>获取IP</h3><ol><li>静态IP</li><li>DHCP（视频，或者可能另一篇文章）</li></ol><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>连接两个不同网络的设备，负责转发数据包。</p><p>在家庭网络中，网关通常是路由器的IP地址，用于将内部网络与外部网络（互联网）连接起来。</p><p>查看网关地址命令也是 <code>ipconfig</code> ，会发现通常就是路由器的内网IP。</p><p>在浏览器输入网关（路由器内网IP），就可以管理家庭内的所有网络设备。</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20240207222509665.png" alt="image-20240207222509665" style="zoom:50%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>伴随着 ISP —&gt; 光猫 —&gt; 路由器 —&gt; 家用设备 这个拓扑结构，简要解释了其中的细节。</p><p>引用：<br>该封面图片由<a href="https://pixabay.com/zh/users/jurakovr-3023036/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=5438427">Юрий Коврижных</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=5438427">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>技术</tag>
      
      <tag>家庭网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不同笔记特点</title>
    <link href="/post/24fb4eec.html"/>
    <url>/post/24fb4eec.html</url>
    
    <content type="html"><![CDATA[<h2 id="三种笔记"><a href="#三种笔记" class="headerlink" title="三种笔记"></a>三种笔记</h2><ul><li>纸+笔</li><li>iPad+pencil</li><li>notion等笔记软件&#x2F;博客</li></ul><h2 id="归纳纬度"><a href="#归纳纬度" class="headerlink" title="归纳纬度"></a>归纳纬度</h2><ul><li>可持久性</li><li>可修改性</li><li>思路展示</li><li>正式性</li><li>书写方便性</li><li>Accessibility（指突然想看某一篇笔记，找到它的难以程度，包括纸张&#x2F;设备&#x2F;查询）</li><li>分享</li></ul><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20240101224203767.png" alt="image-20240101224203767"></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Pipeline: 电子笔记留存思路，notion笔记格式化&amp;持久化</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>笔记</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学教育的CICD</title>
    <link href="/post/8d71a75.html"/>
    <url>/post/8d71a75.html</url>
    
    <content type="html"><![CDATA[<h2 id="论点：大学教育是一场大型的CICD"><a href="#论点：大学教育是一场大型的CICD" class="headerlink" title="论点：大学教育是一场大型的CICD"></a>论点：大学教育是一场大型的CICD</h2><p>随着教育产业的高度成熟化，大学生活似乎变成了一条预定的道路，从大一入学开始，我们就仿佛踏上了一个精心设计的流水线。这个CICD<em>（Continuous Integration &amp; Continuous Deployment）</em>的比喻或许能够准确地描述现代大学的经历。为何高等教育演变成了这样的pipeline流水线呢？</p><h2 id="理想教育"><a href="#理想教育" class="headerlink" title="理想教育"></a>理想教育</h2><p>教育是一个很宏大的概念，<strong>感性来说</strong>，我认为教育应该回答&#x2F;引导几个问题：人为什么是人，你可以成为什么人，你想成为什么人。</p><blockquote><p>中国人缺少的三种教育：性的教育，爱的教育，死亡的教育。</p><p>这三种概念，分别对应着人生的三个支点：身体完整、灵魂丰沛、生命价值。</p><p>——本段话来源于网络</p></blockquote><p><strong>理性来说</strong>，我所讨论的教育可以分为两种：专科教育和高等教育</p><p><strong>1. 专科教育（一技之长）:</strong> 专科教育旨在培养学生特定领域的专业技能，使其能够在特定领域内成为专业人才。</p><p><strong>2. 高等教育（综合性技术）:</strong> 高等教育更注重培养学生的综合性能力，包括批判性思维、团队协作、创新等方面。这有助于适应多变的社会环境，不是某种领域的人才，而是可以成为多种领域的人才。</p><h2 id="现实教育"><a href="#现实教育" class="headerlink" title="现实教育"></a>现实教育</h2><blockquote><p>爱撒野的小孩，被教得很乖。——杨千嬅 歌曲《最好的债》（笔者有断章取义之嫌）</p><p>现代教育对孩子是残忍的，我们逼迫他们为了虚无缥缈的以后而牺牲近在眼前的需求，用各种限制加重孩子的负担，让他受苦，为了永远享受不到的遥远幸福做准备。 —— 卢梭</p></blockquote><p>然而，现实教育与理想相去甚远。一步步的偏差，使得大学生踏上了CICD的道路。</p><h3 id="现实教育的CICD过程"><a href="#现实教育的CICD过程" class="headerlink" title="现实教育的CICD过程"></a>现实教育的CICD过程</h3><ol><li><strong>初高中阶段</strong>：小镇做题家，被试卷 &amp; 考试充填。主要由关键的初一，关键的初二，关键的初三，关键的高一，关键的高二，关键的高三组成。</li><li><strong>入学阶段</strong>：通过高考进入大学，成为流水线的初始阶段。一群freshman对于未来充满憧憬和希望。</li><li><strong>专业学习</strong>：在经历了九年寒窗之后，学生们第一次如此真切地感受到属于自己的时间。同时，也开始接触各种学长总结提炼出来的文档 &amp; 经验 &amp; 道路，即使不懂，可是却被告知，那是大多数人走过的路，不会错的。从此，几条鲜明的道路展现在每一个学生面前：<ol><li>家里有矿，继承家产，不在此文讨论中</li><li>之后打算工作 &#x2F; 考研。此时平时成绩就无所谓了，于是可以平时<strong>持续性摆烂</strong>，只需要按部就班去签到，上着可听可不听的课程，和同学们合作完成一点作业；期末<strong>间歇性冲刺</strong>，及格便万事大吉。此时大多数时间主要被娱乐工具充填，比如短视频 &#x2F; 小说 &#x2F; 游戏等。</li><li>之后打算保研 &#x2F; 出国。此时平时成绩成为关键一环，每次出勤&#x2F;回答问题&#x2F;pre展示<strong>毕恭毕敬</strong>，期末的作业也要卷出水平，卷出高度，卷出风采，卷得让老师不好意思不给你优。参加比赛，参加活动，丰富履历，拿奖学金，最终成为公众号里“神仙宿舍”，“全体保研”文章的主人公。</li><li>当然也有一些其他情况，比如医学生，其本身的高强度课程安排，导致单纯是课程本身就已经占用了很多时间，加上本身5+3培养，导致与上面的情况不完全一样。</li></ol></li><li><strong>(Optional) 实习阶段</strong>：部分学校可能会要求实习，学生们第一次走出校外，到企业中工作，学习新知识，以及嫌弃自己课内什么有用的都没学到。</li><li><strong>秋招 &#x2F; 考研 &#x2F; 出国</strong>：到了大三下&#x2F;大四上，本科阶段逐渐步入尾声，学生们开始寻找出路。工作的人士要开始秋招，考研的人士开始泡图书馆，出国的人士也在考语言，准备材料。大家都开始忙碌起来。</li><li><strong>找到工作 &#x2F; 保研 &#x2F; 上岸</strong> ：大学生活的高潮是找到一份理想的工作，或者选择读研，将找工作这个问题留给三年后更加有智慧的自己。至此本科开始告一段落。</li></ol><h3 id="成为CICD的原因"><a href="#成为CICD的原因" class="headerlink" title="成为CICD的原因:"></a>成为CICD的原因:</h3><p>让我们先做几个假设：</p><ul><li>人需要必需品（衣食住行 + 看病），所以<strong>需要工作</strong></li><li>人需要消费品（手机电脑 &#x2F; 汽车）+ 消费主义盛行，所以<strong>需要高薪的工作</strong></li><li>人太多，资源逐渐有限，所以<strong>需要竞争</strong></li></ul><p>当这几个假设合理后，继续讨论原因：</p><ol><li><strong>工作与学历挂钩：</strong> 在过去的几十年中，伴随着中国经济的高速增长，高学历往往与稳定高薪的工作划上等号。在蓝领工作环境与收入都处于劣势的情况下，人们自然想追求白领工作，而高等教育成为好工作的前提条件。</li><li><strong>传统观念与阶级流动：</strong> 中国古代有“万般皆下品，唯有读书高”的名言，几千年的科举制，是社会阶层流动的重要手段。到了现代，在原因1的背景下，越来越多的人将读书变为唯一的出路。我认为，<strong>教育是中产阶级延续财产的不二法门，更是底层民众逆天改命的唯一途径</strong>。</li><li><strong>社会评价体系单一：</strong> 社会对个体价值的评价往往基于学历和职业。在就业环境不好的现实环境下，大学生感受到来自社会的巨大压力，推动他们沿着事先规划好的路径前进。</li><li><strong>教育产业化与竞争激烈:</strong> 随着教育的商业化趋势，越来越多人获得本科教育，导致学历贬值，就业竞争激烈，学生和家长面临的压力不断增加。大家不得不内卷。</li><li><strong>教育脱离学生</strong>：课程乏味，外界诱惑太多，导致学生难以在课堂上集中精力。</li></ol><h3 id="能否改变-amp-如何改变？"><a href="#能否改变-amp-如何改变？" class="headerlink" title="能否改变 &amp; 如何改变？"></a>能否改变 &amp; 如何改变？</h3><h4 id="学生"><a href="#学生" class="headerlink" title="学生"></a>学生</h4><ol><li><strong>勇于探索</strong>：尽可能多地接触新鲜事物 &amp; 新鲜知识，培养兴趣爱好，<strong>增加知识的宽度</strong>。不能被大数据牵着走，打破信息茧房。</li><li><strong>深入钻研</strong>：在有了一定的兴趣爱好后，发掘自己的热情，并在热情领域深耕，<strong>增加知识的深度</strong>。</li><li><strong>必要的运气</strong>：积德行善吧，没什么好办法</li></ol><h4 id="老师"><a href="#老师" class="headerlink" title="老师"></a>老师</h4><ol><li>老师花更多时间备课：停止使用老旧PPT&#x2F;知识，尽量传输较新的知识</li><li>授课时与实际相结合：停止死记硬背 与 填鸭式教学</li><li>停止无意义的点名签到：域民不以封疆之界，固国不以山溪之险，威学生不以签到点名之利</li></ol><h4 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h4><ol><li><strong>与工业界结合</strong>：放下象牙塔的骄傲，与工业界合作，联合培养学生</li><li><strong>强调人文素养:</strong> 加强对人文素养的培养，使学生在专业技能之外也具备更全面的能力，更好地适应社会的发展。</li><li><strong>兴趣导向</strong>：停止教学大纲导向</li></ol><h4 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h4><ol><li><strong>拓宽评价标准:</strong> 改变对学历的单一评价标准，引入更多多元化的评价体系，包括技能、经验和创新能力。</li><li><strong>提倡终身学习:</strong> 鼓励学生树立终身学习的观念，不仅仅在大学期间，而是在职场中持续提升自己。</li></ol><p><strong>结语:</strong> 大学生活虽然现在更像是一条流水线，但我们有机会通过改革教育体系，打破既有模式，使得大学真正成为学生综合发展的舞台。这需要学生、老师、学校和社会的共同努力，以确保每个大学生都能够在这个社会上找到属于自己的独特路径。</p><p>该图片由<a href="https://pixabay.com/zh/users/nikolayhg-3248/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=105709">Nikolay Georgiev</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=105709">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教育</tag>
      
      <tag>大学</tag>
      
      <tag>社会</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么不想生育?</title>
    <link href="/post/9c716de4.html"/>
    <url>/post/9c716de4.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>生育意愿在下降。</p><p>曾经崇尚多子社会的儒家文化地区，现在谈生色变。</p><blockquote><p>为什么女性受教育程度高了之后，就不愿意生？</p></blockquote><p>答案蕴含在问题本身，也就是为什么对于男性来说没有这个问题？ 因为传统社会以及传统观念中，默认生育养育中的再生产活动，是由女性来完成的。</p><h2 id="再生产的不平等"><a href="#再生产的不平等" class="headerlink" title="再生产的不平等"></a>再生产的不平等</h2><p>生、养、家务、照料这些活动</p><p>区别于直接产生财富货币的生产，再生产可以理解为是提供劳动力的前提</p><p>受教育后不愿意从事再生产活动</p><p><strong>如果是男女在生育上的不平等导致生育意愿降低，那么平权能彻底解决问题吗？</strong></p><p>可能只能解决一部分的问题，就是那部分本身有意愿，只不过受到职业发展阻碍的女性。 但是平权理论没有告诉我们权利平等了之后，我们再一起做些什么。</p><p>平权是扫除障碍，但无法解决内驱力不足的问题。</p><h2 id="内驱力不足"><a href="#内驱力不足" class="headerlink" title="内驱力不足"></a>内驱力不足</h2><p>原因</p><ol><li><p><strong>对于生育的无知</strong></p><ul><li>缺乏对生育的认知，使我们难以具象地构想生育，也难以渴望生育</li></ul></li><li><p><strong>生育者变成旁观者</strong></p><ul><li>让专业人士来！比如，现在女性在生育时绝大多数是医院，但是四脚朝上的仰卧姿势，很难用力生产，容易增加产程。但是这是最有利于医生和护士介入的一个姿势</li></ul></li></ol><p>这种无知，被动，旁观者的姿态是如何形成的？<strong>降低新生儿死亡率</strong>这个原因似乎无法辩驳，但实际上我们正在越来越多依靠权威与专业。如果安全是唯一考虑因素，那么为什么那么多仰卧生育？</p><h3 id="生命政治"><a href="#生命政治" class="headerlink" title="生命政治"></a>生命政治</h3><p>“对于身体的规训和对于人口的管控构成了国家权力围绕生命展开的两极”——福柯</p><p>生命政治的观点，国家机器变成了生命的管理者和规训者。</p><ol><li>身体变成了生产线的产品，必须“合格”、“有用”——优质劳动力</li><li>人口变成了各种需要管理的指标。生变成了出生率，死亡变成了死亡率，人变成了人口总量</li></ol><p>国家机器希望所有人按照既定的规范去生育那个理想的数量</p><p>不在医院生？孩子在家里学习？——现代体系无法容忍。</p><p>生命政治，为什么适得其反？（越管理人口生育率越下降）</p><p><strong>因为越接受现代教育，越认为再生产活动是没用的，要追寻更有价值的活动。</strong></p><p>why？</p><h3 id="现代教育"><a href="#现代教育" class="headerlink" title="现代教育"></a>现代教育</h3><p>现代教育聚焦于能力上（工具理性），因为<strong>现代教育的目的是让人变成可以执行任务的劳动力</strong></p><p>工具理性可以完成分门别类的任务，但是养育，需要的是共情，聆听，感知力，谁教你？</p><p>教和不教，已经有了价值排序。</p><p>教的是工具理性，因为它可以直接产生经济资本</p><ul><li>再生产没有回报，通过对再生产的无偿化和贬值，是资本主义对于再生产活动的剥削；可是再生产活动，恰恰是资本主义能够运作起来的前提。</li><li>再生产被认为没有价值，所以无法得到自我认同和成就感，所以女性有的选的时候，自然不会选择。（生产是可以获得价值的，比如货币，然后就可以从消费中获得快乐</li></ul><p>备考家庭的矛盾：投资与回报的逻辑对于亲子关系无孔不入，与亲子关系所要求的共生矛盾</p><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><p>如何解决？</p><p>肯定再生产？</p><p>非此即彼往往是因为考虑面太少</p><p>改变生育模式的范畴？</p><p>老龄化养老的其他解决方法</p><p>资本主义的最大胜利就是打败了人类的想象力——大卫·格雷伯</p><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2><p>原视频链接：<a href="https://www.bilibili.com/video/BV1q8411r75U/?share_source=copy_web&vd_source=c66a2d9c42b77abf0d1275efa753a2f2">为什么我们不想生孩子了？｜谢晶 一席第1030位讲者</a></p><p>该图片由<a href="https://pixabay.com/zh/users/cherylholt-209609/?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=623417">Cheryl Holt</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&utm_medium=referral&utm_campaign=image&utm_content=623417">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>女性</tag>
      
      <tag>哲学</tag>
      
      <tag>教育</tag>
      
      <tag>生育</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>六种消费陷阱</title>
    <link href="/post/d0010ad1.html"/>
    <url>/post/d0010ad1.html</url>
    
    <content type="html"><![CDATA[<h2 id="减少消费，6种消费陷阱"><a href="#减少消费，6种消费陷阱" class="headerlink" title="减少消费，6种消费陷阱"></a>减少消费，6种消费陷阱</h2><ol><li><p><strong>用消费代替本该付出的努力</strong></p><ul><li><p>比如用买跑步机代替每天跑步</p></li><li><p>盲目报班买资料</p></li></ul></li><li><p><strong>标榜生活的消费</strong></p><ul><li>社会意识的前提：买得起什么，决定我是什么阶层</li><li>消费者按消费能力把自己分为了三六九等，商家只需要在商品定位上也分为三六九等，不同定位的商品收割不同层级的韭菜</li><li>有了等级也就有了鄙视链，人们就想超越层级 + 信用卡</li><li>消费者社会：定义一个人的不是工作能力和社会贡献，而是消费水平</li></ul></li><li><p>贩卖焦虑的消费（健康焦虑，知识焦虑，容貌焦虑，教育焦虑）</p><ul><li>注意饮食、努力锻炼、健康作息</li><li>VS</li><li>保健品，鸡娃</li></ul></li><li><p>加快消耗的消费</p><ul><li>牙膏厂商：增加销量，将管口直径增加1mm</li><li>计划报废<ul><li>手机：提高软硬件更新换代的频率 &amp; 提高维修成本</li></ul></li></ul></li><li><p>拿铁效应的消费</p><ul><li>生活中一些可有可无的消费（比如拿铁</li><li>不在于习惯本身，而是习惯会提高你对生活的要求，不向细节妥协</li></ul></li><li><p>煽动情绪的消费</p><ul><li><p>直播带货</p><ul><li>免费送很便宜的东西</li><li>限时限量，物以稀为贵</li><li>愿意信任自己的主播和人设</li></ul></li><li><p>同情人设</p><ul><li>xx要对自己&#x2F;伴侣&#x2F;父母好一点</li></ul></li></ul></li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>人生中80%的事情可以用钱来解决，剩下20%的事情可以用钱来缓解。</p><p>对于普通人来说，钱最大的作用不是增加快乐，而是缓解困难。</p><p>而那些不需要消费就可以获得的快乐，才是我们真正的快乐。</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消费</tag>
      
      <tag>生活</tag>
      
      <tag>积蓄</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生语句</title>
    <link href="/post/fa44022b.html"/>
    <url>/post/fa44022b.html</url>
    
    <content type="html"><![CDATA[<h2 id="歌词"><a href="#歌词" class="headerlink" title="歌词"></a>歌词</h2><ul><li>游客是你，风景是我，无法避免，让你经过。蔷薇如期盛放，游人如期过路，情人如期相爱，然后分开，仿佛命书中批过。——《游客》</li><li>青春的快餐只要求快不理哪一家，哪有玩味的空档来欣赏细致淡雅。——《苦瓜》</li><li>开始时捱一些苦，栽种绝处的花，幸得艰辛的引路甜蜜不致太寡。——《苦瓜》</li><li>从何时你也学会不要离群，从何时发觉没有同伴不行，从何时惋惜蝴蝶困于那桃源，飞多远有谁会对他操心。                       ——《任我行》</li><li>亲爱的，等遍所有绿灯，还是让自己疯一下要紧，马路戏院商店天空海阔，任你行。 ——《任我行》</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>经济基础决定上层建筑，生产力决定生产关系。 ——《共产党宣言》</li><li>男人的极大幸运在于，他不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；她不被要求奋发向上，只被鼓励滑下去到达极乐。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。 —— 波伏娃《第二性》</li></ul><h2 id="影视剧"><a href="#影视剧" class="headerlink" title="影视剧"></a>影视剧</h2><ul><li>阳光洒在肩头，而我们彷佛一位自由人。——《肖申克的救赎》</li></ul><h2 id="名人"><a href="#名人" class="headerlink" title="名人"></a>名人</h2><ul><li>吏不畏吾严而畏吾廉，民不服吾能而服吾公。—— 明代曹端《官箴》</li><li>He who does not move does not notice his chains. ——Rosa Luxemburg</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>当一个人只有锤子的时候，他看什么都像是钉子</li></ul>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人生语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从头开始配置一台电脑（开发版）</title>
    <link href="/post/e2e1dfa2.html"/>
    <url>/post/e2e1dfa2.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于开发人员来说，能够用到的工具还是有限的，但是每次lazy install也比较麻烦，所以写一篇博客，希望能条理清晰地罗列出从拿到电脑，到上手开发的一系列步骤。</p><p>对于开发人员，命令行是必不可少的，但是鉴于windows和Unix的命令相差较大，因此当遇到不同点时，都会分出两者都区别。</p><p>目前我的开发语言基本是Python + Windows &#x2F; Linux 切换 + VSCode &#x2F; Pycharm 切换。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><a href="https://www.python.org/downloads/">Python</a></h3><ul><li><p><strong>Linux</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubuntu:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">location: /usr/bin/</span><br>apt list python*<br>sudo apt-get update<br>sudo apt-get install python3.x<br>python3.x --version<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将python命令默认指向给定的版本（符号链接）</span><br>sudo ln -s /usr/bin/python3.x /usr/bin/python<br></code></pre></td></tr></table></figure></li><li><p><strong>Windows</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Windows</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">location: <span class="hljs-string">&quot;C:\Program Files\Python3.x&quot;</span></span><br><br>powershell:<br>py -0 # show all installed python<br>需要手动设置环境变量<br></code></pre></td></tr></table></figure></li></ul><h3 id="Pip"><a href="#Pip" class="headerlink" title="Pip"></a>Pip</h3><p> 一般随着python自带</p><ul><li><p>Linux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://bootstrap.pypa.io/get-pip.py<br>python get-pip.py<br><span class="hljs-meta prompt_"># </span><span class="language-bash">想要哪个python环境下的pip，就用哪个python去执行这个文件</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><ol><li><p>安装</p><p><strong>Mac</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Mac 默认已经安装ssh服务端，确认是否开启</span><br>sudo systemsetup -getremotelogin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Remote Login: On 表示已经开启</span><br></code></pre></td></tr></table></figure><p><strong>Ubuntu</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install openssh-server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">check <span class="hljs-keyword">if</span> start</span><br>sudo systemctl status ssh<br><span class="hljs-meta prompt_"># </span><span class="language-bash">(active(running))</span><br></code></pre></td></tr></table></figure><p><strong>Windows</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">open settings<br>click application<br>find &quot;Optional Function&quot;<br>Get-Service sshd<br></code></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Connect:</span><br>Host xxx # 别名<br>HostName ip/domain<br>User username<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;email@example.com&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">gengerate a key and <span class="hljs-keyword">then</span> transfer to server</span><br>ssh-copy-id id ./id_ed25519.pub server<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Or, copy the public key into authorized_keys <span class="hljs-keyword">in</span> server</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a><a href="https://git-scm.com/downloads">Git</a></h3><ol><li><p>下载git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Ubutun</span><br>sudo apt-get update<br>sudo apt-get install git<br>git --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Mac</span><br>brew install git<br>git --version<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Windows</span><br>一般是通过exe文件<br></code></pre></td></tr></table></figure></li><li><p>配置git需要的环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br><br>ssh-keygen -t ed25519 -C &quot;email@example.com&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">之后可以把生成的公钥文件复制到github上</span><br><br>vim ~/.gitignore_global<br>git config --global core.excludesfile ~/.gitignore_global<br></code></pre></td></tr></table></figure></li></ol><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ol><li><p>安装</p><p><strong>Mac</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install vim<br></code></pre></td></tr></table></figure><p><strong>Ubuntu</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install vim<br></code></pre></td></tr></table></figure><p><strong>Windows</strong></p><p>手动安装，网址：<a href="https://www.vim.org/download.php">https://www.vim.org/download.php</a></p></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp .vimrc server:<br></code></pre></td></tr></table></figure></li></ol><h3 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h3><ol><li><p>安装</p><p><strong>Mac</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install tmux<br></code></pre></td></tr></table></figure><p><strong>Ubuntu</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install tmux<br></code></pre></td></tr></table></figure><p><strong>Windows</strong></p><p>无</p></li><li><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scp .tmux.conf server:<br></code></pre></td></tr></table></figure></li></ol><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><blockquote><p>IDE – 通过登录账号来同步设置和插件</p><ul><li>PyCharm</li><li>VSCode</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Developer</tag>
      
      <tag>Linux</tag>
      
      <tag>git</tag>
      
      <tag>Python</tag>
      
      <tag>ssh</tag>
      
      <tag>VIm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Education</title>
    <link href="/post/59fbdc71.html"/>
    <url>/post/59fbdc71.html</url>
    
    <content type="html"><![CDATA[<p>现代教育对孩子是残忍的，我们逼迫他们为了虚无缥缈的以后而牺牲近在眼前的需求，用各种限制加重孩子的负担，让他受苦，为了永远享受不到的遥远幸福做准备。 —— 卢梭</p><p>教师是名副其实的艺术家，但作为一位艺术家不是指他可以任意打造，行塑学生。教育者在教学时所施展的艺术，是让学生们得以可能成为他们自己。 —— Paulo Freire</p><p>该封面图片由<a href="https://pixabay.com/zh/users/weisanjiang-1916748/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2787754">潜辉 韦</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=2787754">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教育</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Plague of Tale - Requiem 通关感言</title>
    <link href="/post/d327916c.html"/>
    <url>/post/d327916c.html</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>作为《瘟疫传说 — 无罪》的续作，本作接续前作的故事，阿米西亚和雨果逃出了支离破碎的家园，一路南下，寻找拯救雨果的关键秘密。</p><p>（本文含有剧透内容，在此提醒）</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="黑死病"><a href="#黑死病" class="headerlink" title="黑死病"></a>黑死病</h2><p>著名瘟疫，历史上共三次大流行，第一次是公元541年东罗马帝国的<a href="https://zh.m.wikipedia.org/zh-cn/%E6%9F%A5%E5%A3%AB%E4%B8%81%E5%B0%BC%E5%A4%A7%E7%98%9F%E7%96%AB">查士丁尼大瘟疫</a>，第二次是14世纪英法百年战争期间的鼠疫，第三次则在19世纪中叶。</p><p>源头来源于鼠疫杆菌，但游戏中则将源头放在了一个成为马库拉的邪恶力量中，它能够控制鼠群。马库拉每次都会找到一个新生儿，在他成长过程中阶段性爆发，同时也会带来鼠群和瘟疫。主人公之一雨果便是现在的携带者。</p><h1 id="玩法"><a href="#玩法" class="headerlink" title="玩法"></a>玩法</h1><p>本系列是线性关卡生存游戏，随着剧情推进，解谜、潜行、战斗娓娓展开，与古墓丽影风格相似。相比前作，本作的战斗系统丰富了很多，有了更多的技能，自己的天赋升级也有手动升级和被动升级两种。虽然战斗技能丰富了，但敌人AI的智能水平仍然不高，战斗方式与前作基本一致。制作组在相对重复的战斗过程与新颖的战斗技巧之间努力寻求着微妙的平衡。</p><p>如果说前作的阿米西亚（女主人公）就像是古墓丽影9的劳拉，两个人都是在懵懵懂懂的情况下，被迫应对着危险的情况；那么本作与古墓丽影·崛起则也有一致性，两位主人公在经历了一系列的战斗后，都已经成长为娴熟机敏的战士，都知道了自己为什么而前进，都有了目标与方向。</p><p>当然还需要感谢制作组提供的无敌模式，帮助我这个手残党两次渡过难关</p><h1 id="画质"><a href="#画质" class="headerlink" title="画质"></a>画质</h1><p>画质很好，可惜电脑显卡配置不够高，画质、分辨率与帧率无法兼得，在3060显卡下，游戏实际体验如下：</p><ul><li><p>分辨率：4k（3840 x 2160）</p></li><li><p>画质：中（关闭光线追踪）</p></li><li><p>dlss：自动（适合不想重复测试的人）</p></li><li><p>帧率：平均40帧</p></li></ul><p>总体体验还好，由于不是FPS游戏，因此不会有很大的卡顿现象。</p><p>除此之外，从画面内容上来说，相比前作还是有很大的进步。首先场景类型变多了，除了前作有的城堡村庄之外，增加了海洋、山洞等更多场景，有很多地方与古墓丽影的场景十分相似。如果说前作更多的是鼠群下的压抑与绝望，那么本作后期在加上烟雾的效果下，更多的展现了一种宏大场面下荒凉的景象。</p><h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>音乐也与游戏的背景和场景十分契合，他的开场音乐是我这么多游戏中最喜欢的，导致打开游戏后经常一直听音乐，迟迟不能开始游玩。该宏大的宏大，该悲伤的悲伤，该愉快的愉快。官方也放出了音乐的视频，相信他的音乐在以后一定会是一种“DNA动了”</p><h1 id="与一代对比"><a href="#与一代对比" class="headerlink" title="与一代对比"></a>与一代对比</h1><ul><li>画面：场景类型更加丰富，更加荒凉宏大</li><li>玩法：技能增加，玩法更多样</li><li>音乐：很棒</li><li>主要内容：一代重点渲染姐弟俩的感情逐渐加深的过程，而本代侧重于共同的冒险，正是因为有了前一代对于二人深厚感情的铺垫，所以本代中二人的很多选择才变得自然而然</li></ul><h1 id="升华章节"><a href="#升华章节" class="headerlink" title="升华章节"></a>升华章节</h1><p>在倒数第二章节中（实际上是主要剧情的结局），经历了十分困难的一个片段。当姐姐去找弟弟时，落入了幻境中，在弟弟的暗示下，姐姐知道了这是幻境。但当遇到一波波的老鼠巨人时，却发现这东西根本就打不完。姐姐站在火堆中，而周围的老鼠巨人却越来越多，我当时玩的时候还是很无奈的，这东西根本就打不过啊，我怎么打？第一次奋力抗争，最后被湮灭，第二次我想着要不看看让老鼠吞噬如何，结果还是失败，第三次无奈地看了看攻略，却发现要结束，必须要把自己身前的火堆熄灭。。。</p><p>坚持很困难，但是当坚持了100次以后，坚持第101次就不是那么困难，此时更困难的，是在第101次放弃，明白有些东西自己无法抗争，无力改变。</p><p>在铺垫了将近两部作品后，姐姐终于发现，自己之前的努力依然没有用，到了结尾，弟弟依然变成了最差的结局。此时一直固执的姐姐，终于在经历一波又一波的老鼠后，选择了放弃。。。</p><p>于是最终，姐姐只能做出了最艰难的决定。</p><p>冒险了一路，经历无数次希望和失望，最终却依然无解，变为绝望。这是痛苦的，也是悲哀的。但或许冒险途中的那些欢笑，那些片刻惬意，那些陪伴与鼓励，才是我们永远的财富。</p><h1 id="口碑分化分析"><a href="#口碑分化分析" class="headerlink" title="口碑分化分析"></a>口碑分化分析</h1><p>在某站的视频中，能够见到众多的评论富含恶意与不解，而在steam上评分却较高。除去官方推荐配置为3070——如此之高之外，我认为对于复杂人性的描述才是大家不愿面对的话题。</p><p>对于妈妈来说，作为炼金术士，那么她所相信的，就只有古籍与科学的代表—炼金术，她也一直坚信需要用科学来打败马库拉。因此她将希望寄托在学会身上，这也是成年人的正常想法，解决问题需要先从逻辑出发，是什么，为什么，怎么办的三部曲一个也不能少。</p><p>对于姐姐来说，经历了前作与弟弟的生死离别，两人的感情是很深的，于是当学会的人使雨果痛苦时，姐姐很难平静下来。两人的感情也使得姐姐相信雨果梦中的海岛，于是两人最终选择与妈妈分开，独身前往海岛，可能看着有些怪异，但这也正是孩子所能理解的世界，只能走一步算一步。</p><p>阿诺德——雇佣兵头子，一开始追杀阿米西亚，后来为了除掉伯爵，选择与弟弟和阿米西亚合作，一路并肩战斗。这里有一个很多人吐槽的点，阿诺德一看见伯爵这个老仇人，就想让雨果召唤鼠群，阿米西亚不愿，阿诺德只能自己硬刚。当最后找到正在打斗的两人时，阿米西亚一个石头把杆子打倒，直接撂倒了阿诺德。于是引来很多讨论，认为属于痛杀友军，这里只能说人性如此了。阿诺德与伯爵有大仇，见到后当然十分生气，而先前与雨果签订的口头契约正是兑现的时候。作为阿米西亚，一上岛就让自己的弟弟和伯爵硬刚，那么后续在岛上探索马库拉的线索将十分困难，并且这个契约是阿米西亚昏迷状态下签订的，阿米西亚自然有弟弟被欺骗的感觉，于是只能帮助伯爵。作为雨果，在姐姐昏迷的情况下，为了让阿诺德救姐姐，签订契约也是可以理解。问题在于需要搞清楚两者之间的关系，到底是属于契约关系，还是属于伙伴关系。如果是契约关系，那么就应该是你救我姐姐，我帮你做掉仇人；而如果是伙伴关系，那么就需要互相帮助，并且一定程度上是不求回报的。阿诺德的初衷是借助雨果之手报仇，作为回报他也帮忙救了姐姐，在他看来，这是一个你情我愿的契约，我帮你完成了你的目的，那你也应该帮我。而在观众看来，既然是并肩战斗，那么两人应该是伙伴关系，那么朋友有难的时候，你怎么可以扔下不管呢？这与伙伴关系中的道义是相违背的。人性的复杂在此处徐徐展开，让人应接不暇，很容易陷入愤怒与不解的深渊。</p><p>人性是复杂的，人与人之间的关系也是复杂的。每个人都有自己的立场，都有自己的想法，都有自己的利益关系；而每个人都不能预知未来，都只能将不久的过去作为不远的将来的近似，每个人都想让自己和自己所爱之人能够利益最大化，做出当下最贪心的选择。在这其中，人与人之间的利益难免有所冲撞，有所摩擦。</p><p>相比于一代，最终灭掉了宗教审判所的头子，虽然赢得的赞赏不多，但至少没有很多喷的人。但是对于第二部的不满较多，我认为这与正义与邪恶的立场有关。</p><p>在第一部中，由于姐弟二人本来就是平民，是宗教审判所破坏了他们的生活，破坏了他们的家庭，杀死了他的父亲，此时绝对的邪恶已然昭然若揭，最终我们则代表正义消灭了邪恶。在游戏中我们喜欢什么，我们喜欢绝对的正义，而我们只能扮演绝对的正义。游戏中总要有一个绝对的邪恶，或者是不会说话的“怪兽”，而我们所要做的，就是代表正义，将任何邪恶绳之以法。我们的爽感，是因为在那一瞬间，我们代表了绝对的正义，消灭了绝对的邪恶，我们脱去凡胎，化作圣人，在一刻的虚假中获得了永恒的超脱。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p><strong>希望这片土地铭记你的深情，铭记你的奉献与牺牲。</strong></p><p>祝愿所有在瘟疫中遇难的人，也祝愿雨果弟弟，灵魂安息</p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Game</tag>
      
      <tag>黑死病</tag>
      
      <tag>瘟疫传说</tag>
      
      <tag>RPG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System</title>
    <link href="/post/b64a7908.html"/>
    <url>/post/b64a7908.html</url>
    
    <content type="html"><![CDATA[<h1 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h1><p>操作系统课程：</p><ul><li>最小的</li><li>原理一致</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个软件体，能让程序运行更加容易（甚至是同时运行多个），能让程序共享内存，能让程序与设备交互，等等</p><p>关键词：<strong>管理、服务</strong></p><p>精准的定义毫无意义</p><h2 id="演变"><a href="#演变" class="headerlink" title="演变"></a>演变</h2><ul><li>硬件</li><li>软件</li><li>管理软件的软件（OS）</li></ul><h3 id="1946年2月14日"><a href="#1946年2月14日" class="headerlink" title="1946年2月14日"></a>1946年2月14日</h3><ul><li>逻辑门 —— 真空电子管</li><li>存储器 —— 延迟线内存（击鼓传花，小丑扔球）</li><li>输入——打孔纸带，输出——指示灯</li><li>不需要操作系统 ——  程序用指令操作硬件</li></ul><h3 id="1950s"><a href="#1950s" class="headerlink" title="1950s"></a>1950s</h3><ul><li>逻辑门 —— 晶体管</li><li>更大的内存 —— 磁芯（小磁针方向代表比特信息）</li><li>更多IO</li><li>当IO速度严重低于处理器速度时，中断技术出现（1953）</li></ul><p>此时计算机价格十分昂贵，一个学校一台，如何分配给各个院系使用？</p><p>需要管理多个程序的执行，操作系统产生（多用户排队共享计算机）</p><p>保存结果到卡片里？——<strong>文件</strong></p><p>一个卡片是什么？——任务</p><h3 id="1960s"><a href="#1960s" class="headerlink" title="1960s"></a>1960s</h3><ul><li>处理器更快（还是一个CPU）</li><li>内存变大 —— 可以<strong>同时载入多个程序</strong></li><li>多个程序在内存，一个CPU。程序是分为CPU时间和IO时间的，也就是说有一段时间，我不需要CPU，而此时内存里又有另一个程序，那么让CPU去执行另一个程序，是非常自然的。——程序切换、调度；多道程序，<strong>进程的概念</strong>。</li><li>有了进程概念，就想让不同进程<strong>彼此隔离</strong>（程序都有bug）——<strong>虚拟地址</strong></li><li>操作系统要有进程管理的API</li></ul><p>当已经能够切换进程了，那如果加上定时切换呢？</p><p>之前是进程走了，通知CPU找其他人；现在是OS管理，OS定时每个进程运行多长时间就下去——现代OS雏形（Multics (MIT, 1965)）分时系统</p><h3 id="1970s"><a href="#1970s" class="headerlink" title="1970s"></a>1970s</h3><p>基本与今日无差别</p><p>1970PASCAL，1972C语言</p><p>UNIX（Multics是多用户，要分时，而UNIX则是单用户，与其针锋相对）</p><h3 id="今日"><a href="#今日" class="headerlink" title="今日"></a>今日</h3><p>虚拟化硬件资源（管理），为程序提供服务</p><h1 id="程序和编译器"><a href="#程序和编译器" class="headerlink" title="程序和编译器"></a>程序和编译器</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>什么是程序？</p><h3 id="代码角度"><a href="#代码角度" class="headerlink" title="代码角度"></a>代码角度</h3><p>状态机。数字系统是状态机，而所有的程序是运行在数字系统上的，因此程序也是状态机</p><p>那C程序的状态是什么？</p><ul><li><p>状态 &#x3D; 栈 + 堆</p></li><li><p>初始状态就是main的第一条语句</p></li><li><p>状态迁移 —— 执行一条语句</p></li></ul><p>stack frame &#x3D; PC + Args</p><ul><li>状态 &#x3D; stack frame + 全局变量</li><li>初始状态 &#x3D; 全局变量初始化</li><li>状态迁移 &#x3D; 栈顶的stack frame的PC指向的语句，PC++<ul><li>函数调用：栈顶增加一个stack frame，这个frame的PC就是函数入口</li><li>函数返回：去掉这个stack frame</li></ul></li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><ul><li>状态 &#x3D; 内存 + 寄存器</li></ul><p>如果确定状态，那么始终拿M[R[PC]]的内容，那么状态是一条直线。但是如果存在不同的状态（随机状态），那么就有分叉。</p><p>内存是有限的，因此状态也是有限的，如果一直执行下去，一定会回到之前呆过的某个位置。程序循环了起来，怎么退出？</p><p>程序是运行在操作系统上的，但所有的程序可以退出。如果只有计算，程序既不能退出，也无法输出到屏幕上。</p><h3 id="特殊指令-syscall"><a href="#特殊指令-syscall" class="headerlink" title="特殊指令 - syscall"></a>特殊指令 - syscall</h3><p>程序大多数都是计算指令。syscall相当于程序将自身所有都交给操作系统，请求操作系统，修改自己的状态机。因为操作系统可以访问所有资源（软硬件资源），进程的意图在os面前清楚显现。由操作系统去和其他东西交互。比如文件，比如创建销毁自身。</p><p>指令分为两种，一种是计算，一种是系统调用</p><p>因此<strong>程序 &#x3D; 计算 + syscall</strong></p><p>一个没有系统调用的例子：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs perl">x86-<span class="hljs-number">64</span> 架构，共有<span class="hljs-number">16</span>个<span class="hljs-number">64</span>位通用寄存器<br><br>%rsp 是堆栈指针寄存器，通常会指向栈顶位置，<br>堆栈的 <span class="hljs-keyword">pop</span> 和<span class="hljs-keyword">push</span> 操作就是通过改变 %rsp 的值即移动堆栈指针的位置来实现的。<br><br>%rbp 是栈帧指针，用于标识当前栈帧的起始位置<br><br>%rdi, %rsi, %rdx, %rcx,%r8, %r9 六个寄存器用于存储函数调用时的<span class="hljs-number">6</span>个参数（如果有<span class="hljs-number">6</span>个或<span class="hljs-number">6</span>个以上参数的话）。<br><br>被标识为 “miscellaneous registers” 的寄存器，属于通用性更为广泛的寄存器，<br>编译器或汇编程序可以根据需要存储任何数据。<br><br>%rax 通常用于存储函数调用的返回结果，同时也用于乘法和除法指令中。<br><br><span class="hljs-keyword">return</span>语句的行为：从rsp寄存器中取出八个字节，然后赋值给rip，<br>之后rsp自增<span class="hljs-number">8</span>，相当于<span class="hljs-keyword">pop</span>一个栈帧<br><br>当<span class="hljs-keyword">return</span>出错时，要么取rsp时出错，要么赋值给rip时出错，<br>最终我们发现一个void _start的函数，如果只有一个<span class="hljs-keyword">while</span>循环，能够被操作系统正确执行，<br>但如果是空函数，却没有办法返回，问题出在初始状态上，进程的初始状态无法返回。<br>那怎么让状态机停下来？纯粹的计算是不可以的，想正确退出，必须要有系统调用<br></code></pre></td></tr></table></figure><h3 id="视角转换"><a href="#视角转换" class="headerlink" title="视角转换"></a>视角转换</h3><p>C语言：变量 + 栈帧</p><p>ASM：内存 + 寄存器</p><p>汇编代码 &#x3D; compiler（源代码）</p><p>编译器将源代码状态机 转换为 二进制代码状态机</p><p>编译正确，编译优化？</p><p>C代码里面有一些无法优化，正确编译就是保留所有无法优化的部分，其他的所有都可以去掉，这也是优化</p><p>优化：保持观测一致性</p><p>一般程序</p><p>在应用眼里，操作系统就是syscall，这是操作系统提供给应用的API。有了syscall，操作系统也可以管理多个状态机。</p><p>所有的程序都是被另外一个程序加载的，执行execve设置初始状态</p><ul><li>进程管理：fork, execve, exit</li><li>文件&#x2F;设备管理：open, close, read, write</li><li>存储管理：mmap, brk</li></ul><h1 id="多处理器编程"><a href="#多处理器编程" class="headerlink" title="多处理器编程"></a>多处理器编程</h1><p>从初始开始，如果一直经历确定的状态，那么一定到达了确定</p><p>而并发则天然随机</p><p>而操作系统是最早的并发程序之一。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>并发的基本单位：线程</p><p>共享什么？</p><ul><li>全局变量</li><li>堆区</li></ul><p>不共享什么？</p><ul><li>局部变量</li><li>自己的PC</li></ul><p>具体执行时，需要选择线程，然后把全局+某个线程，看成一个线程去执行。由于每次都会选择，因此都是不确定的。人天生就是线性走的，但并发要考虑所有的</p><p>从状态机的视角理解进程操作</p><ul><li>进程创建：<ul><li>在原本的状态机里面加入一个栈帧的链表</li></ul></li><li>join<ul><li>某个线程如果进行了join操作，那么他的形式语义就是：如果其他线程尚未结束，那么当执行本线程时，状态自反，不进行任何操作。只有当轮到其他线程并结束时，本线程的状态才可能改变。因此join等待所有运行线程的函数返回。</li></ul></li></ul><p>使用一个小的线程库，我们就可以写出利用多处理器的程序，而操作系统会自动把线程放在不同的处理器上。</p><ul><li>一个全局变量即可证明线程确实是共享内存</li><li>使用函数无限递归的小技巧即可确认不同线程拥有独立堆栈，并且还可以近似确立大小</li></ul><h2 id="带来的改变"><a href="#带来的改变" class="headerlink" title="带来的改变"></a>带来的改变</h2><ul><li>原子性的丧失，甚至一条add指令也无法保证</li></ul><p>99%的并发问题都可以用一个队列完成，将大任务分成可以并行的小任务</p><ul><li>顺序</li></ul><p>对于编译器来说，当编译优化时，是按照顺序来的。编译器优化时，对内存拥有最终的统一性权限。如果编译器知道最终要写入n，那么之前那些就可以忽略。</p><p>编译器对内存访问 “eventually consistent” 的处理，导致共享内存作为线程同步工具失效</p><ul><li>可见性</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T1</span><span class="hljs-params">()</span> &#123;<br>  x = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;y = %d\n&quot;</span>, y);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">T2</span><span class="hljs-params">()</span> &#123;<br>  y = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;&quot;</span> : : <span class="hljs-string">&quot;memory&quot;</span>)</span>; <span class="hljs-comment">// compiler barrier</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x = %d\n&quot;</span>, x);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果按照状态机解释，那么我们可以得到1 0，0 1，以及1 1，得不到 0 0。但是输出时会有0 0 ，因为处理器也是一个编译器，也是会对指令的顺序去做一定的调整。无论执行哪个，都容易再另一个线程中发生miss，然后就会先输出。</p><h1 id="理解并发"><a href="#理解并发" class="headerlink" title="理解并发"></a>理解并发</h1><p>处理器默认不保证原子性的操作</p><p>只要是两条指令，原子性就很难保证。除非一个线程在读某个状态的时候能立刻写状态</p><h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><p>共享内存模型</p><p>之前的错误算法：先读，再写，最后写收尾</p><p>但是先读再写，读的只能是历史阶段（过去），因此后写的时候可能会覆盖一个已经改变的状态</p><p>（两个人竞争上厕所，一个人看了一眼没人，然后眨眼进去了，但眨眼的这个阶段，可能有别人进去了）</p><p>于是将状态改为：先一起写，所有的写结束后，肯定会有一个状态，此时再去读这个状态，有这个不变的再去决定</p><p>前提是走一步就执行一步，即立刻写入共享内存</p><h2 id="自动状态机"><a href="#自动状态机" class="headerlink" title="自动状态机"></a>自动状态机</h2><p>使用python代码实现，实现原理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">numbers</span>(<span class="hljs-params">init=<span class="hljs-number">0</span>, step=<span class="hljs-number">1</span></span>):<br>    n = init<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        n += step<br>        <span class="hljs-keyword">yield</span> n<br></code></pre></td></tr></table></figure><p>g会生成一个状态机，当执行碰到yield的时候，会返回yield的值。</p><p>并且不同于C的，C函数调用就进去了，而且必须等到函数有返回才能出来</p><p>但python可以一直保留这个状态机</p><p>那用两个变量去接受numbers函数，就相当于创建了两个状态机，也就是两个线程。</p><h1 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h1><p>物理世界中，很难有一种机制完全保证某个资源的原子性</p><p><strong>实现互斥的根本困难：不能同时写&#x2F;读共享内存</strong>，即使是数字加1，cpu也会拆分</p><ul><li>load：看一眼把眼睛闭上，但看到的东西立刻过时</li><li>store：闭着眼睛动手，但不知道把什么变成了什么</li></ul><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>假设硬件能为我们完成一条“瞬间完成”的读+写指令</p><p>exange指令，原子交换，即先读再写，类似于交换</p><p>有了原子指令后，算法实现相对简单</p><p>首先有一个共享变量，如果某一个进程要进入临界区，那么先使得其他进程停止，然后该进程原子得交换自己的局部变量和共享变量（一个读一个写）；其他进程继续进行，但是其他所有进程都无法获得原来的共享变量，只有有共享变量的才能进入临界区。等该进程完成后，再原子地把共享变量放回去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> table = YES;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>  retry:<br>  <span class="hljs-type">int</span> got = xchg(&amp;table, NOPE);<br>  <span class="hljs-keyword">if</span>(got == NOPE) &#123;<br>      <span class="hljs-keyword">goto</span> retry;<br>    &#125;<br>  assert(got == YES);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>  xchg(&amp;table, YES);<br>&#125;<br></code></pre></td></tr></table></figure><p>Simplify:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">while</span>( xchg(&amp;lock, <span class="hljs-number">1</span>))<br>    ;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>  xchg(&amp;lock, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>该图片由<a href="https://pixabay.com/zh/users/openclipart-vectors-30363/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=154544">OpenClipart-Vectors</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=154544">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鼠疫-读后感</title>
    <link href="/post/3d81ffe5.html"/>
    <url>/post/3d81ffe5.html</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>放假后闲来无事，晚上难以入睡时，打开了微信读书，看了看前面的几本都没有什么打开的欲望，于是逐渐到了书架的底部，一本鼠疫赫然在列。上次读加缪，还是局外人，出于好奇打开了这本搁置一年的书，陪我度过了一周的夜晚。</p><h1 id="黑死病"><a href="#黑死病" class="headerlink" title="黑死病"></a>黑死病</h1><p>鼠疫，又称黑死病。是由鼠疫杆菌引起的传染病，历史上多次席卷全球。我印象相对深一点的，就是欧洲14世纪的那次，当时也恰逢英法百年战争的开端。了解这些，也是因为之前玩的游戏《瘟疫传说——无罪》里面的介绍，但与游戏里铺天盖地的老鼠所带来的威压不同，本书主要描写的，着重在人身上，着重在几个主要人物对于鼠疫的应对上。书中也有不少我认为很好的句子，下面就从几个句子出发，谈谈感想。</p><h1 id="句子分析"><a href="#句子分析" class="headerlink" title="句子分析"></a>句子分析</h1><ul><li><code>报纸对老鼠事件大肆宣扬，但对此事却只字不提。因为老鼠死在街上，人死在屋里。报纸只管街上的事。</code></li></ul><p>报纸只管街上的事，媒体需要吸引眼球，而公众生活与公众人物是大家都会关心的。某一个家庭或者某一个个体，无论是苦难，还是惊喜，都难以吸引到足够的注意力。十分无奈，却又十分现实。</p><ul><li><code>凭借正当的手段，过上富足的物质生活，从而问心无愧地从事自己喜爱的工作，这样的未来让他憧憬不已。</code></li></ul><p>我也憧憬。但是我也十分矛盾，因为在资本主义的生产方式下，资本的增殖就是唯一的目的。市场上的等价交换掩盖了贫富差距的不断被创造，资本的每一次发展，都会产生更大的贫富差距，否则剩余价值无从谈起。这种背景下，即使有些公司许诺了丰厚的员工福利，但是利润才是公司的最终目的，公司和老板本身并不是慈善家，或者说如果老板是慈善家，那么他也无法成为老板。通过技术的革新，不断减少必要劳动时间，提高单位产出率，使得利润成倍增长，这是所有公司都向往的，谁来买单呢？低端产业的末端产业链的工人们。</p><p>举个例子，计算机，也就是电脑。电脑刚诞生的时候，其成本与重量是难以想象的，不要说个人，即使是企业也难以承担成本。当时主要还是存在于实验室中，但是经过全世界最聪明的科学家的钻研（他们当时大多数人既处于科研第一线，又处于工业界中），技术壁垒被一次次打破，成本一次次下降，电脑的性能也不断增强。从宏观来看，作为顾客，用较低的成本享受到了高性能的电脑，前几年无数千元智能机，让手机走入中国的千家万户；作为企业，用更低的价格却获得了更多的利润，卖出了更多的产品，作为人手必备的产品，企业不愁没有市场，也养活了一大批企业。如此一个双赢的局面，问题出在哪里呢？出在不同人员购买同样产品所付出的劳动时间。作为高精尖的技术人才，其单位时间内所创造的价值更高，但是如果从事一般意义上的体力劳动，那么单位时间内创造的价值更低。这就导致如果体力劳动者想要去购买这些产品，要么延长自己的劳动时间（加班），要么减少不必要的开支，才能去享受到这样的产品。单位产值低的人节衣缩食，通过积攒的手段购买；单位产值高的人，则不需要积攒，甚至还可以有剩下的钱去搞投资，两者的差距进一步增大，剪刀差也由此而来。</p><p>如果没有强制手段保证单位产值低的人的基本薪资，那么贫富差距会越来越大。但是贫富差距又是必然结果，不存在是不可能的。公平是指拥有相同的机会，而不是得到相同的结果。同样的事情，有人一笑而过，有人却能发现机会，这也是客观存在的。差距大不是问题，但是持续拉大，必然会导致社会动荡，产生更严重的问题。</p><p>天之道，损有余而补不足；人之道，损不足而益有余。——《老子》</p><ul><li><code>电报成为我们唯一的通信途径。以前依靠心灵、情感和肉体来维系的鲜活生命，如今却只能通过写有十个大写字母的一封电报来重觅往日的温情。实际上，电报中所能使用的表述很快就穷尽了，长期的共同生活或悲伤的心情只能概括为几句短语来进行不时的交流，诸如“我很好”“想你”“爱你”等。</code><br><code>我们之中还有一些人，他们依然坚持写信，想尽办法与外界取得联系，但所有努力到头来还是一场空。我们想出来的某些办法可能有用，因为没有收到对方回音，所以我们也不知其详。一连好几个星期，我们只能把同样的信写了又写，把同样的呼吁发了又发。这样过了一阵子，我们原本发自肺腑的心声却变成了苍白无力的空洞字眼。我们依旧在麻木地重复同样的内容，试图将我们艰难的生活通过这些死气沉沉的语句传递出去。这种枯燥无味而又自我陶醉的独白，这番如同面壁般冷冰冰的对话，我们觉得其效果还比不上电报的格式化用语。</code></li></ul><p>这段话将长期分隔的人对于彼此的情感写得十分生动。关系需要心灵、情感和肉体去维系，后来变成了有限的文字，等有限文字将所有可能的排列组合穷尽后，也就只能剩下个“我很好”了。</p><ul><li><code>一家咖啡馆贴出“喝酒可以杀菌”的招贴，公众本来就相信酒精可以阻止疾病传染，一经舆论宣传，他们对此就更深信不疑了。每天深夜两点，街上随处可见被咖啡馆逐出来的酒鬼，到处回响着他们乐观的言论。</code></li></ul><p>无知即力量，现实中也不乏这种人，只能说画地为牢后，所见即为世界，唯有登高望远，才知世界广阔。希望当我们遇到与自己以往认知不同的观点时，不要抱着defensive的态度，上来就想着如何反驳，而是抱着inclusive的态度，留出充足的时间来让自己思考，通过科学的手段去验证，不断求真，求实。</p><ul><li><code>那些浅薄之人则趁机向他推销住宅或是推荐便宜的食宿公寓；那些做事有条不紊的人让他填写卡片，然后将其归档；那些忙得不可开交的人会把胳膊高高举起；那些嫌麻烦的人则索性把脸转向一边；最后还有沾染旧习气的人，这样的人也是最多的，他们让朗贝尔去找另一个科室，或是告诉他需要重新申办的手续。</code></li></ul><p>这段话也是现实的投影，懒、殆、踢皮球，自诩，实则。这还并不可怕，最可怕的是普通人的厌恶不是因为这种行为本身，而是因为自己未能参与其中。</p><ul><li><code>叙述者无意过分强调这些救护组织的重要性。对于我们的许多居民而言，如果处在他的位置，肯定就想夸大它们的作用。但是叙述者更愿意相信：如果过于重视高尚行为的话，那么则是对罪恶表达了间接而有力的敬意。这不免让人觉得这些高尚的行为只是因为罕见才显得可贵，恶毒和冷漠是人类行为中最为常见的动力。这样的观点叙述者并不同意。世上的罪恶几乎都源自无知。不明不白的善意造成的破坏和恶意一样多。人性本善，而非人性本恶，实际上问题并不在此。但是他们或多或少都有无知之处，这就是所谓的善与恶，最令人绝望的恶是一种无知的恶，这种恶自以为什么都懂，便放任自己随意杀戮。杀人犯的灵魂是盲目的，如果没有远见卓识，也就没有真正的善良和美妙的爱意。</code><br><code>因此，对于塔鲁帮忙建立起来的卫生防疫组织，应该给予客观的评价。因此，叙述者不会对善意和英雄主义大唱赞歌，而应赞赏有度。</code><br><code>献身于卫生防疫组织的那些人并不见得有多么伟大的功劳，实际上他们知道这是唯一可做的事情，如果不做出决定，那简直无法想象。这些组织有助于市民们更深刻地了解鼠疫，并在某种程度上让他们确信，既然鼠疫已经发生，那就应该采取行动消灭它。因为消灭鼠疫已经成为某些人的义务，鼠疫的本质也便显现出来，也就是说，它是大家的事。</code><br><code>不过一名教师受到赞扬，不是因为他教会别人二加二等于四，而可能是因为他选择了这份崇高的职业。所以说，塔鲁和其他人选择证明二加二等于四而不是与之相反，这值得赞扬。但是，就这份善意而言，他们和教师一样，和所有那些与教师同心同德的人一样。他们远比想象中的要多，这是人类的光荣，至少叙述者是这么认为的。此外，叙述者十分清楚地看到有人会对此提出反驳意见，说这些人在冒着生命危险。但是，历史上总会出现这样的时刻：有人胆敢说二加二等于四，那就会被处死。教师对此很是明白。问题并不在于知道这一推论的后果到底是奖赏还是惩罚，而是在于知道二加二是否等于四。</code></li></ul><p>一段很长的话，对于救护组织的态度作了详细的分析。这也可以扩展到其他事情上。我们到底该如何选择自己的态度。这段话很难理解，我暂时也只是读个大概，希望以后能有更深入的理解。</p><ul><li><code>每当医生听到史诗般的语调或是高雅的论调时，他都显得颇不耐烦。当然，他知道这种关心并不是装出来的，但却只能用人们表达自己与人性相关的套话来表述。而这样的话语并不适用于格朗每天所做的平凡努力，也无法体现格朗在鼠疫中的价值。</code></li></ul><p>与上面一段话类似，平凡的人才是最多的，过度的史诗般的讴歌会越来越偏离这些普通人，越来越偏离这些平凡的努力。</p><ul><li><code>不管怎样，出于比较，他们想到了其他街区的居民，想到了那些自由的人。而后者在自己困难重重的时刻，想到还有人比他们更不自由时，便感觉到一丝安慰。“还有比我更受奴役的人呢。”当时唯一可能实现的希望尽在这句话中。</code></li></ul><p>还有比我更惨的人呢，当时<strong>唯一可能</strong>实现的希望<strong>尽</strong>在这句话中。人性。</p><ul><li><code>希望体面下葬的想法非常普遍，其程度超出人们的想象。幸好没过多久，食品供应问题变得棘手起来，于是居民们的注意力便被转移到更加迫切的问题上来了。如果要吃饭，那就得忙着排队，忙着跑腿办手续，便无暇考虑周围人是如何死的，也无暇考虑自己有一天是如何死的。</code></li></ul><p>活人都顾不上了，也就没人去管死人了。悲哀却又无奈。</p><ul><li><code>翌日，家属便被请来在登记册上签字，这标志着人和狗之类的动物之间是有差别的：因为可以一直核查。</code></li></ul><p>无须多言</p><ul><li><code>他们是在碰运气，但没人能掌控运气。</code></li></ul><p>运气本身就是概率问题，只要基数足够大，总有人会碰到那个小概率事件，无论是好是坏。有人会因为运气好而沾沾自喜，有人会因为运气差而顾影自怜。但请记住一点，我们都是在碰运气，但问题是，没人能掌控运气。</p><ul><li><code>到我这个年纪，肯定得真心实意。撒谎太累人了。</code></li></ul><p>撒了一个谎之后，就需要用另一个谎去圆，进而用另外两个谎去圆这两个谎，指数增长后早晚会不攻自破。</p><ul><li><code>所有预卜都有一个共同点：它们最终都能让人安心。</code></li></ul><p>人们总是愿意去相信对自己有利的事情，而对自己有害的事情，人们总是希冀着不会降临到自己身上。</p><ul><li><code>当然，世间有善恶之分，而且人们很容易解释它们之间的区别。但要解释恶的内因，就变得困难了。</code></li></ul><p>社会是复杂的，人性也是复杂的。一件事放到普遍架构下，对于其善恶的区分是容易的，但是为什么会发生，则是大多数人都不感兴趣的。毕竟相对于追根溯源和仔细求证来说，下一个武断的结论可是容易太多了。但一旦发现其内在原因后，人们对于自己是否会从事这样的善，是否也会从事这样的恶，还会那么坚决吗？</p><ul><li><code>结果到最后，人们发现，即使是在最不幸的时候，也没有一个人能够真正想到谁。因为真正想念一个人，就意味着分分秒秒都在想念，意味着不能被任何事分心，无论是家务事，是苍蝇飞来飞去，是做饭吃饭，还是身上瘙痒。但是，苍蝇和瘙痒总是会有的。这便是生活不易的原因。对此，他们都很明白。</code></li></ul><p>生活总要继续，每个人也都有自己的事情，谁能整天绕着另一个人转呢？现实点吧，“从此公主和王子幸福的生活在一起”只是童话里的结尾，但是在现实生活中，这才是冒险真正的起点。</p><ul><li><code>我听过太多的摆事实讲道理，它们差点把我弄得晕头转向，而且确实把不少人搞得晕头转向，让他们同意杀人。我终于明白，人类所有的不幸其实是因为人类讲的语言不清楚。</code></li></ul><p>新概念词典——第十版</p><ul><li><code>我感觉自己与失败者在一起有一脉相连的感觉，而与圣人在一起时却没有。我觉得自己对英雄主义和圣人之道没有兴趣。我感兴趣的是如何做一个真正的人。</code></li></ul><p>我感觉自己与躺平者在一起有一脉相连的感觉，而与内卷者在一起时却没有。我觉得自己对于高绩点和保研没有兴趣，我感兴趣的是如何上一个真正的大学，成为一个真正的大学生。</p><ul><li><code>这个缺乏爱情的世界仿佛一个死亡的世界。总有那么一刻，人们对监狱、工作和勇气都会感到厌倦，转而去渴求某人的容颜，寻觅让心灵悸动的温情。</code></li></ul><p>爱情还是重要的，无论对男性还是女性</p><ul><li><code>另一些人，主要是先前与亲人分开生活的人，他们经历了长期的封闭生活，身心俱疲，现在刮起的这股希望之风反而让他们变得狂热，变得烦躁，让他们完全无法自控。他们觉得自己可能会在美梦即将成真时死去，从而见不着自己钟爱的心上人，长期经受的磨难也得不到任何回报，每每想到这些，他们不禁心生莫名的恐惧。在这些年月里，尽管他们被囚禁被流放，但他们还是隐忍顽强，在等待中坚持不懈。现在出现了希望的第一道曙光，却足以摧毁恐惧与失望都无法摧毁的东西。</code></li></ul><p>转一下书评：之前恐惧所摧毁的只是当下的美好，但如果希望没了，将会摧毁以后所有的美好。</p><ul><li><code>这群快乐的人儿，他们走在喧闹的人群中，一对对紧紧依偎在一起，言语不多，却沾沾自喜地表现出不恰当的幸福模样，仿佛在表明鼠疫已经结束，恐惧时代已经成为过去。他们罔顾事实，心平气和地否认我们曾经在这个荒谬的世界上生活过，在这个世界里，杀个人像拍死几只苍蝇一样稀松平常；他们否认这种确凿无疑的野蛮行径，这种经过预谋的疯狂举动，否认这种囚禁生活，但凡不属于现在的东西，都被这样的生活披上了一件所谓自由的可怕外衣；他们否认闻到这股使活人作呕的死亡气息；最后，他们还否认我们曾经被吓得惊魂未定。当时，我们之中每天都有人被投进焚尸炉，然后被烧得化为一股浓烟，而另一些人则戴着无能与恐惧的镣铐，等待着死亡的来临。</code></li></ul><p>不要因为暂时的安宁，就忘记了曾经的苦难，那样只会导致下一次苦难。</p><ul><li><code>这样做的目的，就是为了不要成为沉默的大多数，为了支持那些曾经亲眼看见的鼠疫患者，为了让人们记得他们曾经遭受的暴力与不公正的待遇，为了告诉别人自己历经磨难之后的感悟：在人的身上，值得欣赏的东西总是多于应该蔑视的东西。</code></li></ul><p>人总还是要带着希望活着，因此我们还是相信这一点吧：在人的身上，值得欣赏的东西总是多于应该蔑视的东西。</p><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>该封面图片由<a href="https://pixabay.com/zh/users/gregroose-2823595/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5040202">Grégory ROOSE</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=5040202">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Reader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>加缪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Plague of Tale -- Innocence通关感言</title>
    <link href="/post/9be3c0b.html"/>
    <url>/post/9be3c0b.html</url>
    
    <content type="html"><![CDATA[<h2 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h2><p>我们行走在14世纪的法国</p><p>看着14世纪欧洲的风土人情</p><p>两个人</p><p>一姐一弟</p><p>从陌生到熟悉再到依赖</p><p>沉浸式的体验</p><p>无论剧情抑或环境，无论背景还是配乐</p><p>都让我身临其境</p><p>Immersive</p><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>一开始为贵族后裔，在城堡里过着无忧无虑的生活</p><p>却突然遇到变故，父母双亡，14岁少女不得不带着5岁弟弟逃亡</p><p>困难不必多言，众多朋友是唯一的慰藉</p><p>炼金术士卢卡斯帮忙各种技能点</p><p>盗贼兄妹为钱而加入</p><p>铁匠儿子为父报仇</p><p>小伙伴越来越多</p><p>敌人越来越强</p><p>主人公亦在随着玩家一起稳步成长</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/49b09e_a635cd300b82494794f7d95f4a55a9c9~mv2.jpg"></p><h2 id="情节"><a href="#情节" class="headerlink" title="情节"></a>情节</h2><p>单看情节，印象比较深的应该是苦修这一章</p><p>本以为是自己修炼技能，提高战斗水平</p><p>没想到修的是心</p><p>发现弟弟不见，姐姐一路寻找，遇上幻觉。经历劳伦提斯和妈妈的重重对话，最终是雨果对于受骗（姐姐不告诉弟弟妈妈还活着）的愤怒，毕竟小孩子。后来回到幻觉的庄园，在地底是比较震撼的一幕，本来是正常黑色的骨头组成通道，后来是一路上杀的敌人的尸体。姐姐却不害怕，表明自己仍然会为了弟弟再杀一遍，其声嘶力竭的吼声彰显对弟弟越来越深的爱</p><p>随后迎来老鼠，成功在老鼠里游泳（真的很奇妙的感觉）。后来阿米西亚看到尼古拉斯带走雨果，直接崩溃，绝望地将一直以来视为最大敌人的尼古拉斯称为大人。</p><p>或许在雨果第一次为姐姐戴花时，阿米西亚就已经决定要照顾好自己的弟弟——自己剩下的唯一的亲人。</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/49b09e_9d64b48952b043f1a057472f22283563~mv2.jpg"></p><p>姐姐一个人的时候，看见好的东西，棋子或者苹果，都会想到弟弟，这个细节无疑说出了姐姐对于的爱。弟弟也很依赖姐姐，但毕竟5年大多数和妈妈度过，所以自己一个人去找妈妈也能说得通（虽然还是被抓了）</p><p>敌人AI虽然低，但还是有两个地方卡了很久。一个是那个尼古拉斯的秦王绕柱走，最后真的运气好过的。另外就是最后的黑白大战，两个加起来死了应该有30次还多，但总之，I did it.</p><p>其实说实话，打不过的时候，也考虑过要不不打了，看解说云通关吧，但是又不甘心，之前已经经历过那么多了，感觉一定要打过去才行</p><p>以上想到哪写哪，可谓不知所言。</p><h2 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h2><p>手残党20h通关</p><p>我得到了什么？？？</p><p>在气氛优美的法国小镇里体会中世纪的异域风情</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230105223927778.png"></p><p>在铺天盖地的老鼠与敌人前保持镇定，临危不乱</p><p>了解历史上造成一亿人死亡的黑死病在当时到底是何种程度的危害</p><p>（当时全世界4亿人）</p><p>看到了无论底层人民还是中产阶级在面对死亡时的恐惧与悲哀</p><p>人性罪恶与美善相得益彰</p><p>收获一份姐弟亲情，面对鼠群时，相互依靠，给予对方精神上的鼓励</p><p>虽然很多时候两个人会拌嘴，但是如果真的只有一个人的话，都是难以坚持的</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230105223951913.png" alt="image-20230105223951913" style="zoom:50%;" /><p>两个人面对江面，回想着这几天里的家庭变故，不知未来是否与这茫茫江水一样——不知从何来，不知往哪去——越想看清却越迷茫。</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230105224011542.png" alt="image-20230105224011542" style="zoom:67%;" /><p>玩完游戏后，我也明白了火的意义——</p><p>除了如今点烟做饭杀人放火以外，</p><p>最初带给人们的，是远古时期在茫茫黑夜，阵阵狼嚎，一人踽踽独行时的温暖，希望，力量</p><p>当那压抑的黑色袭来时，火焰与光是唯一的救赎。</p><p>刚到城堡里时候，我们是多么地兴奋与安心，感觉外界的鼠患已经消失，一切是如此的明朗，天气晴朗，心情愉悦，大难不死，朋友在旁。</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230105224137298.png"></p><p>然而事与愿违，老鼠该来还是来，同样的，我们该拼搏，还是要拼搏反抗</p><p>穿过挂着犯人的装置时，是多么血腥，但是这就是历史上真实的尸横遍野与血流成河，感慨的同时，只能感恩如今的河清海晏。</p><p>感谢游戏组将我们带去中世纪欧洲</p><p>体会大名鼎鼎的黑死病</p><p>感谢如今医疗水平提高，科技发达</p><p>感谢人与人之间的爱与信任</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230105224235991.png"></h3><p>本文为原创，如有图片侵权请与作者联系：<a href="mailto:&#104;&#49;&#x39;&#x36;&#52;&#54;&#51;&#x34;&#51;&#52;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;">&#104;&#49;&#x39;&#x36;&#52;&#54;&#51;&#x34;&#51;&#52;&#x39;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#109;</a></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Game</tag>
      
      <tag>黑死病</tag>
      
      <tag>瘟疫传说</tag>
      
      <tag>RPG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requestparam and requestbody</title>
    <link href="/post/64c82043.html"/>
    <url>/post/64c82043.html</url>
    
    <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>上传图片遇到了一个矛盾：</p><ul><li>为了上传图片，最简单的方法是在自己的类内部把图片上传逻辑写一下，但是以后其他人上传图片，都要写一次</li><li>于是想把上传图片搞一个工具类(工具类不是接口)，但是这样需要把图片和其他请求放到一个请求中（可能是requestbody和requestparam的区别）</li><li>一开始上面不会，所以为了单独上传图片，想把图片相关设置为一个controller接口<br>但是这个图片的controller里面需要知道图片的上传路径，但是路径确是由具体的逻辑把控的，你无法知道将来调用的路径</li><li>所以上传图片不能当作一个接口</li></ul><p>所以看看能不能把图片和其他请求放在一起</p><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h2><p> javadoc states</p><blockquote><p>Annotation indicating a method parameter should be bound to the body of the web request.</p></blockquote><p>这个参数需要和网页请求的请求体绑定起来</p><p>通过HttpMessageConverter把请求体反序列化为参数类型的对象</p><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a>RequestParam</h2><p>javadoc states</p><blockquote><p>Annotation which indicates that a method parameter should be bound to a web request parameter.</p></blockquote><p>这个方法参数应该绑定到一个网页请求参数上</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Developer</tag>
      
      <tag>Java</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh learning</title>
    <link href="/post/a5271c15.html"/>
    <url>/post/a5271c15.html</url>
    
    <content type="html"><![CDATA[<h2 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h2><p><code>ssh user@hostname</code></p><ul><li><p><code>user</code>：用户名</p></li><li><p><code>hostname</code>：IP地址或域名</p></li></ul><p>之后电脑会将该服务器的信息记录在<code>~/.ssh/known_hosts</code>文件中</p><p>登录某一特定端口：</p><p><code>ssh user@hostname -p 22</code></p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>防止每次登录ssh都需要输入一遍<code>user@hostname</code>，ip不容易记忆</p><p>创建文件<code>~/.ssh/config</code></p><p>然后在文件中输入：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">Host myserver1<br>    HostName IP地址或域名<br>    User 用户名<br><br>Host myserver2<br>    HostName IP地址或域名<br>    User 用户名<br></code></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2</p><p>注意这是使用ssh登录的操作，与使用ssh进行远程git仓库的认证相区分开。</p><h2 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h2><p>防止每次登录都需要输入密码</p><p>创建密钥：</p><p><code>ssh-keygen</code><br>然后一直回车即可。</p><p>执行结束后，<code>~/.ssh/</code>目录下会多两个文件：</p><p><code>id_rsa</code>：私钥<br><code>id_rsa.pub</code>：公钥</p><p>将公钥中的内容，复制到服务器中的<code>~/.ssh/authorized_keys</code>文件里即可</p><p>一键添加公钥：</p><p><code>ssh-copy-id -i &quot;filepath&quot; myserver</code></p><h2 id="配置git-amp-github"><a href="#配置git-amp-github" class="headerlink" title="配置git&amp;github"></a>配置git&amp;github</h2><p>传输文件时，需要使用ssh去与远程git服务器相认证。</p><p>同样需要生成密钥和公钥</p><p>下面两种算法比较常见</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t rsa -C &quot;&lt;您的邮箱&gt;&quot;<br></code></pre></td></tr></table></figure><p>之后，需要在本地<code>~/.ssh/config</code>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">账号A</span><br>Host blogOasis<br>HostName github,com<br>IdentityFile ~/.ssh/id_rsa_blog<br>PreferredAuthentications publickey<br>IdentityAgent none<br>IdentitiesOnly yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">账号B</span><br>Host main-voice<br>HostName github.com<br>IdentityFile ~/.ssh/id_rsa_main_voice<br>PreferredAuthentications publickey<br>IdentityAgent none<br>IdentitiesOnly yes<br></code></pre></td></tr></table></figure><ul><li>HostName：填写托管平台服务地址；</li><li>Host：填写别名，方便命令行使用；</li><li>IdentityFile：填写证书位置，即使用本地哪个私钥与服务器对接；</li></ul><p>在日常推拉代码工作时，获取代码库的 ssh 克隆地址后，因为本地有多个账号，可以手动选择使用哪个账号操作。</p><p><code>git@blogOasis:username/repoName</code></p><p><code>git@main-voice:username/repoName</code></p><p>可使用以下命令查看当前使用的密钥对应的账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -t git@blogOasis<br></code></pre></td></tr></table></figure><h2 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h2><p>基本用法：</p><p><code>scp source destination</code></p><p>如果传输到远程，注意加上meserver:(冒号)</p><p><strong>路径问题：</strong></p><p><code>scp -r ~/tmp myserver:/home/acs/</code></p><p>服务器后加&#x2F;，代表绝对路径</p><p>如果不加&#x2F;，代表相对于~&#x2F;的相对路径</p><p>最后的&#x2F;，看情况加，有时候报错是一个文件夹，无法传输，把&#x2F;去掉即可</p><h2 id="终端tips"><a href="#终端tips" class="headerlink" title="终端tips"></a>终端tips</h2><p>复制内容：开头点一下，按住shift，结尾点一下即可</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://help.aliyun.com/document_detail/322237.html?userCode=okjhlpr5">https://help.aliyun.com/document_detail/322237.html?userCode=okjhlpr5</a></p><p><a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent">https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git learning</title>
    <link href="/post/dbf237bf.html"/>
    <url>/post/dbf237bf.html</url>
    
    <content type="html"><![CDATA[<p>用一棵树，维护所有的代码历史记录</p><ul><li>一个人的代码版本回顾</li><li>多个人的代码协同开发</li><li>版本管理、可持久化、多人协作</li><li></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区：本地看git的文件夹，即当前工作目录，与分支无关</li><li>版本库：repository，存储所有提交到本地的代码版本</li><li>暂存区：工作区与版本库之间的桥梁，多次本地工作，但是尚未构成一次提交，可以先到暂存区，本次阶段完成后，进入版本库。<strong>与分支独立，所有的分支其实是共用一个暂存区</strong></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</li><li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</li><li><code>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code>: 生成一个新的密钥</li></ul><h3 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h3><ul><li><code>git init</code> :  把当前目录变成一个git仓库</li><li><code>git status</code>: 显示状态，untracked就是未加入到暂存区</li><li><code>git add &lt;filename&gt;</code>：加入filename到暂存区中</li><li><code>git add .</code>：将所有待加入暂存区的文件加入到暂存区（忽略.gitignore）</li><li><code>git commit -m &quot;message&quot;</code>：把暂存区内容加入到当前分支</li><li><code>git commit --amend</code>：</li><li><code>git diff XX</code>: 查看某个文件相对于当前分支的最新版本修改了哪些内容（即commit的与尚未add的，版本库的内容与尚未add的内容）</li><li><code>git rm --cached XX</code>: 将某个文件从暂存区删除出来，并且我也不管理它</li><li><code>git restore --staged XX</code>: 将某个文件从暂存区删除，但是还要管理（相比于上面，不需要再次add）</li><li><code>git log</code>：查看当前分支的所有版本（从最开始到HEAD所在位置）</li><li><code>git reset --hard HEAD^</code>: 将代码回滚一个版本，一个三角一个版本，100个版本加数字</li><li><code>git reflog</code>：HEAD的移动记录</li><li><code>git reset --hard &#123;hashval&#125;</code>：回滚到任意版本，借助上一条命令得到哈希值</li><li><code>git restore &lt;filename&gt;</code>: <strong>撤销该文件所有工作区</strong>的修改，<strong>回滚到暂存区</strong>的阶段，如果暂存区没有内容，那么就是回滚到头节点指向的那个阶段。（即使是删除文件，也可以回滚）</li><li><code>git restore --staged XX</code>: 将某个文件<strong>从暂存区删除</strong>，回到了工作区</li><li><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</li><li><code>git branch branch_name</code>：创建新分支</li></ul><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul><li><code>git remote add origin git@github.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li><li><code>git remote remove origin</code>：移除远程仓库</li><li><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</li><li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</li><li><code>git pull</code>：将远程仓库的<strong>当前分支</strong>与<strong>本地</strong>仓库的<strong>当前分支合并</strong></li><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li><li><code>git checkout -t origin/branch_name</code> 将远程的branch_name分支拉取到本地</li><li><code>git push origin --delete &lt;branch_name&gt;</code>：删除远程分支</li></ul><h3 id="栈操作（stash）"><a href="#栈操作（stash）" class="headerlink" title="栈操作（stash）"></a>栈操作（stash）</h3><ul><li>可以将某一时刻的工作区与暂存区全部存储到一个栈中</li><li><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中</li><li><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素</li><li><code>git stash drop</code>：删除栈顶存储的修改</li><li><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素</li><li><code>git stash list</code>：查看栈中所有元素</li></ul><h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><h4 id="1-add"><a href="#1-add" class="headerlink" title="1. add"></a>1. add</h4><p>如果创建一个文件，此时尚未add，则未track任何文件，会提示哪些未track</p><p>这个新文件，未add之前，无论如何修改，git status给的提示都一样</p><p>add之后，会显示有一个新文件，此时如果继续修改，则变成两份：一份是待提交给版本库的commit，也就是add过的那个版本；另一份是没有add的修改</p><ul><li><p>此时如果继续add，则两次add内容合并，git只显示你创建了一个新文件</p></li><li><p>此时如果先把之前的commit，则只把add之前的那个版本提交，add后修改的不动，此时查询状态，是修改状态(且尚未提交)。</p></li></ul><p>删除文件的操作也可以加入到暂存区中，删除是一种特殊的修改</p><h4 id="2-commit"><a href="#2-commit" class="headerlink" title="2. commit"></a>2. commit</h4><ul><li><p>一次commit之后，就会根据当前在哪一个分支，在这个分支下新开一个节点，之前节点+新commit的这些加入到这个新节点中，然后修改HEAD指针，指向这个新节点</p></li><li><p>实际上是将暂存区持久化，如果某个文件在工作区，没有被放到暂存区，那么这个文件也不会被提交。</p></li><li><p>所有的节点都是commit出来的</p></li><li><p><strong>提交commit一次之后，当前目录下的暂存区清空，git的track状态变为null，即不再追踪任何文件</strong></p></li></ul><h4 id="3-origin"><a href="#3-origin" class="headerlink" title="3. origin"></a>3. origin</h4><ul><li>云端只有一个编辑环境，并没有一个运行环境</li></ul><h4 id="4-Mac-problem"><a href="#4-Mac-problem" class="headerlink" title="4. Mac problem"></a>4. Mac problem</h4><ul><li>mac下有一个DS_Store文件，需要忽略：<strong>Add<code>**/.DS_Store</code> into <code>.gitignore</code> for the sub directory</strong></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>该图片由<a href="https://pixabay.com/zh/users/skorec-16694100/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7522129">Daniel Skovran</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7522129">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Learning</title>
    <link href="/post/49b9d038.html"/>
    <url>/post/49b9d038.html</url>
    
    <content type="html"><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h3><p>功能：</p><ul><li>系统内存管理（对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。）</li><li>软件程序管理（init进程启动其他）</li><li>硬件设备管理（eg将驱动插入运行中的内核，之前需重新编译，如今不需，使用内核模块）</li><li>文件系统管理（支持不同类型的文件系统）</li></ul><h3 id="GNU"><a href="#GNU" class="headerlink" title="GNU"></a>GNU</h3><p>Unix实用工具</p><p>GNU是一个操作系统，多使用Linux内核</p><p>基本组成包括GNU编译器套装（GCC）、GNU的C库（glibc）、以及GNU核心工具组（coreutils），GNU调试器（GDB）、GNU二进制实用程序（binutils）等</p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>指操作系统中提供访问内核服务的程序，也用于泛指所有为用户提供操作界面的程序（CLI和GUI）</p><p>多个shell命令放到一个文件中，作为一个程序执行，称为shell脚本</p><h3 id="桌面环境"><a href="#桌面环境" class="headerlink" title="桌面环境"></a>桌面环境</h3><ul><li><p>X Window</p><p>与显示器和显卡交互</p></li><li><p>KDE Plasma桌面</p></li><li><p>GNOME桌面</p><p>ubuntu可见</p></li></ul><p>Linux &#x3D; 内核 + GNU工具 + shell + 桌面环境（软件）</p><p>完整的Linux系统就是发行版</p><ul><li>核心发行版（大量可选配置，但繁琐）</li><li>特定用途的（有自动检测和自动配置）ubuntu属于此类</li></ul><h2 id="shell-1"><a href="#shell-1" class="headerlink" title="shell"></a>shell</h2><p>终端</p><ul><li>控制台终端</li><li>图形化终端：终端仿真软件包，在图形化窗口中模拟控制台终端</li></ul><h3 id="shell中的文件系统"><a href="#shell中的文件系统" class="headerlink" title="shell中的文件系统"></a>shell中的文件系统</h3><ul><li><p>linux将文件存储在名为<strong>虚拟目录</strong>的单个目录结构中，虚拟目录将计算机中所有存储设备的文件路径都纳入单个目录结构</p></li><li><p>Linux使用‘&#x2F;’而不是‘\’来分隔文件路径，主要是因为\在Linux中用作转义符</p></li><li><p>Linux系统中安装的第一块硬盘为根驱动器，包含了虚拟目录的核心</p></li><li><p>Linux使用根驱动器上一些特别目录作为挂载点，挂载点是虚拟目录中分配给额外存储设备的目录，会让这些文件出现在挂载目录下，即使处于其他物理驱动器</p></li></ul><h4 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h4><ul><li>符号链接，软链接。是一个文件，指向另一个地方的文件。要创造符号链接，原始文件必须事先存在。类似于快捷方式</li><li>硬链接，一个独立的虚拟文件，包含了原始文件的信息以及位置，但是根本上与原文件是一个文件。因此原始文件也必须先存在。</li><li>硬链接只能对处于同一存储设备文件创建</li></ul><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><p>dr-xr-xr-x：共10位，第1位表示文档类型，<code>d</code>表示目录，<code>-</code>表示文件，<code>l</code>表示链接文件，<code>d</code>表示可随机存取的设备，如U盘等，<code>c</code>表示一次性读取设备，如鼠标、键盘等。后9位，依次对应三种身份所拥有的权限，身份顺序为：owner、group、others，权限顺序为：readable、writable、excutable。</p><h3 id="常见目录"><a href="#常见目录" class="headerlink" title="常见目录"></a>常见目录</h3><ul><li>&#x2F;bin：二进制文件，存放用户级GNU工具</li><li>&#x2F;boot：引导文件</li><li>&#x2F;dev：设备目录，创建设备节点</li><li>&#x2F;etc：系统配置文件</li><li>&#x2F;home：主目录，可在此创建用户目录</li><li>&#x2F;lib：库目录，系统和应用程序的库文件</li><li>&#x2F;media：媒介目录，可移动存储设备的挂载点</li><li>&#x2F;mnt：挂载目录，临时挂载文件系统的常用挂载点</li><li>&#x2F;opt：可选目录，存放第三方软件包</li><li>&#x2F;proc：进程目录，现有内核与系统的信息</li><li>&#x2F;root：root用户的主目录，可选</li><li>&#x2F;run：系统运行时数据</li><li>&#x2F;sbin：系统二进制文件目录</li><li>&#x2F;srv：本地服务相关文件</li><li>&#x2F;sys：系统目录，存放设备、驱动及部分内核特性信息</li><li>&#x2F;tmp：临时目录</li><li>&#x2F;usr：用户目录，为次目录层级结构</li><li>&#x2F;var：可变目录，存放经常变化的文件，比如日志文件</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>cd -</code> : return last directory</li><li><code>cp</code>: 复制 + 粘贴 + 重命名</li><li><code>mv</code>: 剪切 + 粘贴 + 重命名</li><li><code>mkdir a/b/c -p</code>: -p: make parent directory as needed.</li><li><code>ls</code>：列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<ul><li>●ㅤls -a：查看所有文件包括隐藏文件（以.开头的文件就是隐藏文件）</li><li>ㅤㅤㅤ●ㅤls -l：查看当前路径下文件的读、写、执行权限ㅤ</li><li>ls -h，字节为单位显示大小</li><li>Ls -l “name”：查看某个目录</li><li>ls -dl “name”：仅查看该目录信息</li><li>ㅤㅤ●ㅤls | wc -l：查看ls下有多少个文件</li></ul></li><li><code>history</code>：查看历史输入指令</li><li><code>tree</code>: 以树形显示文件目录结构</li><li>过滤器：？为任意单个字符，*代表任意个任意字符。[]内字母表示候选，[!]表示除了</li><li><code>file &#123;filename&#125;</code> : 查看文件类型、显示二进制文件所需平台和库</li><li><code>more</code> : 分页显示文件 内容，比cat更友好，less也可以</li><li><code>tail -n &#123;number&#125; &#123;filename&#125;</code> ： 显示文件最后n行，默认十行</li><li><code>head -n &#123;number&#125; &#123;filename&#125;</code> ： 显示文件前n行，默认十行</li></ul><h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><ul><li>ps：默认显示运行在当前终端的，属于当前用户的进程</li><li>ps支持三种类型的命令行选项，即选项前加单连字符（Unix风格），不加连字符（BSD风格），双连字符（GNU风格）</li><li>top：实时监测进程</li><li>进程之间的通信是通过信号完成的</li></ul><h3 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h3><ul><li>mount：显示当前挂载的存储设备(设备名，挂载点，文件系统类型，已挂载设备访问状态)</li><li>手动挂载设备：<code>mount -t type device directory</code>，需要root用户权限</li><li>ubuntu中挂载磁盘：<ul><li><code>sudo apt-get install open-vm-tools open-vm-tools-desktop</code></li><li><code>sudo vmhgfs-fuse .host:/ /mnt/hgfs/ -o allow_other -o uid=1000</code></li><li>查询所有可以挂载的磁盘：<code>vmware-hgfsclient</code></li></ul></li></ul><h3 id="数据处理工具"><a href="#数据处理工具" class="headerlink" title="数据处理工具"></a>数据处理工具</h3><ul><li><p>sort：排序</p><ul><li><code>sort -n &lt;filename&gt;</code> : 将数字按值排序，-nr：降序排序</li><li><code>sort -M</code> : 将内容按月排序</li><li><code>sort -k number</code> : 按照第k列排序</li><li><code>sort -t &#39;char&#39;</code> : 字段分隔符，只支持单个字符，不能用字符串分隔</li></ul></li><li><p>grep：搜索</p><ul><li><code>grep [options] pattern [file]</code></li><li><code>grep -v</code> : 反向搜索，输出不符合条件的行</li><li><code>grep -n</code> : 输出行号</li><li><code>grep -c</code> : numbers of matched rows</li><li><code>grep -e [pattern1] -e[pattern2]</code> : multi-pattern match</li></ul></li><li><p>gzip:  压缩</p></li><li><p>tar：归档</p><ul><li>-c：创建新的归档文件</li><li>-x：从tar归档文件中提取文件</li><li>-v：处理文件时显示文件名</li><li>-f：结果输出到文件</li><li>-t：列出tar归档文件的内容</li><li>tar是归档格式，gzip才是压缩格式，归档压缩一般步骤：先使用tar命令对文件夹进行归档，然后再使用gzip命令对归档文件进行压缩，得到tar.gz或tgz的文件</li><li>常见命令组合：<ul><li>-cvf：创建归档，显示名称，并输出到文件</li><li>-tf：显示归档文件的内容</li><li>-xvf：提取归档文件，显示文件名，输出结果</li><li>注意都需要f选项</li></ul></li></ul></li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>etc&#x2F;shells</li><li>shell文件存在于bin和&#x2F;usr&#x2F;bin中，因为现代Linux系统中，&#x2F;bin是指向&#x2F;usr&#x2F;bin的符号链接</li><li>显示当前的shell：echo $0</li><li>可以通过直接输入shell的名称，来改变当前shell，再使用exit命令退出</li></ul><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><p>进程就是执行着的程序，因此bash本身，以及诸如ps等命令，都是进程</p><ul><li>ps -f</li><li>ps –forest</li><li>exit退出当前bash</li></ul><h3 id="进程列表"><a href="#进程列表" class="headerlink" title="进程列表"></a>进程列表</h3><p>用一系列的；可以依次执行一系列的命令，但是仍然是在当前shell里面运行；如果在最外面加上（），那么就是新建一个shell，之后再运行这些命令</p><p>子shell常用于多进程处理，但是创建成本较高，容易拖慢进度，在交互式shell中，子shell并非真正多进程处理，因为终端与子shell的I&#x2F;O绑定在了一起</p><p>而通过将进程列表置入后台，可以在子shell中进行多进程处理，因为终端不再和子shell的I&#x2F;O绑定在一起</p><h3 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h3><ul><li><p>存在于bash shell之外的命令，并不属于shell。当执行外部命令时，就会创建一个字进程，称为fork（衍生）</p></li><li><p>外部命令消耗较高</p></li><li><p>内部命令不需要新建子进程，已经与shell编译为一体</p></li></ul><p><strong>使用type判断是否为内建命令</strong></p><ul><li>有的命令有多种实现，既有内建也有外部</li></ul><h3 id="内建命令"><a href="#内建命令" class="headerlink" title="内建命令"></a>内建命令</h3><ul><li>history：存储在～&#x2F;.bash_history中</li><li>alias：为命令创建别名，alias -p查看当前所有别名。如果自定义，由于是内建命令，因此只在定义的shell进程中才有效</li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>全局：对所有shell均可见</li><li>局部：仅对创建者可见</li><li>可以使用&#x3D;直接设置用户自定义的局部变量</li><li>设置完自定义局部变量后，再使用export即可变为全局变量，在该进程及所有子进程中均可见。但如果子进程修改了该值，则不会影响到父进程</li><li>unset命令取消环境变量</li><li>对于$什么时候用：读变量需要，写变量不需要</li><li>删除与修改，以及export，都是从上到下，无法从下到上</li><li>PATH环境变量：shell查找命令时使用的目录列表，以冒号分隔</li></ul><h3 id="启动shell"><a href="#启动shell" class="headerlink" title="启动shell"></a>启动shell</h3><p>启动shell时，在几个文件中查找命令，称为启动文件。启动文件取决于启动shell的方式。有三种方式：</p><ul><li>登录时作为默认登录shell<ul><li>通过&#x2F;etc&#x2F;profile启动，用for循环去迭代&#x2F;etc&#x2F;profile.d下面的所有文件，从而启动</li><li>再执行用户自定义的启动文件</li></ul></li><li>交互式shell，生成子shell启动<ul><li>不检查&#x2F;etc&#x2F;profile，而是仅检查用户自定义的启动文件（bashrc文件）</li></ul></li><li>运行脚本的非交互式shell<ul><li>有一个BASH_ENV环境变量，当shell启动非交互式时，会检查这个文件</li></ul></li></ul><p>父shell设置并导出的，子shell都可以继承；其他不可以继承</p><p>用户想要持久化的环境变量不建议放在&#x2F;etc&#x2F;profile中，因为更新后就没了</p><p>推荐放在HOME文件夹下面的<code>.bashrc</code>文件中</p><p>用户的alias设置也往往设置在这里面</p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li>分屏</li><li>后台运行</li></ul><p>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul><li><code>tmux</code> : 新建一个session，内嵌window，内嵌pane，pane里有个shell</li><li>左右分屏：<code>ctrl + a , %</code></li><li>上下分屏：<code>ctrl + a , &quot;</code></li><li>关闭pane：<code>ctrl + d</code></li><li>选择pane：<code>ctrl + a , direction key</code></li><li>改变pane大小：鼠标拖</li><li>全屏&#x2F;取消：<code>ctrl + a , z</code></li><li>挂起session：<code>ctrl + a , d</code></li><li>打开之前的session：<code>tmux a</code></li><li>选择其他session：<code>ctrl + a, s , direction key</code></li><li>创建新window：<code>ctrl + a , c</code></li><li>选择其他window：<code>ctrl + a , w</code></li><li>复制粘贴：<code>ctrl + a , [ , select text, ctrl + a , ]</code></li></ul><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h3><ul><li>i：编辑</li><li>esc：进入一般命令</li><li>光标移动：方向键</li><li>n+space：光标右移n个字符，自动换行</li><li>n+enter：光标下移n行</li><li>0&#x2F;home：光标到本行开头</li><li>$&#x2F;end：本行结尾</li><li>G：最后一行</li><li>:n&#x2F;nG：光标移动到第n行</li><li>gg：光标到第一行， &#x3D;&#x3D; 1G</li><li>&#x2F;word：光标以后查找word字符串</li><li>?word：光标前查找word字符串</li><li>n：重复前一个查找</li><li>N：重复后一个查找</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：在n1行到n2行之间寻找word1，并将该字符串替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：全文word1换成word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：全文替换，并且替换前需要用户确认</li><li>v：选择文本</li><li>d：删除文本</li><li>dd：删除当前行</li><li>y：复制选中的文本</li><li>yy：复制当前行</li><li>p：将复制的数据在光标下一行 &#x2F; 下一个位置粘贴</li><li>u：撤销</li><li>ctrl + r：取消撤销</li><li>大于号 &gt; ：选中的文本整体向右缩进，小于号相反</li><li>: ——进入命令行模式</li><li>:w：保存</li><li>:w!：强制保存</li><li>:q ：退出</li><li>:q! ：强制退出</li><li>:wq：保存并退出</li><li>:set nu：显示行号</li><li>:set nonu ：隐藏行号</li><li>gg&#x3D;G：全文格式化</li><li>:noh : 关闭查找关键词高亮</li><li>ctrl + q ：vim卡死，强制退出</li><li>快速删除：先按d，然后按一个数字，回车，代表删几行（因为数字+回车代表下移几行）；如果先按d，再按数字，此时按G，相当于删除+光标移动，就是删到第几行(上下均可)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Linux</tag>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚基类</title>
    <link href="/post/76401623.html"/>
    <url>/post/76401623.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题引出"><a href="#问题引出" class="headerlink" title="问题引出"></a>问题引出</h2><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221028155803777.png"></p><p>问题：A中数据，在D中保存了两份。</p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h2><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221028155922106.png"></p><p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。（本例中，虚继承只影响D，对B和C无影响）</p><h2 id="C-实例"><a href="#C-实例" class="headerlink" title="C++实例"></a>C++实例</h2><p>C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。</p><h2 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h2><p>图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：</p><ul><li>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。</li><li>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。</li><li>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起，每个函数的偏移量在基类型和导出类型中均相同，这使得虚函数相对于表格首地址的偏移量在可以在编译时确定。虚函数表格的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。使用多态类型的引用或指针调用虚函数时，首先通过虚指针和偏移量计算出虚函数的地址，然后进行调用。</p><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br>&#123;<br>    <span class="hljs-type">int</span> ax; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A<br>&#123;<br>    <span class="hljs-type">int</span> bx; <span class="hljs-comment">// 成员变量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f0</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;; <span class="hljs-comment">// 重写f0</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>内存模型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span><br> <span class="hljs-function">object                                            A <span class="hljs-title">VTable</span> <span class="hljs-params">(不完整)</span></span><br><span class="hljs-function">     0 - vptr_A --------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     8 - <span class="hljs-type">int</span> ax                                    |    <span class="hljs-title">A::f0</span><span class="hljs-params">()</span>   |</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(A)</span>: <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          +--------------+</span><br><span class="hljs-function">                                                   |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br><span class="hljs-function"></span><br><span class="hljs-function">struct B</span><br><span class="hljs-function"> object                                         </span><br><span class="hljs-function">     <span class="hljs-number">0</span> - struct A                                  B VTable (不完整)</span><br><span class="hljs-function">     <span class="hljs-number">0</span> -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class="hljs-function">     <span class="hljs-number">8</span> -   int ax                                  |    B::f0()   |</span><br><span class="hljs-function">    <span class="hljs-number">12</span> - int bx                                    +--------------+</span><br><span class="hljs-function">sizeof(A): <span class="hljs-number">16</span>    align: <span class="hljs-number">8</span>                          |    A::f1()   |</span><br><span class="hljs-function">                                                   +--------------+</span><br></code></pre></td></tr></table></figure><p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前。</p><p>在单链继承中，每一个派生类型都包含了其基类型的数据以及虚函数，这些虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且由于每一个派生类都包含它的直接基类，且没有第二个直接基类，因此其数据在内存中也是线性排布的，这意味着实际类型与它所有的基类型都有着相同的起始地址。</p><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>与单链继承不同，由于两个父类完全独立，它们的虚函数没有顺序关系，即父类的第一个函数有着相同的偏移量，不可以顺序排布。 并且父类中的成员变量也是无关的，因此基类间也不具有包含关系。这使得两个父类必须要处于<strong>两个不相交的区域</strong>中，同时需要有<strong>两个虚指针</strong>分别对它们虚函数进行索引。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">                                                <span class="hljs-function">C <span class="hljs-title">Vtable</span> <span class="hljs-params">(<span class="hljs-number">7</span> entities)</span></span><br><span class="hljs-function">                                                +--------------------+</span><br><span class="hljs-function"><span class="hljs-keyword">struct</span> C                                        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span>  |</span><br><span class="hljs-function">object                                          +--------------------+</span><br><span class="hljs-function">    0 - <span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> <span class="hljs-params">(primary base)</span>                 |     RTTI <span class="hljs-keyword">for</span> C     |</span><br><span class="hljs-function">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span><br><span class="hljs-function">    8 -   <span class="hljs-type">int</span> ax                                |       <span class="hljs-title">C::f0</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   16 - <span class="hljs-keyword">struct</span> B                                +--------------------+</span><br><span class="hljs-function">   16 -   vptr_B ----------------------+        |       <span class="hljs-title">C::f1</span><span class="hljs-params">()</span>      |</span><br><span class="hljs-function">   24 -   <span class="hljs-type">int</span> bx                       |        +--------------------+</span><br><span class="hljs-function">   28 - <span class="hljs-type">int</span> cx                         |        | <span class="hljs-title">offset_to_top</span> <span class="hljs-params">(<span class="hljs-number">-16</span>)</span>|</span><br><span class="hljs-function"><span class="hljs-title">sizeof</span><span class="hljs-params">(C)</span>: <span class="hljs-number">32</span>    align: <span class="hljs-number">8</span>              |        +--------------------+</span><br><span class="hljs-function">                                       |        |     RTTI for C     |</span><br><span class="hljs-function">                                       +------&gt; +--------------------+</span><br><span class="hljs-function">                                                |    Thunk C::f1()   |</span><br><span class="hljs-function">                                                +--------------------+</span><br></code></pre></td></tr></table></figure><h2 id="虚继承-1"><a href="#虚继承-1" class="headerlink" title="虚继承"></a>虚继承</h2><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。</p><p>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p><p>还是ABCD的菱形继承：</p><p>对于形式类型为<code>B</code>的引用，在编译时，无法确定它的基类<code>A</code>它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为<code>vbase_offset</code>，位于<code>offset_to_top</code>上方。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>该图片由<a href="https://pixabay.com/zh/users/larisa-k-1107275/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=219972">Larisa Koshkina</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=219972">Pixabay</a>上发布</p><p><a href="https://zhuanlan.zhihu.com/p/41309205">https://zhuanlan.zhihu.com/p/41309205</a></p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++空类大小的探讨</title>
    <link href="/post/347fef97.html"/>
    <url>/post/347fef97.html</url>
    
    <content type="html"><![CDATA[<p>对几个网站的内容整合了一下，结尾有参考链接</p><h2 id="GeeksforGeeks"><a href="#GeeksforGeeks" class="headerlink" title="GeeksforGeeks"></a>GeeksforGeeks</h2><p><strong>Empty class:</strong> It is a class that does not contain any data members (e.g. int a, float b, char c, and string d, etc.) However, an empty class may contain member functions. </p><p>Suppose, if a class does not have any size, what would be stored on the memory location? That’s the reason when we create an object of an empty class in a C++ program, it needs some memory to get stored, and the minimum amount of memory that can be reserved is 1 byte. Hence, if we create multiple objects of an empty class, every object will have a unique address.</p><p><em>There is an interesting rule that says that an empty base class need not be represented by a separate byte. So compilers are free to make optimization in case of empty base classes.</em> </p><h2 id="StackOverflow"><a href="#StackOverflow" class="headerlink" title="StackOverflow"></a>StackOverflow</h2><p>That’s really an implementation detail. Once long ago, I thought it could be zero bytes or a thousand bytes, that it has no bearing on the language specification. But, after looking at the C++17 standard (<code>expr.sizeof</code>), <code>sizeof</code> is defined as always returning one or greater, no matter what.</p><blockquote><p>The size of a most derived class shall be greater than zero.</p></blockquote><p>This is required for, among other things, allowing you to handle arrays of objects and pointers to them. If your elements were allowed to be zero-sized then <code>&amp;(array[0])</code> would be identical to <code>&amp;(array[42])</code>, which is going to cause all sorts of havoc to your processing loops.</p><hr><p>The C++ standard guarantees that the size of any class is at least one. The C++ standard states that no object shall have the same memory address as another object. There are several good reasons for this.</p><ol><li>To guarantee that <code>new</code> will always return a pointer to a distinct memory address.</li><li>To avoid some divisions by zero. For instance, pointer arithmetics (many of which done automatically by the compiler) involve dividing by <code>sizeof(T)</code>.</li></ol><h2 id="sizeof-测试"><a href="#sizeof-测试" class="headerlink" title="sizeof 测试"></a>sizeof 测试</h2><p>来源：<a href="https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/">geeksforgeeks</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Empty</span> &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived1</span> : <span class="hljs-keyword">public</span> Empty &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Empty &#123;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived3</span> : <span class="hljs-keyword">public</span> Empty &#123;<br><span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived4</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Empty &#123;<br><span class="hljs-type">char</span> c;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dummy</span> &#123;<br><span class="hljs-type">char</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><p>大小分别是：1，1，8，1，16，1</p><p>原因：</p><ul><li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间</li><li>类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vPtr指向虚函数表VTable</li><li>虚继承：涉及到虚函数表和虚基表，会增加一个vfPtr指针指向虚函数表vfTable（多重虚继承下对应多个）；一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）</li><li>内存对齐</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>让任意两个对象的内存不同</li><li>标准规定，实现保证</li><li>能保证new出来的都是独一无二的地址</li><li>能保证某些宏内的计算数组大小的算法：<code>#define ARRAY_SIZE((A)) sizeof((A)) / sizeof((A[0]))</code>不会出现除数为0的错误</li></ol><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/">https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/</a></p><p><a href="https://stackoverflow.com/questions/2362097/why-is-the-size-of-an-empty-class-in-c-not-zero">https://stackoverflow.com/questions/2362097/why-is-the-size-of-an-empty-class-in-c-not-zero</a></p><p><a href="https://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class">https://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class</a></p><p><a href="https://blog.csdn.net/qq_22203741/article/details/106797215">https://blog.csdn.net/qq_22203741/article/details/106797215</a></p><p>该图片由<a href="https://pixabay.com/zh/users/mammiya-12752456/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7549449">Mariya 🌸🌺🌼</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7549449">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network Notes</title>
    <link href="/post/c78e5236.html"/>
    <url>/post/c78e5236.html</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概览"><a href="#计算机网络概览" class="headerlink" title="计算机网络概览"></a>计算机网络概览</h1><p>定义：通过单一技术互联的自治计算机集合</p><h2 id="关键推动因素"><a href="#关键推动因素" class="headerlink" title="关键推动因素"></a>关键推动因素</h2><ul><li>信号的数字化——取样、量化、编码——二进制流</li><li>规模效应</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按传输技术分类：</p><ul><li>广播</li><li>点到点</li></ul><p>按范围分：</p><ul><li>Internet：全球互联网</li><li>WAN（国家、大洲）</li><li>MAN</li><li>LAN（Ethernet，WiFi）</li><li>PAN（bluetooth）</li></ul><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>Internet是全球互联网，internet是网络的网络</p><p>internet是一般性概念，单指网络；Internet是一种具体的实现，即全球IP因特网</p><h3 id="常用设备区别："><a href="#常用设备区别：" class="headerlink" title="常用设备区别："></a>常用设备区别：</h3><ul><li><p>AP是无线接入点，主要的作用的是发出无线信号，连接无线终端，整合的网络管理还会通过AC（<a href="https://www.zhihu.com/search?q=%E6%97%A0%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2258986661%7D">无线控制器</a>）来完成。AC是整个无线网络的大脑，集中管理和控制整个无线网络。</p></li><li><p>家用路由器，即使在<a href="https://www.zhihu.com/search?q=mesh%E7%BB%84%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2258986661%7D">mesh组网</a>的技术下，最多不会超过20个设备组网，太多的设备组网对路由器的压力很大。家用路由器的性能，也无法进行大规模网络下的复杂计算。大部分的AP，性能都要比家用路由器高。</p></li><li><p>Modem：信号转换（数字信号与模拟信号）</p></li><li><p>router：连接子网，交换报文</p></li></ul><h2 id="网络核心：交换"><a href="#网络核心：交换" class="headerlink" title="网络核心：交换"></a>网络核心：交换</h2><p>交换核心——相互连接的路由器</p><p>数据如何在网络之间不断交换？</p><ul><li><strong>电路交换</strong> ：建立专用路径，资源保留<ul><li>优点：数据速率稳定，数据按序到达，网络层透明</li><li>缺点：建立连接时延，利用率较低</li></ul></li><li><strong>分组交换</strong> ：整体信息分为数据包，每个数据包单独转发，转发由交换机&#x2F;路由器自己决定。资源共享<ul><li>优点：利用率高，资源共享，资源按需使用，可以容纳更多用户。因为前三个特点，加上路由器的缓存，分组交换可以处理突发数据。</li><li>缺点：资源竞争冲突，拥塞，路由复杂，数据到达顺序不保证</li></ul></li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>处理时延 —— 处理位错误，通常小于ms</li><li>排队时延 —— 等待时间，取决于拥塞程度</li><li>传输时延 —— 传到介质上的时间</li><li>传播时延 —— 在介质上传播的时间</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>protocol：do what at when</p><p>为什么分层：</p><ul><li>明确结构</li><li>模块化</li></ul><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>定位：如何标识一个host</li><li>路由：从src到dest选择路线</li><li>错误控制：检错与纠错</li><li>流量控制：接收双方速度相平衡</li><li>多路复用：资源共享</li></ul><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>应用层——表示层——会话层——传输层——网络层——数据链路层——物理层</p><p>协议&amp;服务&amp;接口区别</p><p>上四层是端到端通信，下三层是点到点通信</p><h2 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><p>应用层——传输层——网络层——链路层</p><p>路由器：连接两个或多个网络，三层设备</p><p>交换机：连接一个网络内的主机</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>功能：提供一个bit流</p><h2 id="信道容量定理"><a href="#信道容量定理" class="headerlink" title="信道容量定理"></a>信道容量定理</h2><p>奈奎斯特取样准则：为了重建信号，每秒需要2H个样本（H为带宽），否则会有重叠</p><p>奈奎斯特准则： 对于一个带宽为W（Hz）的无噪声低通信道，最高的码元传输速率Bmax:</p><p>Bmax &#x3D; 2W(band)</p><p>如果编码方式的码元状态数为M，得出极限信息传输速率（信道容量）Cmax：</p><p>Cmax &#x3D; 2Wlog2M (b&#x2F;s)</p><p>因为信道总是有噪声的，因此奈奎斯特准则给出的是理论上的上限。</p><p>香农定理：带宽为W的通道，一秒内允许传输的最大bit数量</p><p>Cmax &#x3D; Wlog2(1+S&#x2F;N) (b&#x2F;s) 。S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率</p><p>SNR &#x3D; S &#x2F; R，信噪比，单位是分贝，SNR（dB）&#x3D; 10log10 (S&#x2F;N)</p><p>因此相同信道，如果是不同的模拟方法，会得到不同的数据速率，不同的信噪比</p><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号（二进制） —— &gt; 相应的模拟信号（波形图）</p><ul><li>调幅（ASK）</li><li>调频（FSK）</li><li>调相（PSK）</li></ul><p>通过调整载波的<strong>幅度，频率，相位</strong>来匹配相应的二进制信息</p><p>BPSK：将二进制0或1映射到给定相位的正弦波（通常高频波）</p><p>BPSK使用了基准的正弦波和相位反转的波浪，使一方为0，另一方为1，从而可以同时传送接受2值(1比特)的信息。以二进制调相为例，取码元为“1”时，调制后载波与未调载波同相；取码元为“0”时，调制后载波与未调载波反相；“1”和“0”时调制后载波相位差180°。</p><p>QPSK：四相相移调制是利用载波的四种不同相位差来表征输入的数字信息，是四进制移相键控。QPSK是在M&#x3D;4时的调相技术，它规定了四种载波相位，分别为45°，135°，225°，315°，调制器输入的数据是二进制数字序列，为了能和四进制的载波相位配合起来，则需要把二进制数据变换为四进制数据，这就是说需要把二进制数字序列中每两个比特分成一组，共有四种组合，即00，01，10，11，其中每一组称为双比特码元。</p><p>8PSK：三个bit标志一个码元，但解码也难了</p><p>QAM：实际在用的调制（AM + PM）</p><p>改变<strong>相位</strong>和<strong>幅度</strong>，QAM-16:一个码元4bit，QAM-64:一个码元6bit</p><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>引导式介质：信号单方向传播，通常固体介质：光纤，双绞线，同轴电缆</p><p>非引导式介质：空气、真空</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><strong>带宽</strong>（英语：<strong>Bandwidth</strong>）指信号所占据的<a href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%B8%A6">频带</a>宽度；在被用来描述<a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E9%81%93">信道</a>时，带宽是指能够有效通过该信道的信号的最大频带宽度。</p><p>对于<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%93%AC%E4%BF%A1%E8%99%9F">模拟信号</a>而言，带宽又称为频宽，以<a href="https://zh.wikipedia.org/wiki/%E8%B5%AB%E5%85%B9">赫兹</a>（Hz）为单位。（比如1.3微米波段，1.3微米说的是波段的中心，波段的范围还需要在中心加减一个德尔塔，得到能够通过信道的最大波长和最小波长，也就对应了最小频率和最大频率，这个范围就是带宽）</p><p>对于<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a>而言，带宽是指单位时间内链路能够通过的数据量。数字信号的传输是通过模拟信号的调制完成的，为了与模拟带宽进行区分，数字信道的带宽一般直接用<a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">波特率</a>或<a href="https://zh.wikipedia.org/w/index.php?title=%E7%AC%A6%E5%8F%B7%E7%8E%87&action=edit&redlink=1">符号率</a>来描述。</p><h3 id="窄带-amp-宽带"><a href="#窄带-amp-宽带" class="headerlink" title="窄带 &amp; 宽带"></a>窄带 &amp; 宽带</h3><h3 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h3><p>中频以下，无线电波遵循地球曲率</p><p>高频波段，无线电波被反射</p><h2 id="多路访问"><a href="#多路访问" class="headerlink" title="多路访问"></a>多路访问</h2><p>接入网络：接入边缘路由器（有线 或 无线）</p><p>多用户：多路访问：单一媒体上合并多个信号流，使得多个用户可以使用共享媒体</p><ul><li>空分复用——SDM</li><li>频分复用——FDM</li><li>波分复用——WDM（与频分基本一样，毕竟反比）</li><li>时分复用——TDM，缺点：同步较困难</li><li>时频复用——结合FDM与TDM，更困难</li><li>码分复用——CDM<ul><li>每一bit时间分为m个间隔，每个间隔叫做chip</li><li>每个站点分到一个唯一的m-bits的code，叫做chip sequence，是m维向量</li><li>上面的向量，每个分量为1，且相互正交</li><li>传输之前，每个station把自己要传输的内容与自己的chip seq相乘，然后相加，即得到在介质中传输的内容。传输完收到后，每个接收者再把接收内容和发送者的chip seq相乘，即得到原来发送内容。</li><li>为了区分传输0和不传输，可以让不传输为0，传输0为传输-1</li></ul></li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>两台相邻机器实现可靠通信（相邻是通过信道连接起来）</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>向网络层提供服务接口</li><li>处理传输错误</li><li>调节数据流</li></ul><p>提供的服务：</p><ul><li>无确认的无连接服务（差错很少或者实时场景，比如LAN下差错相对较少）</li><li>有确认的无连接（帧要确认是否收到，比如无线系统）</li><li>有确认的有连接</li></ul><h2 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h2><p>由于接收到的可能出错，因此需要校验，方便校验， 使用帧的概念。每一个帧都有令牌检验</p><h3 id="成帧方式"><a href="#成帧方式" class="headerlink" title="成帧方式"></a>成帧方式</h3><ul><li>字节计数（但如果计数位出错的话就会全军覆没）</li><li>字节填充的标志字节（缺点：必须以该字节的大小（比如8比特）作为传输基本单元）</li><li>比特填充的标志比特（任意大小单元组成二进制流）——usb协议中使用</li></ul><p>后两者副作用：帧大小取决于帧的数据内容</p><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>确保可靠，我们要有<strong>反馈</strong>信息。接收方返回控制帧，进行肯定或否定的确认。但可能会有<strong>帧丢失</strong>的情况，这样如何反应？需要引入<strong>计时器</strong>，但是计时器会造成这种问题：接收方接收到两个一样的帧，多次传给了网络层，所以又需要为<strong>帧分配序号</strong>，从而使接收方区分原始帧和重传帧。</p><h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><ul><li>码字，码率，海明距离</li><li>n &#x3D; m + r（m位信息，r位冗余，构成n位码字）</li></ul><p>两个合法<a href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>对应位上<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092">编码</a>不同的<a href="https://baike.baidu.com/item/%E4%BD%8D%E6%95%B0/6281904">位数</a>称为<a href="https://baike.baidu.com/item/%E7%A0%81%E8%B7%9D/5907009">码距</a>，又称海明距离。</p><p>一个有效编码集中,任意两个码字的海明距离的最小值称为该编码集的海明距离。</p><p>为了检测d位错误，需要一个距离为d+1的编码方案，因为在这样的编码方案中，d位错误不可能将一个有效码字变成另一个有效码字。</p><p>为了纠正d位错误，需要距离为2d+1的编码方案，这样，合法码字足够远，即使发生了d位变化，也还是离原来的码字更近。<strong>在不太可能有更多错误的假设下，可以唯一确认原来的码字，从而纠错</strong>。</p><h3 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h3><p>纠错码被用于无线系统，而光纤铜线等更加可靠，因此使用差错检测和重传更高效。</p><ul><li><p>奇偶校验</p><ul><li>奇校验和偶校验（事先约定好的1的个数）</li></ul></li><li><p>校验和</p></li><li><p>CRC</p><ul><li>使用生成多项式</li><li>首先对原本数据表示成多项式格式M(x)（长度为k，最高位是x的k-1次方）</li><li>有一个选定的生成多项式G(x)，计算r(x) &#x3D; reminder(M(x) * x^r &#x2F; G(x))，r是Gx的最高指数</li><li>计算的T(x) &#x3D; M(x) * x^r - r(x) &#x3D; M(x) * x^r + r(x)</li><li>接收方收到数据后，只需要查看是否能被Gx整除即可</li><li>特性：所有单个错误都能被检测出来，两个错误可以被检测出来。如果Gx有x的r次方和r-1次方，那么所有奇数错误都能检测出来</li></ul></li><li><p>海明码</p><ul><li>我们已经知道原始数据，也知道海明码的位置（1，2，4，8），需要填充这些海明码</li><li>每一位数据都会对海明码作出贡献</li><li>对哪一位作出贡献，取决于该数据的位数是2的幂次如何组合的</li><li>检错的时候，和编码时候的表差不多，还是对应的位去检测偶校验，如果出错，那么最后得到的位运算结果，从下到上，转为10进制，就是出错位置。</li><li>无法纠正二位错误，但还是能告诉有错误</li></ul></li></ul><p>如果出错后去纠正，冗余负载太高，不如重传（Ack）</p><h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><p>自动重传请求</p><p>错误一般分为两类：出错 + 丢失</p><p>常用ARQ协议见下面</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>基于反馈的流量控制</p><ul><li><p>物理层进程和某些数据链路层进程运行在一个称为NIC（网络接口卡）的硬件上，也就是网卡</p></li><li><p>网络层永远得不到任何帧头的信息，这是因为要保持网络层和数据链路层的完全分离。只要网络层对数据链路层和帧格式一无所知，那么当数据链路层协议改变时，网络层软件不用作出任何改变。（比如换了个网卡）</p></li><li><p>一个帧由4个字段组成：kind, seq, ack, info，前三个是控制信息，合称帧头</p></li></ul><h2 id="基本协议"><a href="#基本协议" class="headerlink" title="基本协议"></a>基本协议</h2><ul><li>乌托邦式的协议</li><li>无错，单工停等式协议——只是接受，接受到就可以发下一个</li><li>有错，单工停等式协议——计时器+序号（区分新帧老帧）</li><li>如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议叫自动重复请求（ARQ），常用的ARQ有SAW（停等）、GBN（回退N）、SRP（选择重传）</li><li>滑动窗口协议（最大区别-双向的）同一个链路传输两个方向，<strong>并且使用捎带确认</strong>，增大利用率</li></ul><h3 id="SAW（停等）"><a href="#SAW（停等）" class="headerlink" title="SAW（停等）"></a>SAW（停等）</h3><ul><li>发送一个帧后，等ACk（当前帧的ACK）</li><li>设置计时器，超时后自动重传</li><li>设置序号区分帧</li><li>如果ACK不标号，那么sender就不知道是在请求重传帧还是请求新帧，因此ACK返回下一帧正在期待的序号</li><li>为了减少不必要的浪费，标识ACK时使用捎带确认</li><li>因为要一直等ACK，所以是半双工</li></ul><p>效率低，因为大量时间在等待ACK（基本上等RTT）</p><h3 id="滑动窗口思想"><a href="#滑动窗口思想" class="headerlink" title="滑动窗口思想"></a>滑动窗口思想</h3><p>一次发多个待ACK的帧，每个帧有number，也可以用作流量控制</p><p>当出错的时候，就使用GBN或者SRP去处理</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>对于发送端：滑动窗口前的，是已经发送的包；滑动窗口内的，是准备好发送的，但是还没有Acked的</p><ul><li>发送端发出去后，窗口左边缩小</li><li>发送端收到Ack后，窗口右边扩张</li></ul><p>对于接受端：滑动窗口前的，是已经收到的包；滑动窗口内的，是准备好接收的，但是还没有收到或者没有ack的</p><ul><li>接收端收到包后，窗口左边缩小，表明已经收到了</li><li>接收端发出Acked后，窗口右边扩张，表明确认了，可以收后面的了</li></ul><h3 id="回退N协议（GBN）"><a href="#回退N协议（GBN）" class="headerlink" title="回退N协议（GBN）"></a>回退N协议（GBN）</h3><p>Ack for multiple frames</p><p>是滑动窗口思想的一种实现</p><h4 id="简要操作"><a href="#简要操作" class="headerlink" title="简要操作"></a>简要操作</h4><ul><li>发送窗口：<ul><li>收缩：包发出去了</li><li>扩展：收到了包对应的ACK</li></ul></li><li>接收窗口：<ul><li>收缩：包收到了</li><li>扩展：发出了ACK</li></ul></li></ul><p>考虑到传输时延，使用管道化。</p><p>为了处理管道化的错误，两种协议，回退N和选择重传</p><p>回退N对应于窗口大小为1的情形，选择重传的窗口大小大于1</p><p>计时器过期时间 T &gt; W * L &#x2F; R（先把窗口的传出去）</p><p>发现错误后也有基于ACK的和NAK的两种方法</p><p>可能丢帧，也可能丢ACK（计时器触发）</p><p>在GBN下，不是每个帧都要独立ACK</p><h4 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h4><p>A - to - B，A有一个计时器</p><h5 id="帧损坏"><a href="#帧损坏" class="headerlink" title="帧损坏"></a>帧损坏</h5><ul><li>帧内部出错：B检测到frame i出错，B必须立刻传NAK i，当A收到NAK，必须重传帧i和后面的（已经传了但是没有被Ack的那些）</li><li>帧i丢失：但是B收到帧i+1，此时B也认为出错，必须发送NAK i</li><li>帧i丢失，但是B没收到其他帧，B可能会发ACK i-1，可能发NAK i。但A的定时器最终失效肯定会保证。</li></ul><h5 id="ACK-丢失"><a href="#ACK-丢失" class="headerlink" title="ACK 丢失"></a>ACK 丢失</h5><ul><li>B收到帧i，发ACK i+1，但是丢失了，但是B可能发了个ACK i+2或者以后的，<strong>不出错</strong></li><li>B没发后面的ACK，A的定时器失效，重发</li></ul><h5 id="NAK-丢失"><a href="#NAK-丢失" class="headerlink" title="NAK 丢失"></a>NAK 丢失</h5><ul><li>A 将在关联的（稍后的）帧上超时，并重新传输帧 i 和所有后续帧。</li></ul><h5 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h5><p>不是每个帧都会被独立ACKed</p><h4 id="窗口大小讨论"><a href="#窗口大小讨论" class="headerlink" title="窗口大小讨论"></a>窗口大小讨论</h4><p>窗口大小是k个bit的序列，帧的数字可以支持2的k次方减1个GBN</p><p>否则容易引起混淆</p><p>比如有一种用重复ACK表示出错的，当k&#x3D;3，W&#x3D;8时，发送端先发送P0，然后收到ACK1，之后发了P1-P8，加上P0，8个全发了，此时又收到一个ACK1，那么既可能是都没错，正常请求下一波，也可能是之前那个出错了，重新开始请求ACK1，需要第一个ACK1去重发。</p><h3 id="选择重传协议（SRP）"><a href="#选择重传协议（SRP）" class="headerlink" title="选择重传协议（SRP）"></a>选择重传协议（SRP）</h3><p>通常和否定策略结合，即发送否定确认。</p><p>每个帧都需要单独确认（因为没有顺序了，Ack也是没有顺序，只能每个都ack一次）</p><p>需要接受端的缓存配合</p><p>效率：min（1，W*t&#x2F;S）,t是传输时延，S是一个的总时间</p><p><strong>GBN和SRP效率都是这个</strong></p><h2 id="数据链路总结"><a href="#数据链路总结" class="headerlink" title="数据链路总结"></a>数据链路总结</h2><p>提供无错的比特流</p><ul><li>成帧（三种方法确定开始和结尾）</li><li>差错控制<ul><li>编码（检错纠错）</li><li>海明码（纠错）</li><li>奇偶（检测）</li><li>CRC（检测）</li></ul></li><li>ARQ差错恢复：重发<ul><li>发送者处理丢失的帧（计时器），接收者处理出错的帧（重复ACK或者NAK）</li><li>SAW思想</li><li>滑动窗口（管道化提高SAW的效率）<ul><li>SAW</li><li>GBN（SAW + P#，ACK&#x2F;NAK的差错控制）</li><li>SPR（修改GBN，通过缓存，只重发出错的帧，需要对每个帧都ACK一下）</li></ul></li></ul></li></ul><h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>分配channel：单一（固定）&amp; 随机（动态）</p><p>core: Who can transmit at when</p><h2 id="多人访问链接"><a href="#多人访问链接" class="headerlink" title="多人访问链接"></a>多人访问链接</h2><p>包含两部分：</p><p>点对点连接：终端和交换机（台式）<br>广播连接：以太网 ，无线连接</p><p>多人访问并非只有动态，也可能有p to p</p><h2 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h2><ul><li>ALOHA</li><li>CSMA</li><li>Taking turns</li><li>collision free</li><li>limited-contention</li><li>Ethernet</li><li>Wireless LAN</li></ul><p>要解决的核心：<strong>冲突检测、恢复</strong></p><p>冲突系统：多个用户使用相同的通道，导致冲突</p><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><ul><li>frame  time：transmission delay</li><li>N : new frames</li><li>G : generated frames &#x2F; frame time(considering retransmission)</li></ul><h3 id="pure-ALOHA"><a href="#pure-ALOHA" class="headerlink" title="pure ALOHA"></a>pure ALOHA</h3><ul><li><p>检测：听</p></li><li><p>恢复：等随机时间再重发</p></li><li><p>Vulnerable time：2t（t 是 transmission delay）</p></li><li><p>max throughput : 0.184</p></li></ul><h3 id="Slotted-ALOHA"><a href="#Slotted-ALOHA" class="headerlink" title="Slotted ALOHA"></a>Slotted ALOHA</h3><ul><li>Time is cut into slots.</li><li>need sync</li><li>Vulnerable time : t</li><li>max throughput : 0.368</li></ul><p>ALOHO 的主要问题：吞吐量太低了</p><p>本着提高信道利用率，下面是CSMA</p><h3 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h3><p><strong>check before transmit</strong>（提高信道利用率）</p><ul><li>scenario : LAN (propagation delay is small)</li><li>p-Persistence CSMA &amp; Non-Persistence CSMA<ul><li>if persist, the node listen to the channel continuously, and transmit frame with probability of p.</li><li>if not persist, node doesn’t listen continuously, check channel after random time</li></ul></li><li>Collision may still happen because of propagation delay</li><li>p越小，其实吞吐量越大，倾向于conservative</li><li>主要是为了提高利用率，但冲突还是会发生，一旦发生，帧就要浪费</li></ul><p>为了减少不必要的浪费，<strong>添加冲突检测</strong>，检测到就直接停止</p><h3 id="CSMA-x2F-CD（Ethernet）"><a href="#CSMA-x2F-CD（Ethernet）" class="headerlink" title="CSMA&#x2F;CD（Ethernet）"></a>CSMA&#x2F;CD（Ethernet）</h3><p>如何检测？</p><ul><li>有线：听到的和发出的一样不</li><li>无线：难以检测<ul><li>硬件限制（只能取一）</li></ul></li></ul><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ul><li>contention</li><li>idle</li><li>transmission</li></ul><h4 id="检测时间"><a href="#检测时间" class="headerlink" title="检测时间"></a>检测时间</h4><ul><li><p>最小：t（prop）</p></li><li><p>最大：2t（RTT）</p></li></ul><p>CSMA&#x2F;CD &#x3D; slotted ALOHA with slot of length 2t</p><p>静态的适合高负载，动态的适合低负载</p><h3 id="Collision-Free-Protocol"><a href="#Collision-Free-Protocol" class="headerlink" title="Collision-Free Protocol"></a>Collision-Free Protocol</h3><ul><li>polling(轮询)：如果master出问题的话系统崩溃</li><li>token ring：单个节点出问题的话系统崩溃</li><li>bit-map（适合人多）reserve</li><li>binary countdown（有优先级）reserve</li></ul><h3 id="Limited-Contention-Protocols"><a href="#Limited-Contention-Protocols" class="headerlink" title="Limited Contention Protocols"></a>Limited Contention Protocols</h3><p>结合起来</p><p>低负载竞争（延迟小），高负载无冲突（contention-free）（利用率高）</p><p>做法：分组：组内竞争一个时间slot</p><p>关键在于动态分配时间槽</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>LAN</p><p><strong>Encapsulation</strong>: IP datagram -&gt; Ethernet frame</p><ul><li>frame structure：Preamble，Mac Address(Dest &amp; Source)，Type（higher-layer）Data，CRC</li><li>many different Ethernet standards（a family）</li><li>不可靠、无连接</li></ul><h3 id="经典以太网"><a href="#经典以太网" class="headerlink" title="经典以太网"></a>经典以太网</h3><p>传统以太网采用广播的方式发送信息，同一时间只允许一台主机发送信息，否则各主机之间发生冲突，因此属于半双工方式。</p><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><ul><li>目标地址第一位：0是普通地址，1是组地址，该组中的所有站都要接受（组播），全1是广播</li><li>type：网络层可能有多个协议，因此需要知道谁来处理</li><li>Data：不能太大，太大了收发器没有足够的内存来存储完整帧；不能太小，太小了<ul><li>冲突后会截断，截断的更短，要能区分有效帧和截断的无效数据</li><li>（更重要原因）—— 传完了，但是冲突了。冲突时接收方发出突发噪声，让发送方知道冲突了。但如果帧太短，发送方已经传完了，那么它就知道自己已经传成功了，结论错误。</li><li>所以传输时间为Lmin &#x2F; R，传播时间为d &#x2F; c，Lmin &#x2F; R  &gt;  2d &#x2F; c，要求</li></ul></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>NIC收到网络层的数据，构建帧</li><li>监听信道96 bit time，如果空闲就传，否则等待</li><li>无冲突，传输成功</li><li>有冲突，放弃并且传48bit的jam signal（突发信号），等待随机时间</li></ul><p>随机时间如何确定？</p><h4 id="二进制指数后退"><a href="#二进制指数后退" class="headerlink" title="二进制指数后退"></a>二进制指数后退</h4><p>两个站冲突后等待，如果等待时间一样，那么会一直冲突</p><p>如果冲突了m次，那么下次就从0到2的m次方-1，这些数中随机选择。期望增加</p><p>最大1023，还冲突发失败报告</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>帧越长，效率越高，但是那样变成只为一个人服务了</p><h3 id="集线器-hub-x2F-中继器"><a href="#集线器-hub-x2F-中继器" class="headerlink" title="集线器 hub &#x2F; 中继器"></a>集线器 hub &#x2F; 中继器</h3><ul><li><p>无脑传输，一个来，其余所有路线传出去</p></li><li><p>放大信号，延长传输距离</p></li><li><p>共同组成一个大的冲突域</p></li><li><p>hub没有CSMA&#x2F;CD，所以主机需要使用CSMA&#x2F;CD</p></li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>有缓存 ：store and forward</li><li>传输有目标，只传到目标地址的主机</li><li>在各自的冲突域内运行CSMA&#x2F;CD</li><li>全双工，无冲突</li><li>自学习，交换表</li></ul><h3 id="无线网络LAN"><a href="#无线网络LAN" class="headerlink" title="无线网络ＬＡＮ"></a>无线网络ＬＡＮ</h3><p>基站 : 无线和有线之间的桥梁</p><p>802.11n – Wi-Fi4，最高到600Mbps，2.4-5GHz</p><p>802.11ac – Wi-Fi5，5GHz，3.4Gbps</p><p>802.11ax – Wi-Fi6，2.4-5GHz，7Gbps</p><p>都是理论最高速度</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>衰减</li><li>干扰</li><li>多径效应(反射的存在)</li></ul><p>SNR很重要</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>隐藏终端问题 – 由于竞争者离得太远而导致站无法检测到潜在的竞争者</li><li>暴露终端问题 – 发送方由于离得近, 导致不敢发送(其实方向不一样可以发送)</li></ul><p>CSMA还是可以工作,但是无法检测冲突,只能避免冲突</p><h4 id="CSMA-x2F-CA"><a href="#CSMA-x2F-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h4><p>发送前要等一段时间(发送方和接收方都是)</p><p><strong>RTS - CTS</strong></p><p>类似于预定的思想</p><ul><li><p>如果有基站: 发送者发RTS,听到的人知道附近有人在发东西, 先别发, 接收方返回CTS, 其他人听到CTS, 也等着(CTS里面有帧长度信息所以知道等多长时间)</p></li><li><p>没有基站协调，每个host都是独一无二的， 有隐藏终端和暴露终端的问题. 与上面不同的一点, 如果一个站点听到了RTS, 但是没有听到CTS, 说明这个站点和接收方实际上很远, 可以发送</p></li></ul><p>真正希望知道的是接收方附近是否有无线电活动</p><hr><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>数据链路就是将帧从一端传到另一端，而网络层是处理端到端数据传输的最底层。因此需要知道整个网络的拓扑结构，选择路径、选择路由</p><h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><ul><li>向传输层提供服务需要独立于路由器（数量种类与拓扑）</li><li>传输层需要的网络地址需要一个统一的编址方案</li><li>无连接和连接的争论</li></ul><p>不面向连接，数据报——数据报网络（比如IP）</p><p>面向连接，虚电路——虚电路网络（比如MPLS，在ISP中使用的）</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>是网络层软件的一部分，负责确定一个入境数据包应该发送到哪个输出线路上。</p><p>路由：对使用哪一条路径作出决策，找到从src到dest的一条路径</p><p>转发：数据包到达后路由器根据路由表采取的行为（查表）</p><p>路由算法：生成和更新路由表</p><ul><li>需要全局信息的——link- state算法（链路状态算法），如Dijkstra</li><li>只需要分散信息的——迭代过程就是与邻居不断交换信息，distance-vector（距离矢量）算法，如Bellman-Ford算法</li><li></li><li>静态算法——路由改变很慢</li><li>动态算法——路由改变很快</li></ul><h3 id="最优准则"><a href="#最优准则" class="headerlink" title="最优准则"></a>最优准则</h3><p>如果节点j落在从i到k的最短路上，那么从j到k的最短路遵循同样的路径</p><h3 id="最短路径路由（dijkstra算法）"><a href="#最短路径路由（dijkstra算法）" class="headerlink" title="最短路径路由（dijkstra算法）"></a>最短路径路由（dijkstra算法）</h3><p>要求：</p><ul><li>非负</li><li>cost可加</li></ul><p>这是static算法</p><p>dijkstra需要全局信息</p><p>迭代path的长度，k次迭代后，集合N里面包含了k个到原点最近的节点</p><p>每次从不在N里面的节点中选择一个cost最小的，然后加入到N中，用这个节点去更新其他所有节点（不在N里）</p><h3 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a>距离矢量算法</h3><ul><li>局部信息</li><li>动态更新</li><li>Bellman-Ford</li><li>要有一个更新顺序，每次都按照这个顺序，根据自己的所有邻居最新情况去更新，直到不再变化</li><li>有count-to- infinite问题</li></ul><h3 id="链路状态路由过程"><a href="#链路状态路由过程" class="headerlink" title="链路状态路由过程"></a>链路状态路由过程</h3><ul><li>找到邻居，直到邻居地址</li><li>测量到邻居的cost（可以用RTT近似）</li><li>建立一个packet，里面有刚才的信息</li><li>发出packet到其他路由器</li><li>计算最短路</li><li>该路由用于OSPF中</li></ul><h3 id="分层路由"><a href="#分层路由" class="headerlink" title="分层路由"></a>分层路由</h3><p>路由器被分为多个自治系统（AS）</p><p>一个AS内运行同一种路由算法（intra- AS），比如RIP和OSPF</p><p>网关路由器：负责将数据包转发到AS以外的地方，运行的是自治系统间（inter-AS）路由协议，比如BGP</p><p>泛洪：强制泛洪（发到所有出口，重复很多），选择泛洪（只发给目的地）</p><h3 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h3><ul><li>使用泛洪</li><li>或使用多目的地路由</li><li>或使用生成树路由<ul><li>发送最少packet</li><li>只能用于link-state，需要全局的信息</li></ul></li><li>反向路径转发：生成树的近似<ul><li>如果数据包到达的链路 在其返回发送方的最短路径上，那么泛洪</li><li>其他情况，路由器直接丢数据包，因为很有可能是重复的</li></ul></li></ul><h3 id="多播路由"><a href="#多播路由" class="headerlink" title="多播路由"></a>多播路由</h3><h3 id="移动主机"><a href="#移动主机" class="headerlink" title="移动主机"></a>移动主机</h3><p>使用隧道，家庭代理</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>处理网络中的流量吞吐大小</p><ul><li>开环方式：不反馈，直接避免</li><li>闭环方式：使用反馈</li></ul><p>增加资源：通常带宽</p><p>减少流量</p><h2 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h2><p>不同应用对不同的性能要求不一样</p><p>为了平滑抖动，需要使用buffer</p><p>一个buffer里面多个包，需要管理队列，也就是调度</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>多个网络来的包混在一起，谁先转发出去？</p><ul><li>FIFO</li><li>PQ</li><li>罗宾环 &#x2F; WFQ（权重平衡队列）</li></ul><h3 id="Traffic-Shaping"><a href="#Traffic-Shaping" class="headerlink" title="Traffic Shaping"></a>Traffic Shaping</h3><p>入口点控制，调节流量</p><p>主要是ISP管理，安装在接入网中，主要为了保护网络，即使计算机发很多包，但是对后面的网络影响不大</p><h4 id="leaky-bucket"><a href="#leaky-bucket" class="headerlink" title="leaky bucket"></a>leaky bucket</h4><p>像是漏水桶一样，有一个最大吞吐速率来平滑大的burst</p><h4 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h4><p>每一个包都必须有一个token才能出去。如果空闲，那么token会有一个最大值；当来包后，可以消耗这些token，如果消耗完token，必须要等待有token才能出去。同时如果队列已经满，那么新的packet将会被丢弃</p><h2 id="定位（IP）"><a href="#定位（IP）" class="headerlink" title="定位（IP）"></a>定位（IP）</h2><p>以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><p>以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p><p>设计原则：</p><ul><li>没有硬编码地址</li><li>单一命名结构，不能有歧义</li><li>容易处理</li></ul><p>IP作用：标识一个interface，不是一个host</p><p>路由表：mapping</p><p>entry：目的IP地址 -&gt; 出站链路（转发到哪个路由器）</p><p>索引：根据目标IP地址的网络部分去索引</p><h3 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h3><p>每一个ip地址包括两部分：网络地址和主机地址（最新的还有子网id），五类地址对所支持的网络数和主机数有不同的组合。</p><p>共四个八位组，如192.168.123.253</p><p>因此只有每个八位组内部才存在一个增加进位的关系，不同的八位组之间其实是相互并列的，互不影响，完全不需要进位的</p><p>1、a 类地址 ：一个a 类ip地址仅使用第一个8位位组表示网络地址。剩下的3个8位位组表示主机地址。a类地址的第一个位总为0，因此a类地址的范围小于127，再去掉0.0.0.0的主机地址，a类地址只有126个。a类地址最大是0111 1111，也就是127</p><p>当查看一个ip的第一位（从左到右），如果是0，就是a类地址</p><p>2、b 类地址 ： b类网络地址范围 128.0.0.1~191.255.255.254。一个b类ip地址使用两个8位位组表示网络号，另外两个8位位组表示主机号。128.0对应1000 0000，191.255对应1011 1111，我们发现第一位都是1，第二位都是0，因此网络个数为2的14次方。</p><p>当查看一个ip第一位是1，第二位是0，（10开头）就是b类地址</p><p>3、 c 类地址  ：范围：192.0.0.1~223.255.255.254。这类地址可以认为与a类地址正好相反。a类地址使用第一个8位位组表示网络号，剩下的3个表示主机号，而c类地址使用三个8位位组表示网络地址，仅用一个8位位组表示主机号。192.0.0是1100 0000 0000，223.255.255是1101 1111 1111</p><p>当查看一个ip第一位是1，第二位是1，第三位是0，（110开头）就是c类地址</p><p>4、d 类地址 d 类地址用于在ip网络中的组播( multicasting ，又称为多目广播)。d类地址的前4位恒为1110 ，预置前3位为1意味着d类地址开始于128+64+32等于224。第4位为0意味着d类地址的最大值为128+64+32+8+4+2+1为239。（不可分配给主机使用）</p><p>有的会加上子网ID（一个大组织用的多），能隐藏内网结构信息，也有助于减少地址空间耗尽问题</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>Masking：从IP地址中提取出物理网络地址的过程</p><p>IP地址与掩码与运算之后，结果为1的是网络号，结果为0的是主机号</p><p>所以掩码某一位为1，代表是网络地址或者子网地址，如果为0，代表是主机地址</p><h4 id="在三层结构下（有子网地址）"><a href="#在三层结构下（有子网地址）" class="headerlink" title="在三层结构下（有子网地址）"></a>在三层结构下（有子网地址）</h4><p>那么网络id要和网络掩码与运算，子网id要和子网掩码与运算（再减去网络id）</p><h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><p>网络中太多网络和目的地，毕竟从技术上讲，每个网络都需要下一跳的信息</p><p>使用默认路由来处理未知目的地，能够减少空间，但可能不是最优路径</p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>聚合路由以节省空间</p><p>将一个连续地址块折叠成一个逻辑网络</p><p>网络地址就是这个连续块的最小值</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="为什么有传输层"><a href="#为什么有传输层" class="headerlink" title="为什么有传输层"></a>为什么有传输层</h2><p>为了定位一个路由，只需要下面三层，但是我们用户接触的是应用层，还需要一层，连接网络层与应用层。提供的是一种逻辑的连接，在不同主机的<strong>不同进程</strong>之间，对应用层掩盖网络层的一些细节。</p><p>当你位置变动，实际上网络层的细节都变了，路由方式也变了，甚至路由协议也变了。所以我们需要传输层，提供逻辑上的可靠连接抽象</p><ul><li>进程与进程之间的</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>面向连接（TCP）<ul><li>建立连接</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>不面向 – UDP</li><li>注意：网络层给了两种，面向连接（建立虚电路）与不面向（IP），但主流还是IP</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>往往有4种方式，后两种常见</p><ul><li>网卡</li><li>应用层</li><li>操作系统内核</li><li>网络应用的库</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>需要提供可靠、顺序的数据包<ul><li>数据链路层的有序，为什么网络层有无序？</li><li>原因：数据链路有序（GBN），但数据链路仅针对相邻主机的一个hop，是在以太网里运行的，但是出去了还是要靠IP，但是IP是不管的（每个packet独立转发），因此传输层需要再把顺序搞回来</li></ul></li><li>流量控制</li><li>拥塞控制</li><li>网络层运行在所有设备上，主要路由器上，由ISP拥有，但传输层主要是本机，由个人拥有</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>端口（src与dest）——端口就是传输层的address</li><li>Seq #（以bytes的多少计数，不是按照segments计数，每一个byte都被编号了）</li><li>Ack #（同上）</li><li>接受窗口（流控）</li><li>Flag<ul><li>ACK（上面的ACK是否有效）</li><li>RST（reset）</li><li>SYN（是否为syn包）</li><li>FIN（是否为fin包）</li></ul></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>IP + port</p><ul><li>UDP的端口号对应一个队列，但是TCP的端口号就是共享的</li></ul><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>两次握手行不行？</p><p>一个请求，一个回应，同时事先约定我们都从0开始（因为总还是有同步需求）</p><p>不行，根源在于建立在IP上，每个包都是单独转发，路由可能需要复制包去泛洪，这样接收者会收到重复的0，会认为是一个新的连接。</p><p>建立连接，为了防止混淆，需要每次一个ISN（初始seq num），同时三次握手来保障。</p><p>必须要有个已读回执，也就是三次握手，不会收到重复的影响</p><ul><li>序列号要重复使用，其使用间隔必须大于2T，以便于上一轮的包与ACK都expire了</li><li>MSL —— 最长lifetime</li><li>每次连接都是新的初始序列号</li><li>建立后忽略重复建立请求</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>sender发送SYN置1的包，此时seq为x</li><li>receiver返回SYN与ACK均置1的包，seq为y，同时ack为x+1</li><li>sender发送ACK的包，seq为x+1，ack为y+1</li><li>对应关系：</li><li>收到的seq是什么，发出的ack就是什么+1（表示expect下一个）</li><li>收到的ack是什么，就发出什么seq（是他所需要的）</li></ul><p><strong>重复建立连接请求</strong></p><p>如果重复请求建立同一个连接（网络原因），接收者照常回复，由发送者在第三次时候来判断，直接发RST（reset）</p><p><strong>重复ACK</strong></p><p>还是由发送者判断，发送RST</p><p><strong>同时请求建立连接</strong></p><p>各自发SYN与（SYN+ACK），结束，不再有第三次ACK</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>sender发送FIN</li><li>receiver发送ACK，此时关闭单方向的（half-close）</li><li>receiver发送FIN，表示我也结束了</li><li>sender发送ACK，表示我知道了</li><li>即每个方向用两次握手</li><li>关闭时不需要三次，因为如果丢了，还有个过期的机制，无影响</li></ul><p><strong>同时关闭</strong></p><p>各自发送FIN，收到后再发送ACK，即关闭</p><p><strong>第四步的发送</strong></p><p>为什么在第二步已经关闭了单向的连接（比如关闭一个浏览器网页），但是第四步还是可以发送ACK？</p><p>原因：第二步关闭的是应用层，第四步是传输层处理</p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>双端都需要一个状态机，才能知道目前的状态，在等的状态，等到后发什么，变成什么</p><h3 id="TCP性质"><a href="#TCP性质" class="headerlink" title="TCP性质"></a>TCP性质</h3><ul><li>流量与拥塞控制</li><li>TCP Reno，newReno：GBN</li><li>TCP SACK：SRP</li></ul><p>ACK的确认仍然是累加的</p><p>不使用NAK，但是使用重复的ACK</p><h3 id="流量-x2F-拥塞控制"><a href="#流量-x2F-拥塞控制" class="headerlink" title="流量&#x2F;拥塞控制"></a>流量&#x2F;拥塞控制</h3><p>两个变量：</p><ul><li>rwnd : 接收方目前想要接受的速度，可以小于物理buffer</li><li>cwnd：拥塞控制的变量，发送方控制</li><li>cwnd : 一个RTT内可以发出多少segment，是累加的，总数需要加起来</li><li>有效的窗口 &#x3D; min(rwnd, cwnd)</li></ul><p>拥塞控制的核心就在于调整cwnd</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul><li>指数增长</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>AIMD</li><li>线性增加</li><li>指数减少</li></ul><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>这里进行了一次不对等条件的转换</p><p>很多包时，路由器丢掉最后的包，我们直接认为：丢包 &#x3D; 出现拥塞</p><p>然后变成了检测丢包的问题：</p><ul><li>重传时间超时（RTO）</li><li>重复ACK</li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>RTO需要设置好，大于RTT（至少），也不能太长</p><p>动态调整RTO</p><p>先估计RTT：</p><p>发一个SampleRTT，然后收到ACK</p><p>然后对于SampleRTT进行平滑处理，这里方法是在时间上加窗口</p><p>current estimated &#x3D; old estimated * (1 - x) + x * sampleRTT</p><p>类似等比数列，越前面的影响越小</p><p>RTO &#x3D; estimated RTT  + 安全边距</p><p>边距就是SampleRTT的方差，同时也被应用了一个以时间为权重的窗口</p><h4 id="重复ACK"><a href="#重复ACK" class="headerlink" title="重复ACK"></a>重复ACK</h4><p>快重传（cont）</p><h4 id="慢启动细节"><a href="#慢启动细节" class="headerlink" title="慢启动细节"></a>慢启动细节</h4><p>收到一个ACK，就增大一个cwnd</p><ul><li>如果每个包都有ACK，那么整体增速就是2的n次方</li><li>每隔一个包确认一次，底数就是1.5</li><li>达到阈值后就进入拥塞控制阶段</li></ul><h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>每收到一个ACK，就增大<code>1/cwnd</code>，因此是线性增长</li></ul><h4 id="TCP-Tahoe"><a href="#TCP-Tahoe" class="headerlink" title="TCP Tahoe"></a>TCP Tahoe</h4><p>收到三个连续ACK或者超时</p><ul><li><code>ssthresh = cwnd / 2</code></li><li><code>cwnd = 1</code></li></ul><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>超时后与Tahoe一样，但是当收到三个连续ACK后</p><ul><li><code>cwnd = cwnd / 2</code></li><li>继续在拥塞避免阶段</li></ul><h4 id="快重传-amp-快恢复"><a href="#快重传-amp-快恢复" class="headerlink" title="快重传&amp;快恢复"></a>快重传&amp;快恢复</h4><p>如果有三个ACK，不至于超时那么严重，不会激进地把cwnd设置为1</p><p><code>ssthresh = min(rwnd, cwnd / 2)</code></p><p><strong>快重传</strong>：先把请求的发了，然后<code>cwnd = ssthresh + number of duplicated ACKs</code>（临时阶段）</p><p><strong>快恢复</strong>：然后从临时恢复过来</p><p>即收到新的ACK后，说明那个丢失的解决了，再设置<code>cwnd = ssthresh</code>，重新进入拥塞避免阶段</p><p>握手阶段建立的ssthresh</p><p>快重传：要不要加3，快恢复：要不要把cwnd变为一半</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>主要看公平性与吞吐量</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>理想是平分带宽</p><p>如果大家都遵守TCP的AIMD，那么会不断震荡到平衡最佳位置</p><p>但有的应用程序如果不遵守AIMD，那么会一直抢带宽（也比较难）</p><p>但是一般情况下许多应用程序可以通过并行化的方式，开启多个TCP连接，比如浏览器，这样协议是允许的</p><p>为了防止这种流氓行为，有的应用使用UDP协议（一些多媒体协议）</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>throughout &#x3D; W * MSS &#x2F; RTT，W基本决定于cwnd</p><p><code>W = min(rwnd, cwnd)</code></p><p>能发的个数 * 一个大小 &#x2F; 时间</p><h3 id="Long-Fat-Pipes"><a href="#Long-Fat-Pipes" class="headerlink" title="Long , Fat Pipes"></a>Long , Fat Pipes</h3><p>long : RTT is big</p><p>Fat: pipe is wide</p><p>Large bandwidth-delay product, TCP is not friendly.</p><h3 id="AQM"><a href="#AQM" class="headerlink" title="AQM"></a>AQM</h3><p>router如何和host联动，使得sender快速知道有一个拥塞。（除了time out）</p><p>router has buffer，which contains a queue(waiting queue)</p><p>管理队列：</p><ul><li>Drop tail（不公平）</li><li>Early Congestion Notification（Random Early Drop (RED)</li></ul><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221201111745742.png" alt="image-20221201111745742" style="zoom:67%;" /><ul><li>对于黄色的部份，由于提前丢包，发生重复ACK或者time out，sender就知道即将出现拥塞了。</li><li>丢尾的方式，大家基本同时拥塞，丢了之后，再经过一轮时间，又变成了同时拥塞</li></ul><p>RTT增大（不稳定）主要是由于queuing delay</p><p>TCP改的版本很多？IP基本没人该，因为TCP是在end device里面的，IP out of control</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>无连接，不可靠</p><p>由应用层去处理丢包，重复，失序等问题</p><p>端口抽象：允许同一主机上面多个通信端口</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>源端口</li><li>目的端口</li><li>总长度</li><li>校验和</li><li>数据</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>接触TCP的话，需要接触其内核，各种编程地配置连接，所以传输层的软件是分成了两部分，一层对上， 一层对下，socket就是使用下层接口时候的东西</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>传输层：</p><p>可靠性：ACK + 重传</p><p>流量控制：rwnd</p><p>拥塞控制：cwnd</p><p>TCP：</p><p>三次握手，四次挥手</p><p>两个阶段（慢启动和拥塞避免），两个变量（cwnd和ssthresh），两个性能指标（公平和吞吐），两种方案：Tahoe和Reno</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>UDP协议，端口53，应用层处理重发</p><p>使用缓存</p><p>域名解析</p><p>DHCP是给主机分配host，注意区分</p><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>TCP协议，端口25</p><p>MTA ：mail transfer agent</p><p>UA：user agent</p><p>SMTP主要是MAT给MTA传输时候用到的，UA其实是订阅了MTA</p><p>而M TA传给UA时，用的是其他协议，比如IMAP，POP3</p><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><ul><li>URL：统一资源定位符</li><li>cookie：保留状态</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>TCP协议，80端口</p><p>支持管道化请求与缓存</p><p>使用持久连接来提高性能</p><h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><p>声音视频：ADC，模拟to数字转换</p><p>电话波特率是8000，每个样本8bit，总共64kbps</p><p>取样，量化，编码</p><p>H.264也是视频压缩格式</p><p>交织：将一个样本分布在不同的传输上，从而减少丢失的影响</p><h2 id="H-323"><a href="#H-323" class="headerlink" title="H.323"></a>H.323</h2><p>conferencing</p><h2 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h2><p>network management</p><h2 id="路由算法-1"><a href="#路由算法-1" class="headerlink" title="路由算法"></a>路由算法</h2><p>OSPF</p><ul><li>IGP, intra-AS routing</li><li>Link-state</li><li>dijkstra</li><li>no transport protocol</li></ul><p>RIP</p><ul><li>distance vector</li><li>Bellman-ford</li><li>UDP port 520</li></ul><p>BGP</p><ul><li>Inter-AS</li><li>TCP port179</li><li>dynamic</li></ul><h1 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h1><p>密码架构</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>发送方和接收方使用一个key</p><p>使用相同的key加密和解密</p><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>每个人都有一对key：公钥和私钥，公钥所有人都知道，私钥只有自己知道</p><p>text经过一次公钥再经过一次私钥会还原成text</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul><li>接收方可以验证发送方所声称的身份</li><li>发件人不能否认发送了信息</li><li>消息不能由其他人撰写</li></ul><p>如何实现？公钥算法</p><p>Alice发给Bob</p><p>先经过自己的私钥加密，然后经过Bob的公钥加密</p><p>这样Bob收到后，先经过自己的私钥解密，只有自己能解开，然后用Alice的公钥解密，如果能解开，那么就能确定是Alice发的，就像是Alice在上面签名了一样</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>authentication</p><ul><li><p>回放攻击</p></li><li><p>中间人攻击</p></li></ul><p>使用KDC或者CA去解决，</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul><li>网络隔离</li><li>允许一些通过，阻止另一些</li><li>防止DOS攻击，比如SYN泛洪</li><li>防止非法修改数据</li><li>只允许授权访问内部网络</li></ul><p>三种防火墙</p><ul><li>无状态数据包过滤</li><li>状态包过滤</li><li>应用网关</li></ul><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p>因特网组成：</p><ul><li>接入网络 - 边缘<ul><li>ADSL非对称数字用户线</li><li>FTTH光纤入户</li><li>无线Wi-Fi（全名是IEEE 802.11 family）与蜂窝网络</li></ul></li><li>核心网<ul><li>IP</li></ul></li></ul><p>调制：</p><p>波特率 &#x3D; symbol rate</p><p>比特率 &#x3D; 数据率 &#x3D; 波特率 * X bit&#x2F;symbol</p><h2 id="传输介质-1"><a href="#传输介质-1" class="headerlink" title="传输介质"></a>传输介质</h2><ul><li>双绞线<ul><li>数据速率：5类100Mb，超5类传输速率1000M—使用8根（全部使用）</li><li>抗干扰：屏蔽双绞线能提高自己的抗干扰能力</li></ul></li><li>同轴电缆<ul><li>数据速率：10Mb&#x2F;s</li><li>抗干扰：良好</li></ul></li><li>光纤<ul><li>数据速率：2.5Gb&#x2F;s，10Gb&#x2F;s</li><li>抗干扰：优</li></ul></li></ul><p>传输介质的date rate，类型，限制范围</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>IP辅助协议，传达网络级错误的相关信息，只报告错误不做处理，封装在IP里面</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>IPv4的地址耗尽</p><p>IPv6的安全性</p><p>IPv4到6的相互转换</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>IP 到 MAc的转换</p><p>RARP：MAC到IP的转换</p><p>TCP是可靠+有序，UDP是不可靠+无序</p><p>UDP支持单播&#x2F;多播传送，但TCP只有单播传送</p><p>MAC地址中01：00:5E开头的是组播地址</p><h2 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h2><p><strong>网段</strong>是指一个<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>中使用同一<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82">物理层</a>直接通讯的那一部分。</p><p>通常使用同一物理层的设备之间必然通过相同的传输介质直接相互连接，（如交叉双绞线直接连接的两台主机）；但是两组其传输介质并非直接相连的网络设备，如果它们的传输介质通过工作在物理层的扩展设备如中继器和集线器等转接连接，则仍然被视为同一物理层中的设备，是一个而非两个网段。另外，工作在数据链路层或更高层的设备如网桥、交换机、路由器等等，由它们连接起来的两组设备仍然分别处于各自独立的物理层，因此是两个网段。</p><p>在以太网环境中，一个网段其实也就是一个冲突域（碰撞域）。同一网段中的设备共享（包括通过集线器等设备中转连接）同一物理总线，在这一总线上执行CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）机制。不同网段间不共享同一物理层，因此不会跨网段发生冲突（碰撞）。</p><p>现代高速以太网通常使用交换机代替集线器，交换机是工作在数据链路层的设备，由它转接的两组设备不在同一网段中。事实上，交换机为连在其上的每一个独立设备各自划分出一个独立的网段，每个网段只包含两个设备——交换机本身，和这个独立设备。这样，交换机就能隔离冲突，提高网络的利用率和总体性能。</p><h2 id="应用层总结"><a href="#应用层总结" class="headerlink" title="应用层总结"></a>应用层总结</h2><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221227232642827.png" alt="image-20221227232642827"></p><p>SNMP：网络管理协议</p><p>POP，IMAP：收邮件</p><p>RTP，RTSP：串流</p><p>注意DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议</p><p>调制解调器是物理层的设备</p><h2 id="NIC的四种模式"><a href="#NIC的四种模式" class="headerlink" title="NIC的四种模式"></a>NIC的四种模式</h2><ul><li>广播模式：接收全1的帧</li><li>多播模式：接收所有组播的帧</li><li>直连：接收目标地址为自己地址的帧</li><li>混杂模式：接收所有帧，wireshark这么做的，交换机和网桥的NIC也工作在这个模式</li><li>一般NIC的默认模式：广播模式 + 直连（direct）</li></ul><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>该封面图片由<a href="https://pixabay.com/zh/users/xiserge-15871962/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887">xiSerge</a>在<a href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887">Pixabay</a>上发布</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithms</title>
    <link href="/post/e67bc23f.html"/>
    <url>/post/e67bc23f.html</url>
    
    <content type="html"><![CDATA[<p>一些算法思路， 持续更新。。。</p><span id="more"></span><p>理解一个算法没有任何意义</p><p>多练多写才是王道（应试角度）</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基于<strong>分治</strong>思想，最难的是划分</p><ol><li>确定分界点</li><li>调整区间</li><li>递归处理左右两边</li></ol><p>有边界问题建议模板 </p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>; <br><span class="hljs-type">int</span> x = q[l], i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; j) &#123;<br><span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(q[i] &lt; x);<br><span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(q[j] &gt; x);<br><span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>&#125;<br><span class="hljs-built_in">quick_sort</span>(q, l, j);<br><span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在递归函数中用i，注意x不可以取q[l]，否则容易发生死循环</p><p>最开始的边界，如果是在最左侧或者最右侧，然后极端情况下，i与j没有交换过，在边界处相遇，此时下一次递归时，有一个区间会无限递归。比如取x为q[l]，在最左侧，然后i与j都是0，递归时又选择了i，递归区间是[0, -1]和[0, n-1]，无限递归。如果取x为q[r]，在最右侧，i与j都是n-1，递归时选择了j，递归区间为[0, n-1]和[n, n-1]，还是有无限递归。而且即使是x取q[(r+l)&#x2F;2]，也要注意向上向下取整的问题，不能取到某个边界。所以必须一左一右</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>基本思想也是分治，最难的是归并</p><ol><li>找分界点（中间）</li><li>递归</li><li>归并 —— 合二为一  O(n)</li></ol><p>利用<strong>双指针</strong>算法，遇到相同的，可以把第一个数组的元素先放进去，因为归并一般是稳定的。快排也可以是稳定的，只要能保证所有元素都不同即可，那如何保证呢？可以把数组的下标也参与到排序中，构建一个二元组，即可保证不同。</p><p>时间复杂度：O(nlogn)</p><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid); <span class="hljs-comment">// 闭区间</span><br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br>    <br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class="hljs-keyword">if</span>(q[i] &lt;= q[j]) temp[k++] = q[i++];<br>        <span class="hljs-keyword">else</span> temp[k++] = q[j++];<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <br>    <span class="hljs-comment">// target数组 ：q[l...r]</span><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = temp[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>本质：有单调性一定可以二分，但是二分的不一定都是单调性。二分的本质是边界。某个性质在左侧满足，右侧不满足，这种边界点就可以二分找到。</p><p>直接上边界，没有边界的只是特殊情况。</p><p>从左到右的最后一个：<code>if(true) l=mid; else r=mid-1</code>，此时mid需要加上1</p><p>从右到左最后一个：<code>if(true) r=mid; else l=mid+1</code>，mid不需要加1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (r - l) / <span class="hljs-number">2</span> + l;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。在于对左值的处理，这里左值的处理是 left = mid。因为正常的left+mid&gt;&gt;1都是向下取整，如果不加上1，left=mid会死循环</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// int mid = (r - l + 1) / 2 + l;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>选择模板，看如何更新，根据更新结果去改mid，因为C++<strong>整除都是向下取整</strong>，所以如果更新了l，那么mid需要加1，如果更新的是r，mid就不变。为什么更新l要加1的例子：如果l&#x3D;r-1，算出来mid等于l，如果又true了，那么l&#x3D;mid，区间没变，死循环。</p><p>eg：数的二分，check时，不是单调或者大小，二是性质，先定性质，而不是大小关系（当然大小关系可以作为性质）。比如大于等于x或者小于x，再比如大于x和小于等于x，不同的性质就可二分。但同时也要注意，一个性质取反后并不一定正确，比如想找到小于等于x的最后一个数字，此时不可用大于x的第一个数字作为性质，会多一个。</p><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>不需要处理边界，因此更加简单。当区间长度很小时，我们就可以认为找到了答案。区间长度往往比要求的精度再小两个数量级。</p><p>浮点数二分甚至可以直接循环100次。不再管精度，相当于把区间长度除以2的100次方。</p><h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="大整数相加"><a href="#大整数相加" class="headerlink" title="大整数相加"></a>大整数相加</h2><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A, vector&lt;<span class="hljs-type">int</span>&gt;&amp; B)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || i &lt; B.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>        <span class="hljs-keyword">if</span>(i &lt; B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        <br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>; <span class="hljs-comment">// 进位</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和-amp-差分"><a href="#前缀和-amp-差分" class="headerlink" title="前缀和&amp;差分"></a>前缀和&amp;差分</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] +...+a[i];<br></code></pre></td></tr></table></figure><p>如何求S[i]：for循环</p><p>作用：快速求出原数组中一段数字的和，基本也是唯一的应用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">S[r] - S[l<span class="hljs-number">-1</span>] = Sum[l, r]<br></code></pre></td></tr></table></figure><p>tips：<strong>S[0] &#x3D; 0</strong>，好处：方便处理边界。不仅求区间和，也能求前缀和。</p><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><p>求前缀和：二维矩阵。</p><p><code>s[i][j]</code>如何计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + a[i][j];<br></code></pre></td></tr></table></figure><p>用前缀和，子矩阵内所有元素的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>前缀和逆运算</p><p>给定a数组，构造一个数组b，使得给定数组是该数组的前缀和。</p><p>差分主要应对的场景：对于给定A数组一段区间的元素，统一进行加或减的操作，将O(n)变为O(1)</p><p>【l，r】区间中加c，则令<code>b[l] += c, b[r + 1] -= c</code>，从而达到修改原数组的效果。等到用原数组的时候再O(n)改回原数组。</p><p>差分<strong>没有构造</strong>的过程，可以认为a和b初始都是0，每一个初始值都可以认为是在[x, x]这个长度为1的区间加上c。也就是只有一个操作。</p><h3 id="一维模板"><a href="#一维模板" class="headerlink" title="一维模板"></a>一维模板</h3><p>构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><p>改回：</p><p>（所有b依次加起来是对应位置的a）</p><p><code>a[i] = b[i] + a[i - 1];</code></p><h3 id="二维模板"><a href="#二维模板" class="headerlink" title="二维模板"></a>二维模板</h3><p>核心操作：以（x1, y1）为左上角，（x2，y2）为右下角的子矩阵的所有数同时加上C。</p><p>构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2][y1 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br></code></pre></td></tr></table></figure><p>改回：(b是相邻元素的差，因此用所有b加起来是a，而且要分开，使得b元素更新，不然下一次用的还是旧的)</p><p><code>a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];</code></p><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><p>一般两大类，一类单线双向奔赴（快速排序），一类双线单向（归并排序），还有单线单向（一般借助单调性）</p><p>所有双指针算法都是O(n) , 能够将n方优化到O(n)</p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">while</span>(j &lt; n &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j++;<br>    <br>    <span class="hljs-comment">// other logic</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般都可以先从暴力开始，寻找是否有单调关系。单调性在于：当i向一个方向变化时，j是否只可能向一个方向变化，能够证明这点，基本就可以双指针。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="常见操作："><a href="#常见操作：" class="headerlink" title="常见操作："></a>常见操作：</h2><ul><li>求第k位：<code>n &gt;&gt; k &amp; 1</code></li><li>返回x的最后一位1，<code>Lowbit(x) = x &amp; (-x)</code></li><li>lowbit的常见用法：求1的个数</li></ul><h2 id="为什么用补码："><a href="#为什么用补码：" class="headerlink" title="为什么用补码："></a>为什么用补码：</h2><p>计算机里面没有减法，我们是用加法做减法。</p><p>一个数的负数，应该满足的是<code>x + (-x) = 0</code>，所以<code>-x = 0 - x</code>，在用0减去x的时候我们需要在最前面借一位1，变成1000.000减去x，也就等价于x取反后再加1。</p><h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><p>有些数据本身很大， 自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性， 那么可以对其进行离散化处理。当数据只与它们之间的<strong>相对大小</strong>有关，而与具体是多少无关时，可以进行离散化。</p><p>难点：</p><ul><li>去重</li><li>如何算出离散化后的值（二分）</li></ul><p>Essentially, we map the original number to a value which is the index of the discretization array. And the mapping rule is based on the order of the number.</p><p>离散化的本质是将<code>数字本身key</code>映射为它在数组中的索引<code>index</code>。所以通过二分求索引（value -&gt; index)是离散化的本质。二分时，求的是数字离散化后将会在哪里，也就是下标。比如一个数组是[1, 5, 100, 2000]，通过二分，左边界是0，右边界是大小，我们将数字映射成他在数组中的大小顺序，也就是1，2，3，4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">discretize</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (r - l) / <span class="hljs-number">2</span> + l;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x)<br>            r = mid;<br>        <span class="hljs-keyword">else</span><br>            l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// plus one because we want to map original data to [1...n]</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>每种数据结构都有自己的特点，优点或缺点，而我们使用数据结构一般都是看中了它<strong>能快速地支持某种操作</strong>。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>结构体加指针效率较低，尤其是new节点，一般十万个节点，平时笔试一般不会动态链表的方式，直接上数组。</p><p>数组模拟单链表（应用的较多的是邻接表（n个链表），邻接表最多的用处又是存储图和树，这样是用单链表做的）</p><p>模拟双链表，用来优化某些问题。</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class="hljs-type">int</span> head, e[N], ne[N], idx;<br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = <span class="hljs-number">-1</span>;<br>    idx = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 在链表头插入一个数a</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class="hljs-comment">// 将头结点删除，需要保证头结点存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// add x after k</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx;<br>    idx++;<br>&#125;<br><br><span class="hljs-comment">// remove the k-th number</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>邻接表</strong>：把每个点的临边保存下来，就是n个单链表，可以用来保存图和树</p><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>数组模拟比STL的好处：快</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N;<br><span class="hljs-type">int</span> stack[N], top;<br><br><span class="hljs-comment">// add element</span><br>stack[++top] = x;<br><br><span class="hljs-comment">//remove element</span><br>top--;<br><br><span class="hljs-comment">// is empty</span><br><span class="hljs-keyword">if</span>(top &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">not</span> empty<br><span class="hljs-keyword">else</span> empty<br><br><span class="hljs-comment">// top</span><br>stack[top]<br></code></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N;<br><span class="hljs-type">int</span> queue[N], head, tail = <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">// insert element</span><br>q[ ++ tail] = x;<br><br><span class="hljs-comment">// pop element</span><br>head++;<br><br><span class="hljs-comment">// is empty</span><br><span class="hljs-keyword">if</span>(head &lt;= tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">// get head</span><br>queue[head];<br><br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>常见的只有一类题型</p><p>给定一个序列，找到每一个数的左边比他小的 离他最近的数（或者右边）</p><p>同样先尝试暴力，然后抽象</p><p>随着<code>i</code>向右移动，<code>j</code>向左移动，我们可以把<code>i</code>左边所有的数字放到一个栈里，然后遍历这个栈，（从栈顶开始）。</p><p>那么这个栈有什么性质？或者说栈中是否有一些元素，他们永远不可能被输出？——如果<code>x</code>与<code>y</code>都在栈中，x在前，y在后，且y更小，那么x后续便不会被输出，所以栈中没有逆序对（x&lt;y 且 a[x] &gt; a[y]），也就是单调的了</p><p>每个元素只有一次进栈与出栈，因此复杂度是2n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> tt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x : a) &#123;<br>    <span class="hljs-keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt--;<br>    stk[++top] = x;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>滑动窗口里面的最大值和最小值</p><p>先暴力，发现找最大值最小值是O(k)的复杂度，然后我们看看能不能转变成O(1)的复杂度（通过单调性，把没用的元素删掉），挖掘要点，转变</p><p>取最值的话是端点，找一个值可以二分</p><p>窗口是用队列去维护的，看看哪些元素是没用的</p><p>找最大值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N;<br><span class="hljs-type">int</span> a[N], q[N];<br><br><span class="hljs-comment">// 最小值</span><br><span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-comment">// add a element to q</span><br>    <span class="hljs-comment">// q[hh]是窗口起点下标，如果太小，说明头该出去了</span><br>    <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh++;<br>    <span class="hljs-comment">// 缩小其实是从后向前缩小</span><br>    <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) tt--;<br>    <br>    q[++tt] = i; <span class="hljs-comment">// 先加进去，因为i可能是最小值（唯一的）</span><br>    <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, a[q[hh]]);<span class="hljs-comment">//minimum</span><br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 最大值</span><br>hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class="hljs-number">1</span>) hh++;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt--;<br>    <br>    q[++tt] = i;<br>    <br>    <span class="hljs-keyword">if</span>(i &gt;= k - <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a[q[hh]]);<br>&#125;<br><br><span class="hljs-comment">// 实际上是双端队列</span><br></code></pre></td></tr></table></figure><ul><li>暴力算法怎么做</li><li>如何优化</li></ul><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>快速存储字符串集合的数据结构</p><p>Trie树一般字符不多，要么全大写要么全小写</p><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N;<br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>]; <span class="hljs-comment">// 存储树中每个节点的子节点</span><br><span class="hljs-type">int</span> cnt[N]; <span class="hljs-comment">// 每个元素的出现次数（统计词频）</span><br><span class="hljs-type">int</span> idx; <span class="hljs-comment">// 为每个元素赋一个编号</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>; <span class="hljs-comment">// 第几层</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : str) &#123;<br>        <span class="hljs-type">int</span> x = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (son[p][x] == <span class="hljs-number">0</span>) son[p][x] = ++idx;<br>        p = son[p][x];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : str) &#123;<br>        <span class="hljs-type">int</span> x = ch - <span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (son[p][x] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        p = son[p][x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><strong>思路精巧，代码比较短，很受面试官喜欢</strong></p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>并查集用来：</p><ul><li>将两个集合合并</li><li>询问两个元素是否在一个集合中</li></ul><p>并查集能以近乎O(1)的复杂度中实现。</p><p>用树的形式维护集合，树根节点的编号就是集合的编号。每个节点存储他的父节点。p[x] 表示x的父节点。</p><h2 id="使用操作"><a href="#使用操作" class="headerlink" title="使用操作"></a>使用操作</h2><ul><li><p>判断树根：<code>p[x] == x</code></p></li><li><p>求x的集合编号：<code>while(p[x] != x) x=p[x]; </code></p></li><li><p>求x与y 是否在一个集合中：分别求编号</p></li><li><p>合并集合：把一个树根放到另一个树上即可</p></li></ul><h2 id="优化——路径压缩"><a href="#优化——路径压缩" class="headerlink" title="优化——路径压缩"></a>优化——路径压缩</h2><p>求编号的优化（之前是与树的高度成正比，需要n的循环）</p><p>如何优化：一旦找到某条路径的根节点，我们就把这条路上所有的节点都指向根节点。这样每一个点，最多走n步，之后每次都是一步。</p><p>模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (p[x] != x) p[x] = <span class="hljs-built_in">find</span>(x); <span class="hljs-comment">// 这里既递归处理，同时也有路径优化</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><br><span class="hljs-comment">// merge set a and set b</span><br>p[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-comment">// Query a and b</span><br><span class="hljs-built_in">find</span>(a) = = <span class="hljs-built_in">find</span>(b);<br></code></pre></td></tr></table></figure><p>加上当前集合有多少元素（附加操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// when merge</span><br>size[<span class="hljs-built_in">find</span>(b)] += size[<span class="hljs-built_in">find</span>(a)];<br>p[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(b);<br><br><span class="hljs-comment">//之后直接返回size[find(a)]即可找到当前集合元素的个数</span><br></code></pre></td></tr></table></figure><p>加上距离根节点的距离信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p[N], d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x] != x) &#123;<br>        <span class="hljs-type">int</span> par = <span class="hljs-built_in">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = par;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-comment">// 初始化时d[i] = 0</span><br><br><span class="hljs-comment">// 合并时</span><br>p[<span class="hljs-built_in">find</span>(a)] = <span class="hljs-built_in">find</span>(b); <span class="hljs-comment">// a加入b</span><br>d[<span class="hljs-built_in">find</span>(a)] = distance; <span class="hljs-comment">// 根据具体问题，初始化find(a) 偏移量</span><br></code></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一个完全二叉树，使用数组存储</p><p>两个基本操作：<code>down(x)</code> —— 往下调整， <code>up(x)</code> —— 往上调整</p><p><strong>背景：小根堆</strong></p><p>如果把一个数字变大了，那么我们应该把数字向下移动——down操作</p><p>如果把一个数字变小了，那么我们应该把数字向上走——up操作</p><p><strong>注意堆的下标从1开始，因为如果从0开始，但是0的左儿子还是0，冲突</strong></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>插入一个数 : <code>heap[++ size] = x; up(x);</code></li><li>求最小值 : <code>heap[1];</code></li><li>删除最小值 : <code>heap[1] = heap[size]; size--; down(1);</code></li><li>删除k处 : <code>heap[k] = heap[size]; size--; down(k); up(k);</code></li><li>修改任何一个元素 : <code>heap[k] = x; down(k); up(k); </code>可能变大变小，于是我们就都做一遍，注意这两个函数实际只会执行一个。</li><li>（后两个STL中没有）</li></ul><p>建立堆：一个一个插是nlogn，我们可以实现n。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size / <span class="hljs-number">2</span>; i ; i--) <span class="hljs-built_in">down</span>(i);<br><span class="hljs-comment">// 最下一层不用down</span><br></code></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="down"><a href="#down" class="headerlink" title="down"></a>down</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> size;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t = u; <span class="hljs-comment">// u is original </span><br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(u != t)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u], h[t]);<br>        <span class="hljs-built_in">down</span>(t); <span class="hljs-comment">// 大的换到了t，继续down(t)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="up"><a href="#up" class="headerlink" title="up"></a>up</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[u], h[u / <span class="hljs-number">2</span>]);<br>        u /= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 更简单，因为up只有一个父节点</span><br></code></pre></td></tr></table></figure><h1 id="idx"><a href="#idx" class="headerlink" title="idx"></a>idx</h1><p>不管是链表，Trie树还是堆，他们的基本单元都是一个个结点连接构成的，可以成为“链”式结构。这个结点包含两个基本的属性：本身的值和指向下一个结点的指针。按道理，应该按照结构体的方式来实现这些数据结构的，但是用数组模拟，主要是因为比较快。</p><p>原来这两个属性都是以结构体的方式联系在一起的，现在如果用数组模拟，如何才能把这两个属性联系起来呢，如何区分各个结点呢？</p><p>idx的操作总是++idx，这就保证了不同的idx值对应不同的结点，这样就可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。</p><p>对于<strong>单链表</strong>，利用idx联系结构体本身的值和next指针，因此e[idx]可以作为结点的值，ne[idx]可以作为next指针。同理可以理解双链表。</p><p><strong>Trie树</strong>中有个二维数组 son[N] [26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗<strong>多叉树</strong>，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：<strong>son[1] [0]&#x3D;2表示1结点的一个值为a的子结点为结点2</strong>;如果son[1] [0] &#x3D; 0，则意味着没有值为a子结点。这里的son[N] [26]相当于链表中的ne[N]。</p><p><strong>堆</strong>中的每次插入都是在堆尾，但是堆中经常有up和down操作。所以结点与结点的关系并不是用一个ne[idx] [2]可以很好地维护的。但是好在堆是个完全二叉树。子父节点的关系可以通过下标来联系（左儿子2n，右儿子2n+1）。就数组模拟来说，知道数组的下标就知道结点在堆中的位置。所以核心就在于即使有down和up操作也能维护堆数组的下标（k）和结点（idx）的映射关系。 </p><h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>map，将一个大的集合空间，映射到从0到n的一个较小区间内。</p><p>实现快速添加与查找某个数</p><p>但可能会出现冲突，根据处理冲突的不同，分为两种：开放寻址与拉链法</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>不断找下一个可以允许的地方，找到目标地址后，不断向后看</p><p>只开一个一维数组，但要原数组的两到三倍，一般能够把冲突降低到比较小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(x)</span> <span class="hljs-comment">// 如果找到x，返回下标，如果没有，返回应该存储的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">while</span>(h[k] != null &amp;&amp; h[k] != x) &#123;<br>        k++;<br>        <span class="hljs-keyword">if</span>(k == N) k = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><p>设置一个常量用来代表“无穷大”。</p><p>比如对于int类型的数，采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大，加一个正数会溢出。</p><p>所以常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：</p><ul><li>0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。</li><li>0x3f3f3f3f * 2 &#x3D; 2122219134，无穷大相加依然不会溢出。</li><li>可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。</li></ul><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>第一次映射后得到的其实是链表，每个槽是一个链（单链表），期望链的长度是1</p><p>其实也就是邻接表，在存储图的时候也是用这个方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], idx = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N; <span class="hljs-comment">// N一般是一个质数，大于最大范围的质数</span><br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k = (x % N + N) % N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[k]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>        <span class="hljs-keyword">if</span>(e[i] == x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>将字符串看作p进制数，转换成数字，但是数字可能比较大，再去取模</p><ul><li>不能映射成0（A和AA一样）</li><li>p&#x3D;131或者13331，Q等于2的64次方，可以假定没有冲突。2的64次方，刚好是无符号long long的大小，所以我们会发现不用取模，直接计算。每次溢出的时候，就等价于模2的64次方</li><li>前缀哈希，可以获得子串哈希值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N;<br>ULL h[N], p[N];<br><br><span class="hljs-comment">// !!! notice p[0] = 1</span><br>p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    p[i] = p[i - <span class="hljs-number">1</span>] * P; <span class="hljs-comment">// 位权</span><br>&#125;<br><br><span class="hljs-function">ULL <span class="hljs-title">hash</span><span class="hljs-params">(string str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = h[i - <span class="hljs-number">1</span>] * P + str[i];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// str1 == str2</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">int</span> l1, <span class="hljs-type">int</span> r1, <span class="hljs-type">int</span> l2, <span class="hljs-type">int</span> r2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h[r1] - h[l1] * p[r1 - l1 + <span class="hljs-number">1</span>] == h[r2] - h[l2] * p[r2 - l2 + <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>公共的：size，empty，clear（队列无）</p><p>系统分配空间时，所需的时间与空间大小无关，与申请次数有关。因此vector采用倍增。不够的时候，再申请两倍，然后把之前的copy过来。如果申请n个元素，第一次copy1个，然后2个，4个，8个，最后到了n&#x2F;2个，<strong>申请次数是logn</strong>，但copy次数均摊下来每个元素都近似O(1)</p><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>front, back, push_back, pop_back</code></p><p>支持比较运算</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>二元组，两种属性，且需要排序</p><p>相当于两个变量的结构体加上一个比较函数</p><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><ul><li>substr：begin and length</li><li>c_str: char array</li></ul><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><code>push pop back front</code></p><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><code>push top pop</code></p><p>用堆实现，默认大根堆。如何小根堆</p><ul><li>插入时插入-x，取出时再变成原来的数字</li><li>定义时：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code></li></ul><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>push pop top</code></p><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>front back push_back pop_back push_front pop_front []</code></p><h2 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h2><p><code>insert find count erase</code></p><ul><li>erase : 参数为x：删除所有x；参数为迭代器，删一个</li><li>lower_bound：返回大于等于x的最小的数</li><li>upper_bound：返回大于x的最小的数</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>根据索引取值—— [ ] – 时间复杂度是logn</p><h2 id="无序家族"><a href="#无序家族" class="headerlink" title="无序家族"></a>无序家族</h2><p>基本都是O1，但不支持lower_bound，upper_bound（因为无序），++，–</p><h1 id="DFS-amp-BFS"><a href="#DFS-amp-BFS" class="headerlink" title="DFS &amp; BFS"></a>DFS &amp; BFS</h1><p>DFS空间需要O(h) , 与树高度成正比。BFS空间则是2的h次方，但是BFS有最短路的概念，能够用于找最短的东西。</p><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>每个DFS都一定对应一个搜索树</p><p><strong>关键是想清楚顺序</strong>，两个要点：回溯（恢复现场）和剪枝</p><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == n) &#123;<br>        <span class="hljs-keyword">for</span>() <span class="hljs-comment">// output</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">// 树横向扩</span><br>        <span class="hljs-keyword">if</span>(!st[i]) &#123; <span class="hljs-comment">// unused</span><br>            path[u] = i;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="八皇后"><a href="#八皇后" class="headerlink" title="八皇后"></a>八皇后</h3><p>多种思路</p><p>如果分析出每一行只可能会有一个皇后，那么唯一的变数就是皇后在每一行的位置了（也就是列），所以可以使用全排列的思路做，大小为n的全排列（以行为单位枚举）</p><p>时间复杂度为n乘以n的阶乘</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == n) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, chess[i]);<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// i is col</span><br>        <span class="hljs-comment">// [u, i]这个点在哪条对角线上面</span><br>        <span class="hljs-keyword">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n + u - i]) &#123;<br>            chess[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class="hljs-literal">false</span>;<br>            chess[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但也可以<strong>格子为单位</strong>去枚举，每一个格子都有放和不放两种可能</p><p>时间复杂度为2的n方次方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(y == n) y = <span class="hljs-number">0</span>, x++; <span class="hljs-comment">// next line</span><br>    <span class="hljs-comment">// 代替了二重循环的格式</span><br>    <br>    <span class="hljs-keyword">if</span>(x == n) &#123;<br>        <span class="hljs-keyword">if</span>(s == n) &#123;<br>            <span class="hljs-comment">// print</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s); <span class="hljs-comment">// 不放</span><br>    <br>    <span class="hljs-comment">// 放</span><br>    <span class="hljs-keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[n + x - y]) &#123;<br>        chess[x][y] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        row[x] = col[y] = dg[x + y] = udg[n + x - y] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(x, y + <span class="hljs-number">1</span>, s + <span class="hljs-number">1</span>);<br>        row[x] = col[y] = dg[x + y] = udg[n + x - y] = <span class="hljs-literal">false</span>;<br>        chess[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>dp问题和最短路问题其实是互通的，dp是一种特殊的最短路问题（无环存在的最短路问题）</p><p>边权为1 时，BFS才能做最短路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue q;<br>    q.<span class="hljs-built_in">push</span>(init);<br>    <br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> h = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// extense other data</span><br>        q.<span class="hljs-built_in">push</span>(xxxxx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Tree-amp-Graph"><a href="#Tree-amp-Graph" class="headerlink" title="Tree &amp; Graph"></a>Tree &amp; Graph</h1><p>树是一种特殊的图，无环连通图</p><p>图：有向图和无向图（无向图是特殊的有向图）</p><p>邻接矩阵储存（不常用）</p><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>每个节点都是单链表</p><p><code>tip：输入超过1M的时候cin和scanf才有区别</code></p><p>树和图的深度优先遍历和宽度优先遍历，是一种特殊的深度优先搜索和宽度优先搜索。</p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">10e5</span>;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// flag</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// been searched</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != - <span class="hljs-number">1</span>; i = ne[i]) &#123; <span class="hljs-comment">// u的所有出边</span><br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(!st[j]) <span class="hljs-built_in">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 求最短路（需要权重为1）</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(d[j] == <span class="hljs-number">-1</span>) &#123;<br>                d[j] = d[t] + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图宽搜的应用-拓扑排序"><a href="#图宽搜的应用-拓扑排序" class="headerlink" title="图宽搜的应用 - 拓扑排序"></a>图宽搜的应用 - 拓扑排序</h2><p>求有向图的拓扑排序</p><p>拓扑序列所有边都是从前指向后面的。因此有环图不可能有拓扑序列。</p><p>有向无环图 &#x3D; 拓扑图</p><p>入度、出度。</p><p>因此所有入度为0的点都可以作为起点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">d[N]; <span class="hljs-comment">// ru du</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topo_sort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> hh = <span class="hljs-number">0</span>, tt =<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(d[i] == <span class="hljs-number">0</span>) q[++tt] = i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(hh &lt;= tt) &#123;<br>        <span class="hljs-type">int</span> t = q[hh++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(--d[j] == <span class="hljs-number">0</span>) &#123;<br>                q[++tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tt == n - <span class="hljs-number">1</span>; <span class="hljs-comment">// tt start from 0, when tt is n - 1, all points have entered the queue</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h1><p>不证明算法的正确性，考察问题抽象，使得原问题变成一个最短路问题，抽象边与顶点</p><p>图论侧重于实现，不在于原理</p><h2 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h2><p>源：起点，汇：终点</p><p>n: 顶点数量，m：边数量</p><p>稠密图：m是n^2级别</p><p>稀疏图：m与n是一个级别</p><h3 id="无负权"><a href="#无负权" class="headerlink" title="无负权"></a>无负权</h3><h4 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h4><p>O(n^2), 与边无关，适应于<strong>稠密图</strong>（存储用邻接矩阵），边多</p><p>伪代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-number">1.</span> dist[src] = <span class="hljs-number">0</span>, dist[other] = +infinite<br>s：当前已经确定最短距离的点的集合<br><span class="hljs-number">2.</span> <span class="hljs-keyword">for</span> v : i —&gt; n<br>t =  不在s中的距离最近的点<br>    把t加入到s中<br>        用t更新其他点的距离<br></code></pre></td></tr></table></figure><p><strong>基于贪心思想</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// node start from 1</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++ )&#123;<br>        <span class="hljs-type">int</span> min_dist = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (min_dist == <span class="hljs-number">-1</span> || dist[min_dist] &gt; dist[j])) &#123;<br>                min_dist = j;<br>            &#125;<br>        &#125;<br>        <br>        st[min_dist] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[min_dist] + g[min_dist][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆优化的Dijkstra算法"><a href="#堆优化的Dijkstra算法" class="headerlink" title="堆优化的Dijkstra算法"></a>堆优化的Dijkstra算法</h4><p>O(mlogn) ，适应于<strong>稀疏图</strong>（存储用邻接表），如果边多，变成O(n^2logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;);<br>    dist[<span class="hljs-number">1</span>]= <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> distance = t.dirst, num = t.second;<br>        <br>        <span class="hljs-keyword">if</span>(st[num]) <span class="hljs-keyword">continue</span>;<br>        st[num] = <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[num]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">// j是节点编号，i是一个节点（idx）</span><br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[num] + w[i]) &#123;<br>                dist[j] = dist[num] + w[i];<br>                q.<span class="hljs-built_in">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> dist[n];<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="有负权"><a href="#有负权" class="headerlink" title="有负权"></a>有负权</h3><h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p>贝尔曼-福特算法与<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB%E7%AE%97%E6%B3%95">迪科斯彻算法</a>类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以<a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法</a>选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共 |V| - 1次，其中 V 是图的点的数量。在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。</p><p><strong>循环</strong></p><p>每次循环操作实际上是对相邻节点的访问，第 k 次循环操作保证了所有深度为 k 的路径最短。由于图的最短路径最长不会经过超过 V - 1条边，所以可知贝尔曼-福特算法所得为最短路径。</p><p>迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p><p>O(nm)，可以用来求不超过k条边的最短路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> <span class="hljs-number">1</span> : n <span class="hljs-comment">// 经过k次，k的意义：经过不超过k条边，走到每个点的最短距离</span><br>    <span class="hljs-keyword">for</span> edge a, b, w<br>        dist[b] = <span class="hljs-built_in">min</span>(dist[b], w); <span class="hljs-comment">// 松弛操作</span><br><br><span class="hljs-comment">// 经过循环，dist[b] &lt;= dist[a] + w （三角公式）</span><br></code></pre></td></tr></table></figure><p>n次迭代，每一次循环所有边，a, b, w</p><p>如果迭代n次，第n次还有更新，说明经过n条边，n条边意味着n+1个顶点，所以有环，但是由于条件是选更小的路径，说明有负环。（可以求负环，但不怎么用）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dist[N], backup[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> a, b, w;<br>&#125; edges[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bellman</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <br>        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-comment">// k is the limit of edge number</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123; <span class="hljs-comment">// </span><br>            <span class="hljs-type">int</span> a = edges[j].a, b = edges[i].b, w = edges[i].w;<br>            dist[b] = <span class="hljs-built_in">min</span>(dist[b], backup[a] + w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h4><p>SPFA：对上面<strong>优化</strong>，一般是O(m)，最坏O(nm)</p><p>思路：一个边要想更新，那么这条路径上他前面的边必须先更新。换句话说，只有更新过的边才有资格去更新别人。因此可以用一个队列去保存更新过的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> h[N], e[N], ne[N], w[N];<br><span class="hljs-type">int</span> st[N], dist[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; e[idx] = b, ne[b] = h[a], h[a]=idx++;&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">pop</span>();<br>        st[t] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br>            <span class="hljs-type">int</span> j = e[i];<br>            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[i] + w[i]) &#123;<br>                dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + w[i]);<br>                <span class="hljs-keyword">if</span>(!st[j]) &#123;<br>                st[j] = <span class="hljs-literal">true</span>;<br>                q.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-100</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h4><p>在寻找最短路过程中，记录一个cnt数组，只要在寻找过程中出现了大于等于n的路径，那么说明有n+1个点，说明有环，找的是最短的，所以是负环。</p><p><strong>注意：此时初始化时不能只放起点，因为可能有负环但是某个点到不了，所以需要把所有的点放进去</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>st[i] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><br><span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>&#123;<br><span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br>st[k] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i]) &#123;<br><span class="hljs-type">int</span> j = e[i];<br><span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i]) &#123;<br>dist[j] = dist[t] + w[i]; <br>                <span class="hljs-comment">// 利用的是最短路去找负环，这样才能在找到n条边的时候断定有负环</span><br>cnt[j] = cnt[t] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(cnt[j] &gt;= n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span>(!st[j]) &#123;<br>st[j] = <span class="hljs-literal">true</span>;<br>q.<span class="hljs-built_in">push</span>(j);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多源汇最短路"><a href="#多源汇最短路" class="headerlink" title="多源汇最短路"></a>多源汇最短路</h2><p>任意两个点的最短路</p><p>Floyd算法——O(n^3) （动态规划）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k++) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j =<span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>d[k,i,j] : 从i点开始，经过1到k的中间点，到达j的最短距离</p><p>k是阶段，先枚举k，从k-1转移过来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dist[k, i, j] = dist[k - <span class="hljs-number">1</span>, i, k] + dist[k - <span class="hljs-number">1</span>, k, j]<br></code></pre></td></tr></table></figure><p>从i到j经过1到k &#x3D; 1到k-1的阶段，加上第k个点，就是从i到k，再从k到j</p><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><ul><li>初始化距离最大值</li><li>n次循环，每次找到集合外的到集合最近的点<code>t</code>，用<code>t</code>更新其他点到集合的距离</li><li>prim中的<code>dist[t]</code>，代表的是t这个点到集合的最短距离</li><li>对于重边，保留最小值，对于自环，不用管，因为最小生成树里面没有环，实际上只要我们把一个有自环的点放入进去，后续就不会再管到自环</li><li>与Dijkstra算法很像，不同点在于<code>dist[t]</code>的意义，D代表的是t这个点到起点的最短距离，P中代表的是到集合的最短距离</li><li>先累加再更新，否则自环对于权值计算有影响，一个有自环的点，是经过其他的边进入的集合，和负权自环无影响，但是如果更新了，那么这个点到集合的最短距离可能变成了自环上的负数，有影响。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br><span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="hljs-keyword">return</span> INF;<br>        <br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(i) res += dist[t];<br>        <span class="hljs-comment">// 第一个点到集合距离应该为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            dist[j] = <span class="hljs-built_in">min</span>(dist[j], g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><ul><li>将所有边按照权重从小到大排序 O(mlogm)，快排，但是快排常数小</li><li>枚举每条边，如果两个点不在一个集合，加入到一个集合，更新res</li><li>由于该算法只关注边，不关注顶点，所以直接<strong>结构体</strong>存储即可，不需要邻接</li></ul><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="染色法"><a href="#染色法" class="headerlink" title="染色法"></a>染色法</h2><ul><li>判断一个图是不是二分图</li><li>一个图是二分图当且仅当图中不含有奇数环</li></ul><h2 id="匈牙利"><a href="#匈牙利" class="headerlink" title="匈牙利"></a>匈牙利</h2><h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h3 id="质数判定——试除法"><a href="#质数判定——试除法" class="headerlink" title="质数判定——试除法"></a>质数判定——试除法</h3><p>b | a表示b整除a，即a是b的倍数</p><p>循环除法找到，但是O(n)，同时利用约数的性质，约数都是一对一对出现的，如果b | a, 那么 a&#x2F;b | a，所以不需要枚举到a - 1，只需要枚举到a&#x2F;b即可，变成logn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i++ ) &#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分解质因数——试除法"><a href="#分解质因数——试除法" class="headerlink" title="分解质因数——试除法"></a>分解质因数——试除法</h3><ul><li>从小到大枚举所有因数(brust)——枚举所有数也可以，不需要仅枚举质数。因为当我们枚举到i的时候，n中已经不包含任何2到n-1的质因子了</li><li>n中最多只包含一个大于根号n的质因子，因为如果有两个的话，相乘大于n，否定。因此只需要先枚举到根号n的地方，剩下的如果大于1，就是大于根号n的质因子，最后一个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n / i; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// i must be 质数</span><br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>(n % i == <span class="hljs-number">0</span>) &#123;<br>                n /= i;<br>                cnt++;<br>            &#125;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; endl;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="筛选质数"><a href="#筛选质数" class="headerlink" title="筛选质数"></a>筛选质数</h3><p>如果循环再依次判断，复杂度较高</p><p>每当遍历到一个，直接将他所有的倍数去除，也就是for循环每次加自己即可</p><p>优化后能够达到O(n)，只把质数的倍数去掉即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(!st[i]) &#123;<br>            primes[cnt ++ ] = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + i; j &lt;= n; j += i) &#123;<br>                st[j] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 遍历过，且必为合数</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="求约数"><a href="#求约数" class="headerlink" title="求约数"></a>求约数</h3><ul><li>试除法，成对出现，与质数类似</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class="hljs-keyword">if</span>(n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span>(i != n / i) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(n / i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p>基于约数个数定理</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221106202640167.png" alt="image-20221106202640167"></p><p>知道质因数组成，则对a进行组合即可，每种组合对应一个约数</p><ul><li><p>int范围内最多也就是1500多个约数</p></li><li><p>12 ：1，2，3，4，6，12</p></li><li><p>12 &#x3D; 2 * 2 * 3</p></li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>模型（如背包）、线性DP，区间DP，状态压缩DP</p><h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><ul><li>01背包（一个物品用一次）</li><li>完全背包（没有限制）</li><li>多重背包（每种物品数量不一样，告诉有几个）</li><li>分组背包（n组，每一组里有若干种，每一组选一个）</li></ul><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h4><p><code>f[i][j]</code>，考虑需要<strong>几维</strong>来表示状态，每一个<strong>状态的含义</strong>是什么</p><ul><li>状态的<strong>集合</strong>是什么<ul><li>所有选法</li><li>只从前i个物品里面选</li><li>总体积 &lt;&#x3D; j</li><li>满足上面两个<strong>条件</strong>的所有<strong>选法的集合</strong></li></ul></li><li><code>f[i][j]</code>的数值就是状态的<strong>属性</strong>是什么（<strong>最大值，最小值，数量</strong>）</li></ul><h4 id="状态计算："><a href="#状态计算：" class="headerlink" title="状态计算："></a>状态计算：</h4><p>把每一个状态计算出来</p><ul><li>对应集合的划分</li><li>分成更小的子集，使得子集都能计算出来</li><li>背包中，分为两大类：含i和不含i</li><li>划分原则：不重复、不漏掉</li><li>不含i的最大值：从1到i中选，总体积小于j，并且不包含i。合并这三个条件，就是从1到i-1，总体积小于j，选择的最大值，也就是<code>f[i][j - 1]</code>。注意一定存在</li><li>含i的最大值：从1到i中选，总体积小于j，并且我必须要包含第i个元素。直接求不好求，可以先把i去掉，同时体积也减去vi，因为这种条件下，反正都是要选择第i个物品的，那么我们把第i个物品的价值和体积先拿出来，最大的价值还是最大的，最后再加上第i个物品的价值。此时最大的情况是i-1 和 j - vi，再统一加上第i个物品的价值，也就是<code>f[i-1][j-vi] + wi</code>。注意不一定存在，如果当前物品体积大于背包目前最大容量的时候，那么就不存在了。</li><li>但是要注意，含i的情况，可能不存在，就是指现在背包的容量已经装不下第i个物品了</li></ul><p>优化：一般都是对dp方程作等价变形，先做朴素的</p><p>状态的集合，i和j就变成了元素的属性</p><p>dp问题是没有模板的，具体问题具体分析。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j ++ ) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>    <span class="hljs-keyword">if</span>(j &gt;= v[i]) &#123;<br>      dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], w[i] + dp[i - <span class="hljs-number">1</span>][j - v[i]]); <br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一维优化"><a href="#一维优化" class="headerlink" title="一维优化"></a>一维优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = V; j &gt;= v[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], w[i] + dp[j - v[i]]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>状态表示与上面一样</p><h4 id="状态计算"><a href="#状态计算" class="headerlink" title="状态计算"></a>状态计算</h4><p>划分集合，将总的划分成 第i个物品选择0-k个，这些情况</p><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221120151615069.png" alt="image-20221120151615069"></p><p>对于每一种情况，再去分别考虑：</p><ul><li>第i个物品选了0个，对应01背包里面不选择的情况<code>f[i][j] = f[i - 1][j]</code></li><li>第i个物品选了1个，对应01背包里面选择的情况：<code>f[i][j] = w[i] + f[i - 1][j - w[i]]</code></li><li>第i个物品选了2个，仍然采取曲线的方式，先把这俩放进去，再考虑后面的最大值：<code>f[i][j] = w[i] * 2 + f[i - 1][j - v[i] * 2]</code></li><li>第i个物品选了k个：<code>f[i][j] = k * w[i] + f[i - 1][j - k * v[i]]</code></li></ul><h4 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j ++ ) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k * v[i] &lt;= j; k ++ ) &#123;<br>      dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], w[i] * k + dp[i - <span class="hljs-number">1</span>][j - k * v[i]]);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可能超时</p><h4 id="优化版"><a href="#优化版" class="headerlink" title="优化版"></a>优化版</h4><p>我们发现：</p><p><code>f[i][j] = max(f[i-1][j], f[i-1][j-v]+w, f[i-1][j-2v]+2w, f[i-1][j-3v]+3w)....</code></p><p><code>f[i][j-v] = max(f[i-1][j-v], f[i-1][j-2v]+w, f[i-1][j-3v]+2w), f[i-1][j-4v]+3w....)</code></p><p>由上式可得：</p><p><code>f[i][j] = max(f[i - 1][j], f[i][j-v] + w)</code></p><p>又变成了<strong>两种情况</strong>：不拿第i个，变成了<code>f[i-1][j]</code>，如果拿第i个的话，由于是无限个，所以其实还是考虑前i个物品，只不过此时体积变了。整体变成了<code>f[i][j-v]+w</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= V; j ++ ) &#123;<br>    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - v[i]] + w[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：上面的伪代码有个问题，如果不拿的话，肯定还是能更新<code>f[i][j]</code>的，但是如果把j初始设置为最小体积，会导致不拿时候更新出错，也就是不再更新。还是尽量分开讨论，先把能更新的更新掉，之后再看体积问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= V; j ++ ) &#123;<br>    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j]; <span class="hljs-comment">// 必定可以更新</span><br>    <span class="hljs-keyword">if</span>(j &gt;= v[i]) &#123;<br>      dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i][j - v[i]] + w[i]); <span class="hljs-comment">// 根据情况更新</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一维优化-1"><a href="#一维优化-1" class="headerlink" title="一维优化"></a>一维优化</h4><p>将二维变成一维</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt;= V; j ++ ) &#123;<br>    dp[j] = dp[j]; <span class="hljs-comment">// delete</span><br>    <span class="hljs-comment">// 因为把上面这一句删掉，所以下面的if语句没有用了，所以才可以在for循环的初始化时候设置v[i]</span><br>    <span class="hljs-keyword">if</span>(j &gt;= v[i]) &#123; <span class="hljs-comment">// 由于循环内只有这个判断，因此才可以修改j的初始值</span><br>      dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i]] + w[i]);<br>      <span class="hljs-comment">// 循环不需要倒置过来，之前01背包之所以倒置，是因为我们本来想用第i-1层的更新第i层的，但是不倒置的话，就是用第i层更新第i层，而这刚好符合我们完全背包的需求，所以不需要逆向循环</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>总结：</p><ul><li>01背包：用第i-1层更新第i层</li><li>完全背包：用第i层更新第i层</li></ul><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>状态表示与01背包相同</p><h4 id="状态计算-1"><a href="#状态计算-1" class="headerlink" title="状态计算"></a>状态计算</h4><p>与完全背包其实类似，只不过完全背包的k，变成了每种物品的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j++ ) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ ) &#123;<br>            dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], k * w[i] + dp[i - <span class="hljs-number">1</span>][j - v[i] * k]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于有个数限制，因此无法像完全背包那样去优化</p><h4 id="二进制优化"><a href="#二进制优化" class="headerlink" title="二进制优化"></a>二进制优化</h4><p>原理复杂</p><p>某物品最多有s件，我们需要从所有的物品中选择若干件，使这个背包的价值最大。没有说某物品一定需要选多少件出来，也没有说一共要选多少件出来。只是选择若干件，至于选几件，无所谓，但要保证价值最大。</p><p>如果某物品最多k件，那么像上面我们还需要做k次循环，但是我们果真需要完全遍历一遍吗？实则不然。因为从1-k中的k个数，我们只需要用logk个数就可以表示出来。（如同任何一个数都可以用2的多少次幂相加得到）</p><p>所以做法是：某物品有s件，我们把它分成了好几个大的物品。第一个大物品包含1件该物品，第二个大物品是包含2件该物品，第三个大物品是包含4件该物品，第四个大物品是包含8件该物品,…..依次类推。</p><p>对所有种类的物品都这么表示出来，那么对于初始每个物品最多s件，我们就把这个件数条件给消去了，然后我们只需要从新的物品中中任意选择（每种物品选或不选），就可以得到原来问题的每种物品选几件的目的。</p><p>从而变成01背包问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-type">int</span> a, b, s; <span class="hljs-comment">// v, w, s</span><br>  cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>  <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(s &gt;= k)<br>  &#123;<br>    cnt++;<br>    v[cnt] = a * k;<br>    w[cnt] = b * k;<br>    s -= k; <span class="hljs-comment">// s 是剩余的个数</span><br>    k *= <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(s &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    cnt++;<br>    v[cnt] = a * s;<br>    w[cnt] = b * s;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 01 bag</span><br>n = cnt;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j--) &#123;<br>    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - v[i] + w[i]]);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dp[m];<br></code></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>分成几组，每组中只能选一个</p><p><code>f[i][j]</code>本身表示从<strong>前i组</strong>物品里面选，总体积不超过j的最大价值</p><p>而状态计算的时候，则是将集合划分，将<code>f[i][j]</code>的集合划分出来，枚举的是第i组物品选哪一个。</p><p>也就是说<code>f[i][j]</code>，可以由这些情况得来：第i组物品不选，第i组物品选择第一个，，，，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= m; k ++ ) &#123;<br>      <span class="hljs-keyword">if</span>(v[i][k] &lt;= j) &#123;<br>        dp[j] = <span class="hljs-built_in">max</span>(dp[j], w[i][k] + dp[j - v[i][k]]);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线性DP"><a href="#线性DP" class="headerlink" title="线性DP"></a>线性DP</h2><p>递推方程有一个明显的线性关系。</p><p>多维状态，求的时候有一个明显的顺序</p><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><ul><li><p>状态表示：对三角形分行列，易知维数。</p><ul><li>集合<code>f[i][j]</code>表示的是什么？——所有从起点开始，走到(i, j)这个点的路径。</li><li>属性：上述路径和的最大值</li></ul></li><li><p>状态计算：集合划分：来自左上方的和来自右上方的</p></li></ul><p><strong>tips：</strong>当计算中涉及到了<code>f[i - 1]</code>这种情况的时候，一般让i从1开始，不用处理边界</p><p>时间复杂度：状态的数量 * 转移一次的数量</p><p><code>f[i][j] = a[i][j] + max(f[i - 1][j - 1], f[i - 1][j]);</code></p><p>注意：初始化时候，需要多初始化一列，因为最右边的一列需要用到更右边的一列，尤其是有负数的时候。</p><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><ul><li><p>状态表示：一维即可</p><ul><li>意义：以第i个数结尾的上升子序列的集合</li><li>属性：上述最大长度</li></ul></li><li><p>状态计算</p><ul><li>最后一个数已经以i结尾了，所以划分区间时需要考虑第i - 1个数</li><li>第i - 1个数是几，如果第i - 1个数是 j 的话， 那么f[i] &#x3D; f[j] + 1</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  dp[i] = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ ) &#123;<br>    <span class="hljs-keyword">if</span>(a[j] &lt; a[i]) &#123;<br>      dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长递增子序列II"><a href="#最长递增子序列II" class="headerlink" title="最长递增子序列II"></a>最长递增子序列II</h3><p>上述的算法时间复杂度为O(n^2)，能否继续优化？</p><p>对于序列<code>3 1 2 5</code>来说，先看序列长度为1的子序列，3和1，但是我们发现后面的数，如果能够接在3后面，那么也一定能够接在1后面，并且1更小，情况更好。所以3就没必要存下来了。</p><p>求到第i个数，前面的所有序列可以按照长度分类。长度为n的上升子序列，只需要存储一个结尾最小的子序列。</p><p>因此可以存储前面的每种长度的上升子序列的结尾的最小值。且随着长度的增加，其结尾的值也递增。</p><p>在这种情况下，如果想求一下以a[i]结尾的最长上升子序列，只需要在上面的数组中，找到最后一个小于a[i]的数，然后+1即可。而找到小于ai的最大值，只需要二分即可。再更新q[i + 1]即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) &#123;<br>  <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>  <span class="hljs-keyword">while</span>(l &lt; r) &#123;<br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(f[mid] &lt; a[i]) l = mid;<br>    <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>  &#125;<br>  len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>  f[r + <span class="hljs-number">1</span>] = a[i];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><ul><li>状态表示：由于两个序列，需要二维（经验 ）<ul><li><code>f[i][j]</code>意义：所有在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的公共子序列</li><li>属性：上述最大长度</li></ul></li><li>状态计算：<ul><li>选不选a[i]或者b[j]，四个子集合</li><li>a[i]和b[j]都不选：<code>f[i - 1][j - 1]</code></li><li>a[i]和b[j]都选：<code>f[i - 1][j - 1] + 1</code></li><li>a[i]不选，b[j]选，所以a[i]不出现在子序列当中，但是b[j]一定出现在公共子序列当中的情况，注意这个集合不等于<code>f[i - 1][j]</code>， <code>f[i - 1][j]</code>指的是在第一个序列的前i - 1个字母中出现，且在第二个序列的前j个字母中出现的公共子序列最大值，也就是说<code>f[i - 1][j]</code>其实可能不会选j，是包含了前面我们想要的情况的。但是我们注意到，后者完全包含前者，而我们要求的是最长公共子序列长度，后者又被包含在<code>f[i][j]</code>中，即从集合个数上来讲，前者小于后者。当我们想在所有情况里选出最大值时，某元素可能会重叠出现在多个情况中，但是对于求最大值来说，是没有影响的。因此是可以使用后者等价替代前者的</li><li>a[i]选，b[j]不选同上</li><li>同时我们又注意到第一种情况被后面的情况包含，因此可以忽略</li></ul></li><li><code>dp[i][j] = max(dp[i - 1][j - 1], max(dp[i - 1][j], dp[i][j - 1]));</code></li></ul><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><ul><li>状态表示：<ul><li>意义：<code>f[i][j]</code> : 所有将a[1 - i]变成b[1 - j]的方式的集合</li><li>属性：操作的最小值</li></ul></li><li>状态计算：</li></ul><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h3 id="合并石头"><a href="#合并石头" class="headerlink" title="合并石头"></a>合并石头</h3><ul><li>状态表示：二维<ul><li>集合：将第i堆石头到第j堆石头合并为一起的合并方式</li><li>属性：最小</li></ul></li><li>状态计算：<ul><li>逻辑上划分的第一步（或者实际操作的最后一步）一定是将最后剩下的两堆合并在一块，因此状态划分可以以最后一次分界线为依据去划分</li><li>最后一步的最小代价，就是先合并左边的最小代价，加上右边的最小代价，最后再加上这两堆的总重量（i到j的重量和——前缀和）</li><li>区间dp需要注意一点：每次计算<code>f[i][j]</code>时，要确保他的所有子情况都已经准备好了，而最小的子情况是长度为1的情况。所以我们需要先循环区间的长度，再循环起点，就可以达到长度由小到大了</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++ )&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> start = <span class="hljs-number">1</span>; start + len - <span class="hljs-number">1</span> &lt;= n; start ++ ) &#123;<br>    <span class="hljs-type">int</span> i = start, j = start + len - <span class="hljs-number">1</span>;<br>    dp[i][j] = <span class="hljs-number">1e8</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = i; i &lt;= j - <span class="hljs-number">1</span>; k ++ ) &#123;<br>      dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i][k] + dp[k + <span class="hljs-number">1</span>][j] + s[j] - s[i]); <span class="hljs-comment">// s is prefix sum</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="计数DP"><a href="#计数DP" class="headerlink" title="计数DP"></a>计数DP</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>正整数 n 可以表示成若干个正整数之和，n 共有多少种不同的划分方法</p><h4 id="完全背包思路"><a href="#完全背包思路" class="headerlink" title="完全背包思路"></a>完全背包思路</h4><p>将n看作为容量为n的背包，每个数字都是一个物品，要刚好装满背包。由于每个数字可以用多次，所以是完全背包问题。</p><ul><li>状态表示：二维<ul><li>集合：考虑选前i个数字，刚好和为j的集合</li><li>属性：集合大小</li></ul></li><li>状态计算：<ul><li>用完全背包的思路，<code>dp[i][j] = dp[i - 1][j] + dp[i][j - i]</code></li></ul></li></ul><h4 id="another-idea"><a href="#another-idea" class="headerlink" title="another idea"></a>another idea</h4><ul><li>状态表示：二维<code>f[i][j]</code><ul><li>集合：考虑总和为i，且使用了j个数字的集合（<code>j&lt;=i</code>）</li><li>属性：集合大小</li></ul></li><li>状态计算：<ul><li>分为两大类：j个数字中至少有一个数字1的，以及j个数字里一个数字1都没有的<ul><li>对于至少有一个1的，我们可以先把这个1去了，对应的集合为<code>f[i - 1][j - 1]</code>，因为去掉一个1后，相当于总和变为i - 1，同时数字也少了一个</li><li>对于没有数字1的，说明所有数字都是大于1的，这时我们把所有数字都减去1，还是一个集合，对应<code>f[i - j][j]</code></li><li>最后的结尾需要把总和为n的不同组合数加起来</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java 学习笔记</title>
    <link href="/post/eef4f581.html"/>
    <url>/post/eef4f581.html</url>
    
    <content type="html"><![CDATA[<p>持续更新。。。</p><span id="more"></span><ul><li><p>JDK：Java Development Toolkit，JDK包括JRE（Java Runtime Environment）</p></li><li><p>Java中只有两种类型：基本类型和引用类型。引用类型引用对象（reference to object），而基本类型直接包含值（directly contain value）。所有类的&#x3D;都是引用，所以会互相影响。</p></li><li><p>Java中字符串是不可变的，都是通过引用去操作对象实例</p></li><li><p>数组为定长，不能增减</p></li><li><p>Java是面向对象的语言，Java的类把方法与数据连接在一起，构成了自包含式的处理单元。为了将基本类型也能当作对象去处理，Java为每个基本类型都提供了包装类，从而当作对象处理。</p></li><li><p>equal的默认方法是使用“&#x3D;&#x3D;”运算符去比较两个对象的引用地址，而不是去比较内容。如果想要对于自定义的类也去使用equal，那么需要重写该方法，从而比较内容。</p></li><li><p>向上转型，即子类对象赋值给引用父类的变量。背后思想在于“平行四边形也是一种四边形”，所以很自然地可以将平行四边形看作是一种四边形。这是从具体类到抽象类的转换，所以总是安全的。这也是多态机制的基本思想，也是工厂模式的基础。而在向下转型时，是将具体类赋值给一个引用抽象类的变量，会出问题，我们必须通过显式类型转换，告诉编译器，这个抽象类也是一个具体类，才不会出错（感觉就像是把父类没有的成员变量与方法声明了一下）</p></li><li><p>Java 的关键字都是小写，比如instanceof，能够检测一个对象到底是不是一个类的实例。</p></li><li><p>一切都是对象，为了得到某个对象，我们需要一个 key，通常这是reference。</p></li><li><p>增强型for循环，只能读，不能改，因为每次得到的元素都是一份copy</p></li><li><p>可预测型字符串，推荐用string builder</p></li><li><p>signature &#x3D; function name + params</p></li><li><p>Java一直都是pass by value</p></li><li><p>模糊参数，用int…，本质是一个array</p></li><li><p>在多态中，继承抽象类的所有子类需要重写父类的抽象方法。但是同样会有冗余代码。比如某个子类可能不需要这个抽象方法，但是又不得不重写。如果将不需要的分出一个抽象类，又会出现多继承。于是有了接口的概念。哪个类需要这个方法，哪个类就去实现这个接口。同时注意在接口中定义的任何字段默认都是static和final的。</p></li><li><p>向上转型为抽象接口也可，不仅是抽象类</p></li><li><p>Java不允许多重继承，但是使用接口就可以实现多重继承</p></li><li><p>被声明为final的对象引用只能指向唯一 一个对象，不能指向其他的对象。但由于一个对象本身的值是可变的，因此真正不可变，可以用<code>static final</code>，通过static，在内存中开辟恒定内存，保持不变。</p></li><li><p>Java中的全局常量，通常都是<code>public static final</code></p></li><li><p>定义为final的方法是不能被重写的。</p></li><li><p>内部类的实例必须要绑定在外部类的<strong>实例</strong>（注意不是外部类）上，内部类可以用外部类的东西，外部类<strong>不能</strong>用内部类的东西。</p></li><li><p>由于Java是面向对象的语言，所以在Java中异常也是以类的实例的形式出现的。</p></li><li><p>try结构发生异常后，直接执行catch的语句与之后的，try中异常语句后的不再执行。</p></li><li><p>在抛出异常的方法中处理异常，可以直接使用try-catch结构，而在方法的声明处写出throws结构，并给出要抛出的异常，是要把异常抛给方法调用者。然后在方法的调用处，因为可能会有异常，还是要有一个try-catch</p></li><li><p>throws是在方法声明处，可声明多个，可以一层一层向上抛出，但是始终要有处理的；</p></li><li><p>throw是在方法体内，执行到throw立刻停止，如果方法体内抛异常，则需要在声明里写出throws，之后再调用者处理。</p></li><li><p>所以写了throw就必须要写throws，但是写了throws可以不写throw。</p></li><li><p>一个try可以跟多个catch，对应不同的异常。</p></li><li><p>使用List集合时候通常声明为List类型，然后通过不同的实现类来实例化该集合。</p></li><li><p>Java反射可以在程序中访问已经装载到JVM中的Java对象的描述</p></li><li><p>Methods called from constructors should generally be declared final. 如果子类有重载A，并且A在父类构造函数中被调用，那么会调用子类的重写版函数，但是子类在此时尚未被实例化。所以在构造函数中调用的，需要被定义成final（推荐），是为了子类不会重写，将来调用的时候出现多态。</p></li><li><p>If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass <em>hides</em> the one in the superclass.</p><p>The distinction between hiding a static method and overriding an instance method has important implications:</p><ul><li>The version of the overridden instance method that gets invoked is the one in the subclass.</li><li>The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.</li></ul></li><li><p>Methods called from constructors should generally be declared final.（引入如果调用一个普通函数，然后这个函数在子类中被重写了，那么子类在实例化时，由于多态，在父类中就会调用子类重写的函数，但是此时子类还没有被实例化出来，容易出问题）</p></li><li><p>抽象类和接口：</p><ul><li>抽象类：<ul><li>want to share code among several closely related classes</li><li>expect that classes extending the abstract class have many common methods or fields, or require access modifiers other than public</li><li>want to declare non-static or non-final fields</li></ul></li><li>接口<ul><li>unrelated classes would implement your interface</li><li>want to specify the behavior of a particular data type, but not concerned about who implements its behavior</li><li>multiple inheritance</li></ul></li></ul></li><li><p>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计（C++11 开始（2011 年的时候）,C++就引入了多线程库），而 Java 语言却提供了多线程支持</p></li><li><p>Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便</p></li><li><p>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</p></li><li><p>Java 中，JVM 可以理解的代码就叫做字节码。不面向任何特定的处理器，只面向虚拟机。通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的）</p></li><li><p>.java -》javac编译 - 》.class文件 - 》解释器&amp;JIT - 》机器可以理解的代码。<code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p></li><li><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p></li><li><p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p></li><li><p>静态方法为什么不能调用非静态方法：静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p></li><li><p>可变参数只能作为函数的最后一个参数</p></li><li><p>包装类型可用于泛型，而基本类型不可以。</p></li><li><p>几乎所有对象实例都存在于堆中。</p></li><li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p></li><li><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法（比如intValue，floatValue）。</p></li><li><p>性能差异是来自于这个语言的执行机制，而不是这个语言采用的编程范式。</p></li><li><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p></li><li><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p></li><li><p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p></li><li><p>Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——对象在内存中的地址。值和引用存储在 stack中，而对象存储在 heap中。基本数据类型的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。</p></li><li><p>The terms “pass-by-value” and “pass-by-reference” are talking about <em>variables.</em> Pass-by-value means that the <em>value</em> of a variable is passed to a function&#x2F;method. Pass-by-reference means that a <em>reference</em> to that variable is passed to the function. The latter gives the function a way to change the contents of the variable.</p></li><li><p>By those definitions, Java is always <strong>pass-by-value</strong>. Unfortunately, when we deal with variables holding objects we are really dealing with object-handles called <em>references</em> which are passed-by-value as well. </p></li><li><p>创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p></li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。</p></li><li><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次</p></li><li><p>用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p></li><li><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork&#x2F;Join 框架（JSR166y）来拆分任务和加速处理过程。</p></li></ul><h2 id="Write-and-Read-File"><a href="#Write-and-Read-File" class="headerlink" title="Write and Read File"></a>Write and Read File</h2><ul><li><p>When constructing a reader or writer object, the default character encoding of the operating system is used</p></li><li><pre><code class="java">FileReader reader = new FileReader(&quot;MyFile.txt&quot;);FileWriter writer = new FileWriter(&quot;YourFile.txt&quot;);<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><br>-   <span class="hljs-keyword">if</span> we want <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> a specific charset, <span class="hljs-keyword">use</span> an **InputStreamReader** <span class="hljs-keyword">or</span> **OutputStreamWriter** instead. <br><br>-   ```java<br>    InputStreamReader reader = <span class="hljs-keyword">new</span> InputStreamReader(<br>              <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;MyFile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-16&quot;</span>);<br></code></pre></td></tr></table></figure></code></pre></li><li><p>In case we want to use a <strong>BufferedReader</strong>, just wrap the <strong>InputStreamReader</strong> inside</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">InputStreamReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;MyFile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-16&quot;</span>);<br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>override v.s. overload v.s. overwrite</title>
    <link href="/post/9e1da285.html"/>
    <url>/post/9e1da285.html</url>
    
    <content type="html"><![CDATA[<p>简单讲讲C++与Java中的overload，overwrite，override的概念</p><span id="more"></span><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><code>stackoverflow:</code></p><p>In C++ terminology, you have <em>overriding</em> (relating to virtual methods in a class hierarchy) and <em>overloading</em> (related to a function having the same name but taking different parameters). You also have <em>hiding</em> of names (via explicit declaration of the same name in a nested declarative region or scope).</p><p>The C++ standard does not use the term “overwrite” except in its canonical English form (that is, to replace one value with a new value, as in the assignment <code>x = 10</code> which overwrites the previous value of <code>x</code>).</p><p>也就是说，C++中在函数层面，并没有overwrite的概念。</p><p>overloading，函数重载，更多适应于在面向过程编程时，<code>函数名相同</code>但是<code>参数列表不同</code>的函数。（注：重载的返回值可以不同，因为返回值并不是区分重载函数的条件。之所以不是，是因为并不是每次调用函数都会接收返回值，返回值只是一种状态）。</p><p>override，函数重写，也称为覆盖，适用于在面向对象编程，并且使用到了继承的类结构体系时，子类重写父类方法，此时<code>函数名相同</code>并且<code>参数列表相同</code>。</p><p>overwrite，类似hiding隐藏的概念，针对变量，可以重新赋值，就是隐藏了之前的值；针对文件，也是类似。</p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>与C++基本相同。也有重写与重载的区别。</p><p>重载：由于Java完全面向对象，因此没有面向过程的编程。所以重载，就只是在<code>一个类的内部</code>，<code>函数名一样</code>但是<code>参数列表不同</code>。</p><p>重写：子类重写父类的<code>同名同参数</code>方法，java5以后还支持重写返回值（返回值可以不同）。如果返回值也一样，这种特殊的重写称为重构。</p><p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://stackoverflow.com/questions/4738315/c-overriding-overwriting">https://stackoverflow.com/questions/4738315/c-overriding-overwriting</a></p><p><a href="https://www.runoob.com/java/java-override-overload.html">https://www.runoob.com/java/java-override-overload.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>C++</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观后感-女佣浮生录</title>
    <link href="/post/f0069d9c.html"/>
    <url>/post/f0069d9c.html</url>
    
    <content type="html"><![CDATA[<p><strong>Each kind of situation has its own solution.</strong> </p><p><strong>You would never lose hope as long as you insist.</strong></p><span id="more"></span><p>Inspired by <a href="https://en.wikipedia.org/wiki/Stephanie_Land">Stephanie Land</a>‘s memoir <em>Maid: Hard Work, Low Pay, and a Mother’s Will to Survive.</em>  It just shocked me.</p><p>What A Helpless Situation!</p><p>A single mother —-</p><p>She has a alcoholic husband, a mother with mental problems, a three year old daughter and a abusive boyfriend.</p><p>Her life is just like a mess.</p><p>What makes me sad the most is that she could have gone to college and she had won a scholarship.</p><p>But just because of a man and an unexpected baby, she gave up that opportunity.</p><p>  In my initial and traditional perspective, a girl is a child or a princess spoiled by her parents, at least before she enters the society and start working. But in the play, the woman could be considered to be shamed and failed. People would be shamed by her behavior and tell their children not to be like her.</p><p>​And this woman and this TV series totally changed my pervious thoughts. You can always make  it through as long as there is hope in your mind and there are some kind people who are willing to help you.</p><p>​She accepted help from lots of people. That’s coincidence, but also for her character, she is diligent, sticks to her principles even live in other’s home, she keep in mind that she is accepting other’s help or charity. Her love for daughter impressed many persons. </p><p>​At the beginning I think she could been had a better life, go to the college, hang out with her friends, meet a romantic love, find a decent job. She could do so many things that belongs to youth. Just due to the man and a baby, her life is ruined. But when she said: “Daughter is my life. “ I suddenly understood that she is happy and passionate for life just because of her daughter which is her whole world. I also understood mother’s power which should be respected by everyone.</p><p>​When she got the scholarship again, she felt hope for the future. But her ex-boyfriend returned her car to another man and that means she can’t go to work, she can’t make money, so she also can’t go to college. Suddenly she lost all her hope and fell into despair. I was  very worried for her at that time. And eventually, she resumed her spirit and made it through again due to her cute daughter, she took her daughter away, away that house full of alcohol and violence. She took her daughter run out of the cage which is in her mind. She showed me how powerful she is again, not only as a woman, but also as a mother.</p><p>​In the end, when she drove to Montana with her daughter, drove to her future full of hope,   that plot hit my heart.</p><p>​She said: “I’m going to drive the fuck out of the town, I’m going to drive nine hours, 566 miles to Missoula, Montana, where I’m going to spend the next four years, learning to be a writer. Hopefully, there will be a lot of happy days during that time. And I know there will be hard ones. Most people would bet against a single mom putting herself through college. But they don’t know what it took to get here. Three hundred and thirty-eight toilets cleaned, seven types of government assistance, nine separate moves, one night on the ferry-station floor, and the entire third year of my daughter’s life. But, when we got to Missoula, I’m going to take Maddy(her daughter) up Sentinel Mountain, which looks over the town, and show her new home. I’ve been telling her all about the giant ‘M’ that’s at the tippy-top of the mountain. That the trail up there is long and zig-zaggy. The hike will be hard. But we’ll make it to the top. And when we do, I’m going to tell her that the <em>‘M’ stands for ‘Maddy’.</em> That this is whole new world for her “</p><p>end</p>]]></content>
    
    
    <categories>
      
      <category>观影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>女性</tag>
      
      <tag>观后感</tag>
      
      <tag>电视剧</tag>
      
      <tag>美剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NieR-Automata通关感言</title>
    <link href="/post/b988b94d.html"/>
    <url>/post/b988b94d.html</url>
    
    <content type="html"><![CDATA[<p>尼尔一场大梦，人生几度秋凉</p><span id="more"></span><p>没想到最后还是哭了</p><p>注：涉及剧透内容（包括结局），请酌情观看</p><h2 id="一段人生，一次经历"><a href="#一段人生，一次经历" class="headerlink" title="一段人生，一次经历"></a>一段人生，一次经历</h2><p>尼尔里面有什么</p><p>有机械，有人类</p><p>有战斗，有音乐</p><p>有喜悦，有痛苦</p><p>有虚拟，有现实</p><p>有游戏，有人生</p><h2 id="从头到尾的虚拟"><a href="#从头到尾的虚拟" class="headerlink" title="从头到尾的虚拟"></a>从头到尾的虚拟</h2><p>一切的一切都是假的</p><p>甚至包括你的名字</p><p>只是为了服务于某个更高阶层</p><p>服务于更为宏大的目标</p><p>服务于从头到尾都是虚假的人类荣耀永存</p><p>战斗员戴着眼罩</p><p>通讯官戴着口罩</p><p><strong>行凶者不知真相，知真相者口不能言</strong></p><p><strong>没有谁能够毫无理由就去战斗，我们需要能够为之奉献的神</strong></p><p>——尼尔-机械纪元</p><h2 id="机械的感情"><a href="#机械的感情" class="headerlink" title="机械的感情"></a>机械的感情</h2><p>为了毫不留情地将所有的机械消灭，只能不断灌输机械没有感情，寄叶部队也相信着它。</p><p>然而无休止唱歌的歌姬</p><p>亚当与夏娃</p><p>帕斯卡的村庄</p><p>因恐惧自杀的孩童</p><p>抵抗军的军营</p><p>森林里的王</p><p>迪瓦拉和波波拉</p><p>甚至包括2B，9S，A2他们自身</p><p>以及辅助机</p><p>都在演绎着人类的情感</p><p>开心难过痛苦绝望</p><p>分离的不舍，重聚的欢欣</p><p>全作无一个人类</p><p>却处处是人类</p><p>自以为能够拯救世界，可到头来终究是一场空</p><p>数据被删除后，往事皆随风，又是一次轮回的开始</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>不知道最后的E结局是不是封神之作</p><p>但确确实实感动到了我</p><p>最终打所有制作人员的操作别出心裁，或许是想让玩家泄愤</p><p>然而打是打不过的</p><p>每一次死亡，都会被问道：</p><p><strong>“你承认自己已经战败了吗”</strong></p><p><strong>“这一切都是白费力气吗”</strong></p><p><strong>“你认为区区游戏实在很愚蠢吗”</strong></p><p><strong>“你承认这个世界没有意义吗”</strong></p><p><strong>“要在此放弃吗”</strong></p><p><strong>“要接受救援吗”</strong></p><p>看来我一共死了六次，第六次来了救援</p><p> <img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163559073.png" alt="image-20230723163559073"></p><p>然后弹药突然变多</p><p>但是每死一个，都会提示xx的数据丢失了</p><p>总之火力猛了果然还是过了</p><p> <img src="https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdbfcebc7-62a1-4de7-956e-9e7caf1e66d2%2FUntitled.jpeg?table=block&id=a029abb2-314a-4863-868b-6e4e1b192a9c"></p><p>这时候辅助机发问：”你有什么话要说”</p><p>看到这个格式，我才明白</p><p>之前的每一条留言</p><p>都是一位玩家贡献出来的</p><p>之后辅助机开始问我问题：</p><ul><li><p>你打不打算拯救弱者？</p></li><li><p>只要选择这个选项，你就能拯救世界上的某人，代价是失去所有的保存资料，<strong>即便如此。你仍愿意拯救某个素不相识的人吗</strong>？</p></li></ul><p>（看到这里我才知道原来之前的每个帮助我的人都放弃了自己几十个小时的游戏存档）</p><ul><li><p>拯救的对象随机选择，所以，向你求救的对象，可能是你讨厌的人，<strong>即使如此，你仍愿意拯救他人吗</strong>？</p></li><li><p>你拼命才解锁的选择章节功能（我甚至还没有体验过），也会无法使用，<strong>即使如此，你仍愿意拯救他人吗</strong>？</p></li><li><p>即使你拯救他人，或许也不会被感谢，你的行为可能会被视为伪善，<strong>即使如此，你仍愿意拯救他人吗</strong>？</p></li><li><p>真的，真的要继续吗</p></li><li><p>以所有数据当作代价</p></li></ul><p><strong>我会把你的意思告诉这个世界</strong></p><p>就在问这些问题的时候</p><p><img src="https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4c9c919c-2512-4f19-9610-57cc29be1868%2F20220810151300_1.jpg?table=block&id=c903fa57-9803-4f21-bddb-3a3cd8a460da"></p><h2 id="活着的意义"><a href="#活着的意义" class="headerlink" title="活着的意义"></a>活着的意义</h2><p>开始的一段话结尾：</p><blockquote><p>  他们被设计成能毁灭一切的存在</p><p>  在生与死的螺旋中</p><p>  他们一直被囚禁着</p><p>  但是</p><p>  在那些轮回中的挣扎</p><p>  便是活着的意义</p></blockquote><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723164044096.png" alt="image-20230723164042426"></p><p>三位主人公的名字：</p><ul><li><p><code>A2</code></p></li><li><p><code>2B</code></p></li><li><p><code>9s</code></p></li></ul><p><code>All(A2) is gonna to be(2B) nice(9S)</code></p>]]></content>
    
    
    <categories>
      
      <category>Game</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Game</tag>
      
      <tag>RPG</tag>
      
      <tag>3A</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>资本论系列视频笔记</title>
    <link href="/post/84e29d5d.html"/>
    <url>/post/84e29d5d.html</url>
    
    <content type="html"><![CDATA[<p>资本论不是经济学，其副标题是政治经济学批判</p><p>构建框架，构建范畴，将社会现实放在这样的一个理性系统中，这就是社会科学（政治学，经济学，法学，社会学）。两个特点：</p><ol><li>实证的，认为自己是理性的</li><li>将社会现实放入到逻辑框架中</li></ol><p>（当一个人只有锤子的时候，他看什么东西都像是钉子）</p><p><strong>物理事实 + 范畴 &#x3D; 社会事实</strong></p><p>社会事实不是直接给予我们的，事实是被范畴所建构的，只能看到物理世界物理事件</p><p>比如警匪事件就是政治概念，二者都属于暴力事件，但是匪是私人非法暴力，警是公共合法暴力。</p><h2 id="资本雇佣劳动"><a href="#资本雇佣劳动" class="headerlink" title="资本雇佣劳动"></a>资本雇佣劳动</h2><p>经济事实：<strong>资本雇佣劳动</strong></p><p>其中隐藏的三个经济范畴：资本——工资——商品</p><p>劳动是作为商品——因为被购买，购买也就是雇佣的意思</p><p>前资本主义的师徒关系只是半人身依附关系，没有市场行为，也就没有工资的范畴。</p><p>这句话意思：资本的范畴拿出一部分（称为工资），工资用来雇佣（工资里隐藏着雇佣的范畴）作为商品范畴的劳动</p><p>在其中发生了等价交换，隐含价值这个范畴</p><p>资本主义生产关系被认为是人类迄今为止找到的最合理的生产关系，他没有政治强制，等级压迫。而是独立的个人在市场上实现等价交换</p><p>如果把资本雇佣劳动中的三个范畴都去掉，即去掉资本，去掉工资，去掉商品这三个范畴，经济事实是没了，但是事情还在发生。因为如果没有资本，也就是没有过去积累起来的劳动。</p><p>若我没钱，只有活劳动这种能力，为了保证自己的物质需求，那我必须去找那些拥有过去积累起来的劳动的人。（包括生产资料土地设施机器）</p><p>人类积累起来的劳动有两种，一种是直接消费品，一种是生产消费品，后者可以用来生产新的消费品，也就是创造新的价值。</p><p>当今人类生产的目的是价值的增殖。谁有生产资料，谁就可以拥有一种力量，使得没有生产资料的人的生命一部分时间由这些人所支配。</p><p>把范畴去掉后，该经济事实变为事情本身，即<strong>生产资料行使对活劳动的支配权。</strong></p><p>马克思的哲学革命就是在去除原本事实中的那些范畴，即现象学还原。</p><p>范畴之间有逻辑关系，因此是理性的。理性的基础是价值，等价交换。以统一的尺度交换，这个尺度是货币。</p><p><strong>价值增殖的竞争是积累起了的劳动对活劳动的支配权的竞争。</strong></p><h2 id="社会权力"><a href="#社会权力" class="headerlink" title="社会权力"></a>社会权力</h2><p>社会权力：<strong>social power</strong>。</p><p>对资本作理性的研究叫做经济学，但是如果发现资本实际上是一种权力，是支配别人的力量，就发现资本是当代社会权力。</p><p>赚钱的目标：脱贫、安全、权力（代表支配别人和被别人支配），即使财务自由了，但离着权力还远，就会还以为自己很穷。</p><p>还原后，一个合乎理性的事实变成了非理性的人与人的关系，power</p><p>今天的国家机器如此强大是为了什么？20世纪基本完成国家独立，民族解放，为什么还要拥有如此多威力空前的杀人武器？按照国际理性法则做生意、外交，一切都已经正常了，为什么还要建立？</p><p>根源不是我们比以往更饥饿了，根源在于社会权力。经济学家把资本的竞争描述为一个理性的活动。马克思告诉我们这是斗争，是非理性的，是一部分人统治另一部分人的活动。</p><p>王国维：世界上的学问只有两种，一种可爱而不可信，一种可信而不可爱。经济学理论是可爱的，马克思学说是可信而不可爱。</p><p>我们不喜欢斗争，我们要人道主义精神。</p><p>比尔盖茨说：<strong>人类在科学技术方面所取得的所有成就都不足以让人们 自豪，人类在经济建设方面所取得的所有成就都不足以让人们自豪，人们只有在减轻或者消除人类不平等境遇方面所取得的所有成就才足以让人们自豪。</strong> 但今天我们一直在倒退，今天的市场经济是穷人为富人打工的经济，你口袋里的钱越多，整个市场为你服务的动力就越大，你口袋的钱越少，市场为你服务的动力就越小直至降低为零。当我们在歌颂当今市场经济的繁荣的时候，我们不要忘记地球上有十亿人口其每天的消费水平不足一美元。（当然现在中国人民已经不在其中了，因为我们实现全面小康了）</p><p>比尔盖茨没说社会权力，而是说的不平等，这不是政治的不平等，我们都有投票权，你也可以主动离开老板。</p><p>比尔盖茨想让市场为穷人服务，将企业的资本分为有形的与无形的。无形的就是社会声誉，他举例联合国向全球医疗企业招标，能不能以成本价向非洲投放疫苗，奖励是给予新药市场份额。这里说明他不懂马克思。</p><p><strong>资本增殖的本身必然创造了一部分的相对贫困，造成社会分裂，之后再去消弭贫困，否则剩余价值无从谈起。</strong> 如果比尔盖茨一开始就是慈善家，他不可能成为世界首富。比尔盖茨觉得他没有创造相对贫困，他不应该为此负责，资本的本性如此。</p><p>现代贫困不是等级压迫的结果，<strong>价值范畴的等价交换掩盖了贫困的不断被制造</strong>。</p><p>法国的黄马甲运动，表面是燃油，但其实是通货膨胀导致相对贫困。</p><p>英国脱欧是民众投票的，英国是靠的金融，那么为什么脱欧呢？最终脱欧说明在加入欧盟以及全球化过程中，获利的全都是英国的大资产阶级获利。一个金融，一个贸易。</p><p>由此根据马克思的学说，逆全球化才是主导趋势。</p><p>资本竞争，上升Social power上升到国际层面，国与国之间会穷兵黩武，国内则是社会分裂，或政党之间的斗争</p><p>马克思说资本主义的每一次成功发展，必然伴随着社会权力的扩大，权力就是冲突、对抗，是非理性的。</p><p>资本capital分为财富wealth和权力power，财富不以土地和牲畜的多少计算，这是使用价值多，资本增殖了才叫财富。研究资本的运动，也就是研究社会权力的变动。财富增加，权力必然同步扩大，导致社会矛盾。</p><p>政治权力是国家机器，军队警察监狱，这是用于维护社会权力的。</p><p>一个弱小的人如果有很多钱，首先他不会担心别人抢，因为有政治权力即国家机器保护社会权力；其次一大堆人会不断游说他让他投资，即求着他雇佣，求着他支配自己的一部分生命时间。这个过程，钱没说话，所以社会权力不是观念，不是idea，但我们说的话一直在承认它的力量。</p><p>但是观念必然会来，观念把这个真实的感性的力量表达为right权利，法的范畴就上去了</p><p>power——权力</p><p>right——权利</p><p>非理性的权力变成了理性的权利</p><p>无论政策如果变，我手里有social power，最后谁听谁的？</p><p>社会权力不能直接等同于政治权力。</p><p>所以改革是不可避免的，国营企业拥有资本同时是政治权力，需要把政治拿掉，还原为社会权力才行。当时有投资饥饿症，也就是投资后利润达不到，但是不能倒闭，所以继续投资。</p><p>所以我们改革，承认社会权力，承认体制外的经济活动，不承认的时候叫投机倒把，现在变成了搞活经济。这是意识形态的改变，观念的改变。</p><p><strong>Power + ideology(意识形态) ——&gt; Right</strong></p><p>政治权力承认了社会权力，将其表达为私有财产的权利，上升到了法的概念（2006年物权法）。</p><p><strong>扩大开放：承认国外的social power</strong></p><p><strong>深化改革：清洗掉国内在social power上的政治维度</strong></p><p>不是Right让你拥有了支配别人的力量，而是social power</p><p>所以改革开放并不是观念的改变，不是思想解放的结果，这是历史唯心主义。而是在计划经济晚期，产生了异质的要素，这是不能容纳在计划经济内的。产生的原因则是因为有货币。只要有货币，有商品交换，价值规律就一直在起作用。因此社会主义计划经济体制本身包含着与自身相异的要素。</p><p>以苏联为首的社会主义国家的行为难道叫做社会主义吗？不是，价值规律一直在起作用。</p><p>当时实际上是没有资本家的资本社会</p><p>这种异质的东西一定会突破计划经济，这是不可避免的。所以新的社会权利一定会在原本的计划经济中成熟起来，然后意识形态要表达它，上层建筑（法的体系和国家制度）都要表达它。power决定了right，就是经济基础决定上层建筑（思想上的意识形态与政治上的国家制度和权力机器）</p><h2 id="劳动抽象化"><a href="#劳动抽象化" class="headerlink" title="劳动抽象化"></a>劳动抽象化</h2><p>范畴本身，是怎么来的比如价值这个经济范畴怎么来的？</p><p>价值这个范畴我们觉得很容易理解，只要商品交换存在那么人类的产品呢它就有两个维度：一个叫使用价值，比如说这块手表使用价值用来看时间，这块手表价值200块，是他的价值。劳动产品成为商品，那么就意味着有一个价值范畴</p><p>200块的手表和值200块的皮鞋可以等价交换，本来生产手表的劳动跟生产皮鞋的劳动是完全不同的劳动，是完全不同的使用价值。他们之前是无法通约的。作为商品交换，必须通约，满足等价交换的原则。</p><p>这时需要把劳动抽象化，即一定时间内人类时间与体力的支出。<strong>劳动也有二重性，使用价值是具体劳动创造的，价值是抽象劳动创造的，虽然在现实中这是一种劳动。</strong></p><h2 id="生产目的改变"><a href="#生产目的改变" class="headerlink" title="生产目的改变"></a>生产目的改变</h2><p>商品交换在资本主义之前就有了，</p><p><strong>W - G - W</strong>，这时货币只有媒介的作用，只是流通手段。但对于投资来说，则是<strong>G - W - G’<strong>。前者生产目的是获得我不能生产的产品，后者的生产目的是货币增殖，</strong>G’ &gt; G</strong>，差值就是剩余价值。这意味着原来仅仅是流通手段的<strong>货币，变成了财富的主体</strong>。</p><p>中国古代也有商品流通，但商人积攒货币后，是置办田产，有了田地才是真正有了财富，这是中国古代。但是欧洲不一样，因为<strong>欧洲贵族对土地的占有制是世袭的</strong>。所谓封建，就是封土建国，所以欧洲和中国古代封建不一样。中国阶层是可以流动的，一个是科举，一个是财富。所以中国古代内部不能发展出资本主义，中国古代的人们不可能把生产的目的变为剩余价值，我们追求的是使用价值。</p><p>欧洲商人的货币无法转换为土地，资产阶级的法语意为城关市民。商人就是在领地之中从事贸易，如果受到贵族武装侵袭，就需要武装保护。</p><p>欧洲资产阶级成长的三个阶段，第一个是将自己武装起来与贵族武装进行战斗，但是经常失败；到了第二阶段：建立资本所需要的政治制度，即各种革命；第三阶段是与无产阶级斗争</p><p>商人的目的是<strong>赢得动产的自由，即动产能够战胜不动产的历史权威，让货币战胜土地。</strong> 前提是贵族要垮台，而当时欧洲贵族喜好东方瓷器绸缎，于是商人扩大海外贸易，让贵族的钱到商人中。没钱了，也就没钱支付仆人、土地上的半农奴。这批人奔向城市，但行会手工业完全是闭源的，这批人<strong>自由了，但自由的一无所有</strong>。而此时，商人等着他们呢——工厂手工业。商人一开始不在生产领域，而是在流通领域，但时间长了，商人肯定更了解市场的需要，商人想要手工业服从于市场，但是行会手工业不服从市场，而是一定区域的老主顾，这种手工业没有扩大生产的需要。</p><p>等到大量劳动力进入到城市中，商人又在等着他们，一种新的商品出现了——劳动力。商人投入资金，雇佣劳动力，生产商品，进入市场，获得资金，继续雇佣劳动力扩大生产。<strong>生产目的改变了——追求剩余价值。</strong></p><p>但是资本的生命本性就是增殖，按其本性，要求他一定要突破欧洲有限市场，走向世界的市场。商人与劳动力结合，与贵族对抗，贵族要么卖爵位，要么卖地，要么转变为资本家（新贵族）</p><p>由此土地世袭占有权改变。土地被纳入到资本中，产生了圈地运动，羊吃人。</p><p>要现代化必须先工业化，工业化的前提是什么？剥夺农民的土地所有权。工人生产不能吃不能穿的东西，但是工人自己要吃要穿，谁来提供？农民。如何理解计划经济，<strong>一个后发的现代化国家，如何快速工业化，实质是剥夺农民的土地所有权，通过差价交换农业与工业产品。</strong> 比欧洲温和，但是就是穷。不剥削农民，不可能短时间实现工业化。</p><p>资本开创了世界史。</p><p>欧洲的王室是支持商人的，因为王室最大的敌人是贵族。</p><p>东印度公司是英国最著名的</p><p>国富论的原则：让政治从市场中退出</p><p>政治经济学经历的阶段：重商主义到重农主义，再到一门科学，标志就是劳动价值理论，这让经济学称为一门科学，获得了研究对象。</p><h2 id="劳动价值论"><a href="#劳动价值论" class="headerlink" title="劳动价值论"></a><strong>劳动价值论</strong></h2><p>劳动：一般劳动：凡是能使货币增殖的活动都是劳动，所以理发师的劳动也是劳动，创造的是商品价值。</p><p>价值：商品的交换价值（不是使用价值）</p><p>这样完成了一件事：把具体劳动的感性特征抽象掉，只说社会必要劳动时间的量，这个量的体现就是货币。货币因此也成为财富主体，而不是一般等价物。</p><p>不同的劳动能够被等量齐观</p><p>货币增殖：劳动的量增加，这个劳动量增加是在生产领域增加，不可能在流通领域。</p><p>具体劳动受抽象劳动支配，如果具体劳动不能给资本带来增殖，那他就不算劳动。所以研究哲学不算是劳动。</p><p>经济学取代了记账学，一个家庭内一定要计算一月内的收入与支出情况，即直接计算使用价值，并设法保住这个使用价值。</p><p>但今天不能丢掉记账，经济学，是通过市场，让通过劳动创造的剩余劳动卖成剩余价值，货币增殖，获得在市场上的购买力。万一市场断了呢？</p><p>发达资本主义国家也要考虑这些使用价值。一旦危机要保持必要的粮食储备。</p><p>如果整个社会的电网都崩溃了，蜡烛就重要了。人还是要站在大地上的。年轻的钱不能花完，必须储蓄。假如货币没有脱离金本位，钱始终是那些钱，购买力始终是可靠的。</p><p>资本主义发展到现在完全脱离大地，稍微有点钱的老人是最惨的，整天担惊受怕自己的财富缩水。</p><p><strong>资本的本质：抽象劳动统治具体劳动，交换价值的增殖支配使用价值的生产。</strong></p><p>这是近代以来的唯心主义</p><p>但财富作为使用价值的数量来计算这件事是不能被遗忘的</p><p>金融危机会在几个月内将十年经济发展毁于一旦，90年代金融危机，韩国老百姓将黄金上交国家，短时间内恢复韩币的金本位制，稳住韩币</p><p>因此<strong>金银不是天然的货币，但货币天然是金银</strong>。</p><p>金银只是矿产，<strong>货币是一般等价物，是流通的，但如果要把财富用货币来表示，应该在自然界寻找一种储备有限，质地均匀，便于分割携带的东西。——只能是金银</strong></p><p>G - W - G’</p><h2 id="资本与技术是孪生兄弟"><a href="#资本与技术是孪生兄弟" class="headerlink" title="资本与技术是孪生兄弟"></a>资本与技术是孪生兄弟</h2><p>G是生产资料的价值和劳动力（工资），开始劳动过程，即劳动时间，产生新产品，如果原材料的价值完全转移到了新产品上，产生的多出来的价值完全等于工资，那么资本家变成了义务劳动。</p><p>马克思用<strong>剥削这个词没有任何道德贬义</strong>。以往的农奴劳动是等级强制，现在的剥削是正义的。</p><p><strong>资本家是资本的人格化，经营企业的行为是服从资本的逻辑的，与其道德品质无关。</strong></p><p>资本家没有奴役任何人，只是<strong>按照资本的法则，必须要将劳动分为必要劳动和剩余劳动。</strong></p><p>市场是一个竞争的舞台，产品要么便宜，要么质量好。这迫使资本家降低成本，第一种方法是延长工时，但无法无限延长，因为要吃饭睡觉，12小时最多了，第二种是减少必要劳动的时间，即提高生产效率，第一种是劳动者更熟练，第二种是新技术。</p><p>围绕相对剩余价值，展开了技术比拼。</p><p>中国是第一制造业大国，因为量大，不是质量。这是中低端制造业，高端是技术。<strong>高端能够获得品牌的地位，有品牌就有市场。</strong></p><p>相对剩余价值的开发，只能依赖新技术的研发，这能够带来两个好处，第一个是提高产品质量与效率，第二个是创造新的使用价值（iPad这种新产品就是新的使用价值）</p><p>美国特别强调产权，是因为其实体制造业很少了，但三亿人口的老百姓并不都在硅谷，实体制造业衰落造成大量的失业人员。所以特朗普号召制造业回归本土。</p><p><strong>资本主义的生产一定带来技术的进步</strong>，在此之前人们没有技术，只有技艺。<strong>技术将自然抽象化看作资料material的世界，技艺则是追求天人合一</strong>。把劳动抽象化必然也会把自然界抽象化。资本与技术是孪生兄弟，中国的土壤既无法产生资本主义，也无法产生对自然界的技术的态度。</p><p>马克思的<strong>生产力决定生产关系</strong>：不是说生产工具的进步带来新的生产关系。从行会手工业到工厂手工业，生产工具没变，生产关系变了，行会中是师徒，工厂中是资本主义生产关系，要求相对剩余价值。这种资本主义生产关系产生后，机器在逻辑上被发明了，经验上还没诞生。</p><p>如果没有资本主义的生产关系，瓦特发明的蒸汽机只是一个宫廷里的玩具</p><p>所以鲁迅说，中国的四大发明不是生产力</p><p>所以资本与技术是孪生兄弟</p><p><strong>没有技术，资本无法竞争，没有资本，技术无法被要求</strong></p><p>资本在根本上改变了人们的生活方式，这个改变的指向就是效率——时间就是金钱，效率就是生命</p><p>技术运用到农业生产，改变靠天吃饭；运用到医疗，延长生命；运用到电声转换，将古典音乐收入到口袋中。这是积极的方面，不能被否认也无法被忽视。</p><p>核能是不能运用的，因为人是会犯错误的动物。<strong>新能源的运用是要靠旧能源</strong>，资本主义不断要求效率，效率就不断要求高效的能源</p><h2 id="资本主义内在界限："><a href="#资本主义内在界限：" class="headerlink" title="资本主义内在界限："></a><strong>资本主义内在界限</strong>：</h2><p>资本主义生产方式没有外在界限，它要求突破一切民族、疆域、文化</p><p>但它有内在界限，即<strong>资本主义的每一次发展，都会同时产生限制自己的力量</strong></p><ol><li><p><strong>必要劳动是活劳动的交换价值的界限</strong>（必要劳动是等于工资的那部分劳动，所以剩余劳动是必须的。劳动力是商品，也就有交换价值）：技术运用后，必要劳动比例减少，但劳动者的工资不会变多。如果必要劳动的比例进一步减少，就会发生裁员。产品需要卖给大比例的人口即劳动者，但劳动者购买力没有提高。资本家的矛盾心理：员工在企业内部工资一直不变，但当员工一出企业，又希望他们有旺盛的购买力。这是资本主义无法克服的悖论西方国家通过二次分配——社会福利解决，这与资本主义无关，让劳动者敢于花钱，能保证最基本的保障。</p></li><li><p><strong>剩余价值是剩余劳动和生产力发展的界限</strong>：剩余劳动是一直都有的，它是过去积累起来的劳动物化为使用价值。到了资本主义时，剩余劳动不能停留在实物形态，它必须要在市场中转换为剩余价值，实现货币的增殖。否则就破产。所以出现倒牛奶。因此<strong>过剩的绝不是剩余劳动</strong>，<strong>过剩的是这部分剩余劳动无法在市场竞争中实现剩余价值。</strong> 唯一的做法就是毁掉，重启市场需求。要么自然灾害，要么发动战争。资本主义一方面极大促进了生产，积累剩余劳动，但又在随时准备破坏这些积累起来的劳动。 相对过剩发生，产业链资金链都受影响，容易连锁反应发生经济危机。日本侵略也是在这个背景下，发展新市场，瓜分殖民地。而美国当时则是选择另一种方法，突破资本主义的第三个界限（见下）</p></li><li><p><strong>货币是生产的界限</strong>： 生产目标是货币增殖，资本主义投入开始就是货币，整个过程都以货币作为媒介。产业链从上游一直到下游末端直接面对消费者，如果钱回不去，资金链就断了，只能印钞票。这样货币天然是金银的原则就被破坏了，因为你没法印金子。美国罗斯福国家干预经济，超发货币，低息贷款，启动资本主义生产第一个阶段。让货币与黄金脱钩。救济企业，应对就业危机，工人就业有了钱，又回去消费，将剩余劳动转化为剩余价值，解决过剩危机。内部危机只有两个手段：超发货币与国家投资。最终走入资本主义最终形态，金融资本主义。金融4个方面，银行，证券，保险，基金。</p><p>马克思谈金融：生息资本：金融是资本市场，资本市场是资本成为商品进行买卖。资本作为商品，即资本产生利润的能力被买卖了，产生的利润是资本作为商品的使用价值，产生利润的能力是资本作为商品的价值。这个产生利润能力的价值如何确认？资本之所以表现为商品，是因为利润被分割为利息和本来意义上的利润，是由供求，从而由竞争来调节的。供求平衡，价格与价值相等，工资就是一种价格，因为工资是波动的。资本作为商品被买卖时，便有价格，价格就是利息；而使用价值就是生产利润的能力，那这个能力有没有价值中心线，也就是说有没有价值？资本生利能力的价值是多少？这里的竞争不是对价值规律的偏离，而是除了由竞争强加的分割规律之外，不存在别的分割规律，并不存在自然利息率，利率没有自然界限。所以这个商品，只有价格，没有价值。金融危机的可怕之处也在于此，它没有价值中心线。所以资本只是表现为商品而不是商品。为什么不具有自然属性，一是使用价值无法确定，只能用最近的过去作为不远的将来的近似，二是供求关系也就是货币供应量不确定。</p></li></ol><p>生产是以货币作为价值和财富，货币贬值后经济就垮了。但中国人厉害的一点在于，如果生产和消费的一系列过程垮掉，那么可以直接让生产和消费在地摊上见面。资本不行了，就走合作化的道路。</p><ol start="4"><li><strong>使用价值的生产受交换价值的限制</strong>。如果某种生产价值带不来剩余价值，那么这种使用价值将不被生产。但他可以改头换面，带来新的剩余价值。</li></ol><p>这是资本主义自己发展的同时，也在积累否定自己的力量。</p><p>其带来的文明的果实不会消失，但不能用产生的方式来保存这种果实。</p><p>马上得天下，但是治天下要下马</p><p><strong>资本主义的消亡不是从外部被否定的，而是从内部。</strong></p><p>中国以自己特色的方式取得了巨大的经济成就，但过去几十年获得的方式不是保存的方式。三十年为一世，而道更。1919的反帝反封建，到49年新中国成立，再到79年的改革开放，如今赢得总量第二，一个靠资本，一个靠技术，缺的是这两个，多的是廉价劳动力与自然资源。</p><p>资本主义还有一段路要走，我们要用自己的路走。</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人文情怀</tag>
      
      <tag>资本论</tag>
      
      <tag>王德峰</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划之爬楼梯</title>
    <link href="/post/29a0832b.html"/>
    <url>/post/29a0832b.html</url>
    
    <content type="html"><![CDATA[<p>爬楼梯的三种题型</p><span id="more"></span><!-- more --><!-- more --><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">question1：<br>假设你正在爬楼梯。需要<span class="hljs-built_in">n</span>阶才能到达楼顶。<br>每次可以爬<span class="hljs-number">1</span>或<span class="hljs-number">2</span>个台阶。有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure><p>当我们站在第n层台阶时，只能是由n-1阶或者n-2阶跳上去的。因此我们需要保存到达n-1和n-2级台阶的方法数。不妨设置大小为n+1的数组dp（dynamic programming），其中dp[i]代表到达第i级台阶的方法数。由上可知，有dp[i]&#x3D;dp[i-1]+dp[i-2]，不难看出此数组即位斐波那契数列。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)&#123;<br>        std::cout &lt;&lt; n;<span class="hljs-comment">// 直接判断</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">51</span>] = &#123;&#125;; <span class="hljs-comment">// 假设最多50级台阶</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>    &#125;<br>    std::cout &lt;&lt; dp[n] &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于对于每一个台阶，只需要保存前一级台阶和前两级台阶，因此只需要两个变量的空间即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution2</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)&#123;<br>        std::cout &lt;&lt; n;<span class="hljs-comment">// 直接判断</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> prePre = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        result = pre + prePre;<br>        prePre = pre;<br>        pre = result;<br>    &#125;<br><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="提高"><a href="#提高" class="headerlink" title="提高"></a>提高</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">questio<span class="hljs-symbol">n2</span>：<br>爬楼梯。<br>每次可以爬<span class="hljs-number">1</span>或<span class="hljs-number">2</span>个台阶，并且不能连续跳两次二级台阶，有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure><p>由于对两阶的连续性作出了限制，因此我们除了保存<strong>跳跃之前在哪一级台阶</strong>之外，还需要保存前一次是否跳了两阶。此时不妨设一个二维数组，对于<code>dp[i][j]</code>而言，其中i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**。最终到第n级台阶的总数就是<code>dp[n][0]+dp[n][1]</code>。对于第i级台阶来说，满足以下关系：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[0]</span>=dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[0]</span>+dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[1]</span>;<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[1]</span>=dp<span class="hljs-comment">[i-2]</span><span class="hljs-comment">[1]</span>;<br></code></pre></td></tr></table></figure><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solution3</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        std::cout &lt;&lt; n;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">51</span>][<span class="hljs-number">2</span>] = &#123;&#125;; <span class="hljs-comment">//i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，dp[i][j]就代表连续j次跳了两级台阶后到达第i级台阶的方法数，j只能是0或1</span><br>    <span class="hljs-comment">//所以最后返回dp[n][0]+dp[n][1]</span><br>    <span class="hljs-comment">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><br>    dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有2种情况，分别是0次两级，1次两级</span><br>        dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是之前跳了一级然后到的前两级</span><br><br>    &#125;<br><br>    std::cout &lt;&lt; dp[n][<span class="hljs-number">0</span>] + dp[n][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拓展一"><a href="#拓展一" class="headerlink" title="拓展一"></a>拓展一</h2><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">questio<span class="hljs-symbol">n3</span>：<br>爬楼梯。<br>每次可以爬<span class="hljs-number">1</span>或<span class="hljs-number">2</span>个台阶，并且不能连续三次跳两级台阶，有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure><p>与第二种情况类似，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**，j只能是0，1，或者2。从<code>dp[i][j]</code>开始，可以有两种情况，一种是跳了一级到i+1级，且跳两级台阶的次数为0，即<code>dp[i+1][0]</code>,另一种跳了两级，到i+2级台阶，跳两级台阶的次数为j+1，即<code>dp[i+2][j+1]</code> 。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sln</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        std::cout &lt;&lt; n;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">51</span>][<span class="hljs-number">3</span>] = &#123;&#125;; <span class="hljs-comment">//二维数组dp的第二维 0 1 2表示的是: dp[i][j] 在第i级台阶，之前是有连续j次走了二级台阶的方法数</span><br>    <span class="hljs-comment">//所以到达第n阶的总方法数就是dp[n][0]+dp[n][1]+dp[n][2]</span><br>    <span class="hljs-comment">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]。</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br>    dp[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有3种情况，分别是0次两级，1次两级，2次两级</span><br>        dp[i][<span class="hljs-number">1</span>] = dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">0</span>];<span class="hljs-comment">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 为保证最近仅一次跳了两级，唯一情况是跳了一级然后到的前两级</span><br>        dp[i][<span class="hljs-number">2</span>] = dp[i - <span class="hljs-number">2</span>][<span class="hljs-number">1</span>];<span class="hljs-comment">// 到了第i级台阶，并且之前两次都是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是跳了两级然后到的前两级</span><br>    &#125;<br><br>    std::cout &lt;&lt; dp[n][<span class="hljs-number">0</span>] + dp[n][<span class="hljs-number">1</span>] + dp[n][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后两种情况也同样可以 用变量代替数组，但是对于理解来说数组更友好，因此没有给出变量版本。</p><h2 id="拓展二：最小花费"><a href="#拓展二：最小花费" class="headerlink" title="拓展二：最小花费"></a>拓展二：最小花费</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">爬楼梯。<br>从楼梯第<span class="hljs-selector-tag">i</span>个台阶向上爬需要支付cost<span class="hljs-selector-attr">[i]</span>的费用。<br>一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>返回爬到楼顶需要的最小花费。<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sln</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; cost)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> size = cost.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(size + <span class="hljs-number">1</span>)</span></span>; <br>    <span class="hljs-comment">// dp[i] 是到第i层后的最小花费，其中包括第i层的花费</span><br>    dp[<span class="hljs-number">0</span>] = cost[<span class="hljs-number">0</span>];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(cost[<span class="hljs-number">1</span>], cost[<span class="hljs-number">0</span>] + cost[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= size; i++) &#123;<br>        dp[i] = (i == size ? <span class="hljs-number">0</span> : cost[i]) + <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>], dp[i - <span class="hljs-number">2</span>]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[size];<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的解决方法中，将<code>cost[i]</code>放在了<code>min</code>的外面，是因为基于这样的思路：到达第<code>i</code>级台阶后将立刻花费，所以放在外面，只需关注是前一级花费小还是前两级花费小即可。</p><p>到达楼顶时，由于超出<code>cost</code>的范围，因此该层花费为0。</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分法核心及算法细节</title>
    <link href="/post/c96d2cc6.html"/>
    <url>/post/c96d2cc6.html</url>
    
    <content type="html"><![CDATA[<h2 id="核心："><a href="#核心：" class="headerlink" title="核心："></a>核心：</h2><ul><li><p>二分并不是仅仅用于找数字的，二分的二，其本质是两种不同的状态，通过<strong>每次排除一半</strong>来逼近两种状态的分界线。</p></li><li><p><strong>二分</strong>的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用<strong>二分</strong>。</p></li></ul><span id="more"></span><h2 id="二分细节"><a href="#二分细节" class="headerlink" title="二分细节"></a>二分细节</h2><h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><ol><li><p>所有情况均为<code>if else</code>语句，更加清晰</p></li><li><p>注意防止mid溢出</p></li></ol><h3 id="普通二分查找"><a href="#普通二分查找" class="headerlink" title="普通二分查找"></a>普通二分查找</h3><p>在nums中搜索target，找到返回下标，否则返回-1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; <span class="hljs-comment">// @1</span><br>    <span class="hljs-keyword">while</span>(l &lt;= r) <span class="hljs-comment">// @2</span><br>    &#123;<br>        <span class="hljs-type">int</span> m = (r - l) / <span class="hljs-number">2</span> + l;<br>        <span class="hljs-keyword">if</span>(nums[m] == target) <span class="hljs-keyword">return</span> m; <span class="hljs-comment">// 找到元素，返回下标</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &lt; target) l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// @3</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &gt; target) r = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// @4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先要明确，二分到最后肯定是不断逼近一个数字的，类比数学上二分找函数零点的思想。</p><p>上述的四处@，是四个注意的点，下面分别说一下：</p><ul><li><p>@1： r是<code>nums.size()</code>还是<code>nums.size()-1</code>?，这个选择其实是自由的，因为我们二分的目标在于，用尽量少的次数去找到目标值，其本质还是基于遍历的思想（不知道这么说是否准确，我的理解是，二分每次可以舍弃一半，但是这一半的舍弃我们确定不会对结果产生影响，所以舍弃，但是不能舍弃掉未知的元素。举个例子，这个nums数组有n个元素，那就必须n个元素都考虑在内，不能从第2个元素开始遍历）。既然要遍历，那么我们这里的<code>r</code>和<code>l</code>，也就是在确定遍历的范围。我们知道元素的下标是<code>0</code>到<code>nums.size()-1</code>，因此这里选择<code>nums.size()</code>还是<code>nums.size()-1</code>无所谓，<strong>只要保证搜索区间范围包含所有元素即可</strong>。对于选择<code>nums.size()</code>，那我们的搜索区间就是<code>[l,r)</code>，选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code></p></li><li><p>@2： <code>l &lt;= r</code>还是<code>l &lt; r</code>，这里的范围是由上面的搜索区间决定的。</p><ul><li><p>如果选择<code>nums.size()</code>，搜索区间是<code>[l,r)</code>，那么这里就应该是<code>l &lt; r</code>，可以用反证法，如果是<code>l &lt;= r</code>，那么如果一直向<code>r</code>逼近的话，<code>r</code>保持不变，<code>l</code>最终等于<code>r</code>，就会越界，所以是<code>l &lt; r</code>。</p></li><li><p>选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code>，这里应该是<code>l &lt;= r</code>，这时不怕越界，如果是<code>l &lt; r</code>的话，<code>l</code>最大也就是<code>r - 1</code>，那么会导致最后一个元素漏掉。</p></li><li><p>对于最后返回-1，<code>l &lt;= r</code>，终止条件是<code>l 等于 r + 1</code>，区间为空，可直接返回；但如果选择<code>l &lt; r</code>，终止条件是<code>l 等于 r</code>，但可能会漏掉一个元素（之所以可能，是因为如果<code>l</code>等于<code>r</code>等于<code>nums.size()</code>，那么无所谓，但如果是在内部，那么这个地方就没有顾及到）</p></li><li><p>如果数组是<code>&#123;1, 2, 3, 4, 5, 6, 7&#125;</code>，目标是3，那么就会找不到（已运行验证（注意这里说的是 <code>r=nums.size()</code>并且<code>l &lt; r</code>的循环条件）)，所以为了防止漏掉，要检查这个地方，即</p></li><li><p>&#96;&#96;&#96;cpp<br>if(l &lt; nums.size() &amp;&amp; nums[l] &#x3D;&#x3D; target) return l;<br>else return -1;</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- @<span class="hljs-number">3</span>： <span class="hljs-number">3</span>与<span class="hljs-number">4</span>是一个问题，放在一块说。有时候是`l = m`，有时候是`l = m + <span class="hljs-number">1</span>`，这里还是由于搜索空间决定的，这里左右边界的变化，决定了下一次的搜索空间。对于这个题，我们要保证所有的都遍历过，而现在`nums[m]`已经遍历过，那么不再需要遍历，下一次的空间就应该是`[l, m - <span class="hljs-number">1</span>]`或者`[m + <span class="hljs-number">1</span>, r]`。这是由一开始的搜索空间决定的，如果一开始是`[l, r)`，那么经过m后，要保持相同格式，就应该是`[l, m)`与<br>  <br>  `[m +<span class="hljs-number">1</span>, r)`。<br><br>### 边界二分查找<br><br>上面的二分可以查到目标值，但是如果有多个目标值，我们想要第一个或者最后一个的边界值又该怎么办呢？<br><br>要在下一次的**搜索空间**上下功夫：<br><br>#### 左边界二分<br><br>核心代码：<br><br>```cpp<br>while(l &lt; r) &#123; // 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是 &lt;<br>    int m = (r - l) / <span class="hljs-number">2</span> + l<span class="hljs-comment">;</span><br>    if(nums[m] == target) &#123;<br>        r = m<span class="hljs-comment">; // @1</span><br>    &#125; else if(nums[m] &gt; target) &#123;<br>        r = m<span class="hljs-comment">; // @2，m已经验证过，但这里保持m，是为了保持[l, r)的区间格式</span><br>    &#125; else if(nums[m] &lt; target) &#123;<br>        l = m + <span class="hljs-number">1</span><span class="hljs-comment">; // @3</span><br>    &#125;<br>&#125;<br>if(l &lt; nums.size() &amp;&amp; nums[l] == target) <span class="hljs-keyword">return</span> l<span class="hljs-comment">; // 原因上面已谈及</span><br>else <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>@1： 当我们找到一个符合条件的，由于需要找最左边的，不能直接返回，而是缩小上界。那如果只出现一次，将其放在<code>r</code>中，但最后返回<code>l</code>，有影响吗？经验证，没有影响，如果只出现一次，在第一次遇见放到<code>r</code>中，那么<code>l</code>会不断逼近直到与<code>r</code>相等（这也就是循环条件），所以最后返回<code>l</code>也是可以的。</p></li></ul><h4 id="右边界二分"><a href="#右边界二分" class="headerlink" title="右边界二分"></a>右边界二分</h4><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(l &lt; r) &#123; <span class="hljs-comment">// 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是&lt;</span><br>    <span class="hljs-type">int</span> m = (r - l) / <span class="hljs-number">2</span> + l;<br>    <span class="hljs-keyword">if</span>(nums[m] == target) &#123;<br>        l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// @1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &gt; target) &#123;<br>        r = m; <span class="hljs-comment">// 同上</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m] &lt; target) &#123;<br>        l = m + <span class="hljs-number">1</span>; <span class="hljs-comment">// 同上</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; nums[l - <span class="hljs-number">1</span>] == target) <span class="hljs-keyword">return</span> l - <span class="hljs-number">1</span>; <span class="hljs-comment">// @2</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure><p>在找右侧边界时，即最后一个，那么如果当前的m大了，为保持左闭右开，<code>r = m</code>，如果m小了，<code>l = m + 1</code>。</p><p>在@1中，可以看到是增大了下届(如果这里不加1，可能会出现死循环，因为m是向下取整，在只有两个数时，无法区分，比如3和4，中点是3，如果3不符合条件则会一直循环)，这里的+1对于返回值@2产生了影响，容易看到如果只有一个数字符合，这时候<code>l</code>又加1，那么应该返回<code>l - 1</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简要介绍了关于二分法在代码实现上的相关细节， 二分法思想比较简单，但是细节很多， 需要多注意。</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>算法</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Navicat无法连接MySQL</title>
    <link href="/post/32e06ea.html"/>
    <url>/post/32e06ea.html</url>
    
    <content type="html"><![CDATA[<h1 id="Navicat无法连接到MySQL数据库"><a href="#Navicat无法连接到MySQL数据库" class="headerlink" title="Navicat无法连接到MySQL数据库"></a>Navicat无法连接到MySQL数据库</h1><p>解决问题只需要一分钟，而发现问题则需要三小时。</p><span id="more"></span><h2 id="省流版："><a href="#省流版：" class="headerlink" title="省流版："></a>省流版：</h2><p>服务器没有开MySQL的端口。</p><p>之所以还要写一篇文章，是因为开端口只需要一分钟，而根据各种现象与线索推断出没有开端口则需要三个小时。</p><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在服务器上安装了Linux虚拟机，然后在虚拟机上安装MySQL。</p><p>之前一直都是用xshell操纵MySQL，今天想使用Navicat连接。</p><h2 id="my数据库"><a href="#my数据库" class="headerlink" title="my数据库"></a>my数据库</h2><p>MySQL的数据库如下：</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723162913700.png" alt="image-20230723162913700" style="zoom:50%;" /><p>共两个数据库，一个myDB1，一个university数据库（其余为MySQL自带的数据库）</p><p>此时我MySQL里面的用户如图：</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723162928064.png" alt="image-20230723162928064" style="zoom:50%;" /><p>可以看到里面有三个用户，root，peng和user_for_db1。其中user_for_db1是之前建立的，根据名字可知，为user_for_db1赋予了myDB1数据库的所有权限，同时为peng用户赋予所有数据库的所有访问权限。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在Navicat中，建立了两个连接，如图：</p><p>连接1：</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723162941660.png" alt="image-20230723162941660" style="zoom:50%;" /><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723162956534.png" alt="image-20230723162956534" style="zoom:50%;" /><p>可以看到连接成功，并且由于设置了访问权限，所以只有myDB1一个数据库。这个连接是很久之前建立的，当时忘记怎么连接的了（果然还是要养成记录的好习惯）。</p><p>但是当用另一个用户连接的时候，却提醒<strong>连接出错</strong>，如图：</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163046174.png" alt="image-20230723163046174" style="zoom:50%;" /><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163100864.png" alt="image-20230723163100864" style="zoom:50%;" /><p>另外也不是SSH连接的错误，因为都不行，这里只是没放截图。</p><h2 id="请教大佬"><a href="#请教大佬" class="headerlink" title="请教大佬"></a>请教大佬</h2><p>在向大佬请教过程中，并没有直接问为什么连不上，因为很多背景会导致共同的问题，上来直接问往往讲不清背景。我先是注意到在XShell中，连接的端口是22，协议是SSH，而Navicat中的端口是3306，因此就先问了一下这两个端口的不同。</p><p>大佬回答如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">22</span><span class="hljs-string">这个端口，是用SSH连接服务器的默认端口；</span><br><span class="hljs-number">3306</span><span class="hljs-string">这个端口，是MySQL的默认端口。</span><br></code></pre></td></tr></table></figure><p>当时还并没有十分清楚，大佬又来了一句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">3306</span><span class="hljs-string">可以改的</span><br><span class="hljs-string">开启MySQL时候换个端口就行</span><br></code></pre></td></tr></table></figure><p>听了这句话之后，我也排除了端口冲突的问题，因为这两个连接并没有同时打开。</p><p>之后向大佬讲了一下背景，也就是上文的内容，大佬听完后，也是不太清楚。。。。</p><h2 id="峰回路转"><a href="#峰回路转" class="headerlink" title="峰回路转"></a>峰回路转</h2><p>其实一开始就感觉这个问题有点奇怪，所以并没有很失望，不过看着大佬跟我说的那句：3306可以改的，我陷入了沉思。</p><p>MySQL怎么知道你把端口改了呢？</p><p>突然又想到最初设置服务器的时候，在安全组里面设置过一些端口</p><p>于是问了一下大佬要不要在服务器上添加允许这个新端口</p><p>果不其然，需要在服务器上设置。</p><p>然后，就想着在服务器上添加一个新端口，尝试用新端口连接。</p><p>然后震惊地发现，我没有给MySQL开端口！！</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163139596.png" alt="image-20230723163139596" style="zoom:67%;" /><p>发现这点后，我并没有立刻开放端口，而是开始思索，我之前怎么登录的呢？</p><p>看着被允许的几个端口，尤其是<strong>22</strong>那个端口，事情逐渐明朗了起来</p><p>我开了22的端口，而xshell也是用22连接的，也就是说，我用xshell连接，相当于是<strong>远程桌面</strong>。</p><p>我是先通过22端口，连接到远程桌面，也就相当于登录到服务器这个计算机，然后在进入到mysql，这时的MySQL就相当于是远程计算机的本地应用了，所以不需要向外网开放3306这个端口，本地计算机自然有访问所有端口的能力。</p><p>但是我一开始怎么连接成功的呢？</p><p>就是这个</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163240414.png" alt="image-20230723163240414" style="zoom:50%;" /><p>说实话想了好久也没想清楚，目前的推断是，在上图的安全组中（图7），有三个内网IP，有可能服务器认为我这个连接属于内网连接，所以可以通过（只是推测）。</p><h2 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h2><p>开放端口后，确实连接成功了，但是发现没有任何数据库信息，于是通过网上查阅资料，知道是需要如下操作，简单记录一下：</p><p>右键——编辑连接——数据库——选择对应的数据库（可能需要勾选使用自定义数据库列表）</p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20230723163320055.png" alt="image-20230723163320055" style="zoom:50%;" /><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>通过这次的问题，我明白了端口的重要性，端口和IP地址一样都是用来标识计算机的，通过这些标识赋予不同计算机的访问权限。</li><li>熟悉了一些关于用户与数据库授权的知识，只有授权后才能在Navicat中显示。</li><li>进一步感受到了如何正确的问问题：<ul><li>自己必须先尝试一些方案，不要遇到问题就直接问，先自己尝试解决。</li><li>同时要将对方代入到你的场景中，描述清楚背景是成功的一半。</li><li>在问的过程中，也要不断给出自己的思路，自己多加思考，因为没人有义务无偿且天然地向你解答。</li><li>即使到最后，这个解决方案，包括添加新端口与两个端口的差别，都是我自己引导着大佬去解答的。大佬并没有直接给出方案（可能还是由于描述不清，到最后他才知道我之前是用xShell登录的），自己才是最清楚历史原因的人，一定要多思考。</li></ul></li><li>添加一个端口只需要一分钟，但知道为什么添加，却需要三个小时。</li><li>2023年更新：计算机网络无处不在，无法理解网络，无法理解社会</li></ul>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>mysql</tag>
      
      <tag>数据库</tag>
      
      <tag>navicat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观后感-明日、我会成为谁的女友</title>
    <link href="/post/663a0935.html"/>
    <url>/post/663a0935.html</url>
    
    <content type="html"><![CDATA[<p>现在，在这个东京，仅是一个人想要生存下去，就需要很大的开销了，无论是优越的环境，还是强大的意志，要是缺少其中一样，就会连普通的生活都无法维持下去，这就是现实。</p><span id="more"></span><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>在这个充满束缚的世界里，为了尽可能活着，活下去，我要用自己的脚一步一步走下去。所以，今天，我也会是某人的女友。</p><p>彼时的东京，恰如此时的xx，都是一个这样的地方：<strong>金钱流通无息稍停，欲望增长尽日奔驰</strong>。</p><p>之前看过一本关于东京女性纪实的书，大体上有这样的概念，即很多在东京的女性，尤其以年轻女性为主，都在try theirs’s best to make ends meet. 在这种情况下，不能完全说风俗店或者出租女友的服务完全不合理，它终究是有个原因，是一整个社会共同造成的。在这样的情况下，女性究竟是何种命运，是什么造就了这种情况，它将如何发展下去，似乎要再次回到更加广阔的历史生物与哲学背景中。</p><p>但我自然没有如此之水平，再加上我是男性的身份，就决定了我既是法官，又是当事人，也就难以客观，值得怀疑。</p><p>但值得瞩目的事情在于讨论区的女性朋友们大多将重点放在了感情线与杀猪盘上，并未想要去考虑在背后与整个日本经济社会政治方面的联想，我也无法有效联想，因为知识太浅，但个人确实比较喜欢这种讲两性的剧并作出联想。</p><h2 id="情节"><a href="#情节" class="headerlink" title="情节"></a>情节</h2><p>对于整体的分析比较困难，还是拿几个情节来讲吧。</p><h3 id="雪"><a href="#雪" class="headerlink" title="雪"></a>雪</h3><p>第一个在于不同人对于小雪伤疤的态度，几乎所有人都带有略带怜悯的眼光去同情她，但实际上可能这种人最希望追求的是normal，不是别人特殊的眼光，特殊的照顾，而是正常看待的眼光。这种情况下，一直坚持整容变美的彩反而作出了雪最想要的反应：正常看待，觉得有问题就解决，解决时候还要注意很多东西。而另两个，一个爱情一个友情，都没有作出这种选择，而是投以怜悯的目光，或许也是身未受故感不同吧。之前觉得彩执着于整容有些过头，然而却也是自己的选择，这种情况下，你很难去以一件事情就去对一个人作出自己对他的盖棺定论，事情不断变化，人也在不断发展，我们的认识也要不断变化，这才是实事求是。</p><p>在剧中最理性的好像是雪，没有不良嗜好，行为也都有界限。所有的一切都是为了生活本身，而且对于未来也有一个比较清晰的规划。不得不说其原生家庭也不容易，<strong>并不是生了孩子就能变成母亲</strong>。</p><h3 id="萌"><a href="#萌" class="headerlink" title="萌"></a>萌</h3><p>第二个是沉沦的萌，她的沉沦与前面对爱情的冷漠表面矛盾对立，然则好像一体两面一样，是完全统一的。就好像弹簧一般，前期由于自己外貌与身材，加上身边人的评价，她也只能无奈接受这种设定，暂时把对于一些东西的渴望隐藏起来，但它们并没有消失。当一旦遇到某一个愿意正常待他时，她的反应只会更加剧烈，其热烈程度反而会让自己深度沉迷，最终导致受伤。正如其心中所想：“大家都在看着我，这用金钱编织的关系，这充满谎言的世界，但是，在这个世界中，我像主人公一样。”幸好最后即时发现止损。</p><p>一开始萌与枫之间就只是顾客与服务者的关系，因为有这样的一个恶性循环：萌想要多见枫，但她好像只能通过投入大量金钱与其他女性竞争来达到与枫的短暂见面机会，这样的金钱又迫使着萌去发展其他业务，使自己更加空虚后，又会继续到枫身上寻找依赖与慰藉。然而如果两个人真的情投意合好似天公作美的一对，那么第一步只能通过金钱的途径就会无效，枫自然会不断找时间与萌见面，恶性循环也就无从谈起。</p><p>一开始好像都很清醒，都知道只是逢场作戏，然而人心不足蛇吞象，欲望会不断增长的。见一面后就想着见两面，散步一小时后就想着吃饭两小时，最后所有的时间都换算成了高昂的价钱。</p><ul><li><p>疯狂尝试变美的彩，最初也只是为了抵抗身边人对于自己外貌的评头论足。</p></li><li><p>过度爱美的彩对于看重平淡的男友来说是负担，可是对于想要化妆变可爱的小翼，却是一位优秀的老师；对于脸部烫伤的雪，其自然而然的遮盖与变美的态度，又是雪所一直追求的平常相待。</p></li><li><p>不要看我！我讨厌那种眼神，就算我不觉得自己可怜，那种视线也会让我显得很悲惨。爱雪的朋友，都在为她所惋惜遗憾，甚至可怜她，可是单纯爱美的彩，却给出了最为平淡的反应和最为准确的建议</p></li><li><p>我已经递交退学申请书了，之前在电话里听你说时，妈妈因为很吃惊，说了很多难听的话，但我们永远都会支持小萌，人生不是只有读大学，小萌的人生只有一回，其实你爸爸也曾辍学过哦，稳定下来后再回家来玩吧。</p></li><li><p>未来的事没有任何人知道，现在你也只能选择想走的路。</p></li><li><p>雪冷静理性，但可能是因为童年缺爱，导致将自己最真实的封闭起来</p></li><li><p>梨奈外在条件好，但是前期需要不断地依靠男人，朋友，金钱，内心缺乏一个人独处的平心静气</p></li><li><p>彩因为之前被人说过丑，所以发疯般地不断整容，她仍然不会否定自己的活法，因为当她发现没人能理解她之后，能让自己幸福的还是自己。</p></li><li><p>优爱则是偏恋爱脑，被自己支持的男公关不断PUA，仍然喜欢他，可能也和父亲常年不在家有关系，基本不怎么管她。</p></li><li><p>萌因为一开始打扮中性，没有什么被呵护的经历，所以一开始并不喜欢恋爱。即使去过一次男公关店里后，依然是浅尝辄止的态度。后面枫的嘘寒问暖也无法真正打动萌，只有当萌以为自己因为外貌原因和其他人不是一类人，并且以为其他人闯入了自己的乌托邦之后，萌才去寻求男公关的安慰。可是这本就是个无底洞，当安慰是可以用钱去量化的，那么就总有人能比你出更多的钱，这种情况下，除了家庭资产丰厚的少部分人，卖身就变成了唯一的途径。</p></li></ul><h2 id="劳动、产业、起源"><a href="#劳动、产业、起源" class="headerlink" title="劳动、产业、起源"></a>劳动、产业、起源</h2><p>剧中的五个人的共同点在于都选择了以自己的身体作为生产资料去进行售卖身体的活劳动，一定程度上是女性占比多一些。牛郎也有，但我潜在意识中还是会觉得女性多一些，因为产业发达程度与受众数量也就是用户多少有关。在这种情况下，当女性是为了一些目标去从事这种活动时，或者只是为了make ends meet，并不会去觉得有什么不妥。因为她们也是劳动者，比起某些利用权力去为虎作伥的人来说好太多了。但这种劳动的可怕之处，在于它的易沉迷性。不管思想上多么受折磨，这样如此的高薪仍然是少有的领域，即使是互联网也难以抗衡（对于普遍人来说）（当然这里的高薪我们必须要提到关于色情行业的产业升级，无论什么行业产业链的下游都是困难的，高薪是说那些在新时代中改变营业方式吸取客人的店）在这样的高薪后面，即使有相对难缠的客人，但拿到手里的货币的重量仍然不容小觑。所以我想说的论点在于：投入产出比很高。正如那句话所说，拼命的努力是为了让成功到来时能够心安理得。与之意思相近的一点是权力要与胸怀匹配，否则会给自己和下属都带来灾难。</p><p>同样的，这种行业也会带来这样的不平衡。而且这样的劳动基本完全脱离成果。来钱过快过容易必然导致跨过思想层面的门槛变得极度容易，后续也会轻而易举地进入正反馈中：赚钱-&gt;大手花钱+因劳动脱离成果产生空虚-&gt;继续花钱-&gt;钱不够-&gt;继续赚钱。</p><p>劳动脱离成果后，因为没有成果的反馈，消费便十分容易地脱离掉需要，只能通过大手的花钱来证明自己的价值，不断强化自己有价值的观点，等到习惯了大手花钱后，也就只能与快速赚钱的行业相绑定了。</p><p>此时又不得不搬出那句话了：“男人的极大幸运在于，他，不论在成年还是在小时候，都被迫着必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>然而不得不提的一点在于，这并不是相当一部分女性的初心，这种情况下，很多问题都可以通过<strong>稳健到位的社会保障机制，及时高效合理的司法，有职业道德的教育工作者</strong>这三样东西去解决。日本高昂的大学贷款逼着年轻女性拼命地用尽一切方法维持生计，这并不是这部分女性的错。</p><p>这是谁的错呢？</p><p>或者更重要的一点，如何解决呢？</p><p>I don’t know both.</p>]]></content>
    
    
    <categories>
      
      <category>观影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>女性</tag>
      
      <tag>观后感</tag>
      
      <tag>电视剧</tag>
      
      <tag>日剧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些对于博客的归纳</title>
    <link href="/post/1a07e293.html"/>
    <url>/post/1a07e293.html</url>
    
    <content type="html"><![CDATA[<p>本人很喜欢写东西，无论是道听途说，还是捕风捉影，抑或是经典小作文，我都想要用文字记录下来，上大学以来在OneNote上记录的也不少了。</p><span id="more"></span><p>一个博客，应该是能够体现我这些想法的，而不仅仅只用来存放技术类的知识（个人想法）。</p><p>然而博客维护起来相对还是比较麻烦的，一是要面对其他人而不是自己，遣词造句上需要再三斟酌；二来毕竟要放在一个公开的互联网上，需要充分尊重不同人群的差异并给予平等的对待。</p><p>身为技术人员，所希望的，自然是</p><p><strong>互联网连接五大洲，二进制写尽天下事</strong></p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reference in c++ and c#</title>
    <link href="/post/8a2f0ada.html"/>
    <url>/post/8a2f0ada.html</url>
    
    <content type="html"><![CDATA[<p>浅谈一下C#与C++中引用的区别</p><span id="more"></span><p>C# 中有两种类型：引用类型和值类型。  引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（in、ref 和 out 参数变量除外——</p><p><code>in</code> 关键字会导致按引用传递参数，但确保未修改参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它类似于 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref">ref</a> 或 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier">out</a> 关键字，不同之处在于 <code>in</code> 参数无法通过调用的方法进行修改。 <code>out</code> 参数必须由调用的方法进行修改，这些修改在调用上下文中是可观察的，而 <code>ref</code> 参数是可以修改的， 同时<code>ref</code> 要求在传递之前初始化变量。）</p><h2 id="按值传递引用类型"><a href="#按值传递引用类型" class="headerlink" title="按值传递引用类型"></a>按值传递引用类型</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types">引用类型</a>的变量不直接包含其数据；它包含对其数据的引用。 如果按值传递引用类型参数，则<strong>可能更改属于所引用对象的数据</strong>，例如类成员的值。 但是，<strong>不能更改引用本身的值</strong>；例如，不能使用相同引用为新对象分配内存，并将其保留在方法外部。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">PassingRefByVal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Change</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] pArray</span>)</span><br>    &#123;<br>        pArray[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;  <span class="hljs-comment">// This change affects the original element.</span><br>        pArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>] &#123;<span class="hljs-number">-3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>&#125;;   <span class="hljs-comment">// This change is local.</span><br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class="hljs-number">0</span>]);<br><br>        Change(arr);<br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">    Inside Main, before calling the method, the first element is: 1</span><br><span class="hljs-comment">    Inside the method, the first element is: -3</span><br><span class="hljs-comment">    Inside Main, after calling the method, the first element is: 888</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在C++中，结果如下：</p><p>如图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeArray</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt; a)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>;<br>    a = vector&lt;<span class="hljs-type">int</span>&gt;&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    <span class="hljs-built_in">changeArray</span>(a);<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出为</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">1<br>1 2 3<br><span class="hljs-deletion">-1</span><br>1<br></code></pre></td></tr></table></figure><p>可以看出C#自动传递引用类型，只不过按照值传递；而C++则是调用复制构造函数，直接产生一个新的数组，对函数外没有影响。</p><h2 id="按引用传递引用类型"><a href="#按引用传递引用类型" class="headerlink" title="按引用传递引用类型"></a>按引用传递引用类型</h2><p>除了 <code>ref</code> 关键字添加到方法标头和调用，以下示例与上述示例相同。 方法中所作的任何更改都会影响调用程序中的原始变量。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">PassingRefByRef</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Change</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span>[] pArray</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// Both of the following changes will affect the original variables:</span><br>        pArray[<span class="hljs-number">0</span>] = <span class="hljs-number">888</span>;<br>        pArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>] &#123;<span class="hljs-number">-3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">-4</span>&#125;;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class="hljs-number">0</span>]);<br><br>        Change(<span class="hljs-keyword">ref</span> arr);<br>        System.Console.WriteLine(<span class="hljs-string">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* Output:</span><br><span class="hljs-comment">    Inside Main, before calling the method, the first element is: 1</span><br><span class="hljs-comment">    Inside the method, the first element is: -3</span><br><span class="hljs-comment">    Inside Main, after calling the method, the first element is: -3</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>C++如下：（在上面C++的代码中加了一个&amp;）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeArray</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; a)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); ++i)<br>    &#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    a[<span class="hljs-number">0</span>] = <span class="hljs-number">999</span>;<br>    a = vector&lt;<span class="hljs-type">int</span>&gt;&#123; <span class="hljs-number">-1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; a&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> &#125;;<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    <span class="hljs-built_in">changeArray</span>(a);<br>    std::cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">1<br>1 2 3<br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p>C++ 应该是没有值类型和引用类型的说法的（或者说不存在与 C# 的引用类型和值类型相对应的概念）。但是 C++ 类型的行为默认是 C# 中值类型的行为。</p><p>比如函数传递参数时，C++ 和 C# 的值类型都会把参数完整复制一份。C++ 往往用传递 const 引用的方式来省去复制的开销。而 C# 可以用 ref 关键词来传递值类型的引用。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>上述只是简单描述了其区别，但对原理尚未搞清楚，希望等到对引用了解深入以及进一步学习后再来看C++与C#的区别。</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters</a></p><p><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref</a></p><p><a href="https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/">https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</a></p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Developer</tag>
      
      <tag>Programming</tag>
      
      <tag>C++</tag>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>onedrive - not just cloud drive</title>
    <link href="/post/71ae5435.html"/>
    <url>/post/71ae5435.html</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>很多时候，一些问题与想法，必须要有多个设备的背景。</p><hr><span id="more"></span><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​通过两台电脑的日常使用思考，展现OneDrive这一同步利器，以及OneDrive的理念与意义。</p><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​三月份由于一些原因，入手了一个主机，原来的笔记本一下子变成了键盘托，想起之前觉得30块钱的键盘托有些贵，如今用大几千的笔记本当键盘托确实有些好笑。</p><p>​Angway，同步的问题刚开始显得不是那么重要，因为使用场景固定。无非是一些大文件的拷贝，这时用一个硬盘，就能轻松解决，而且300MB的顺序读写速度也让每次借硬盘、插线显得不是那么费劲。随后便在主机上舒舒服服地用了一段时间。</p><p>​后来，由于地区解封的原因，需要隔离，而隔离7天，或许就只能用我的笔记本了。</p><p>​但是我几个月来的工作文件基本都在主机上，如何同步，成了一个难题。</p><p>​我不想直接把文件拷到U盘然后传到笔记本上，感觉这样有些原始……</p><p>​也不想传到网盘里，因为要么某些太慢，要么感觉每次打开客户端太麻烦……</p><p>​我想要做的，是等我换回主机工作的时候，如何避免再重复一遍文件同步的工作，也想避免以后每次在两台设备或者更多台更换时，我都要记得这段时间内在当前电脑上的修改，然后用网盘或者U盘的方式传文件。因为使用场景比较灵活，也不可能部署一个NAS系统存文件(太贵加没有地方放)，对于一些软件来讲，没有必要把软件本体都同步，软件在电脑上变动还是相对较小的，主要是文件。</p><p>​我的理想目标是，能够像Git一样，有一个版本控制的功能，让我能够在多个客户端修改，之后每次修改完，能够通过一些指令(或者完全自动)比如git push传到某个云服务器上，然后更换设备时，只需要像git pull一样再从云端拉取下来，这样两台设备就可以无缝切换。</p><h4 id="OneDrive-来了"><a href="#OneDrive-来了" class="headerlink" title="OneDrive 来了"></a>OneDrive 来了</h4><p>​之前也一直有用过OneDrive，毕竟是微软自家的，用着Windows想不注意都难。之前个人有个5G的免费空间，但是用的体验不太好，要么很容易满，然后提醒你升级到365；要么是本地写点文件时候，他就一直在同步，但我又不清楚到底哪些能够同步，哪些默认同步，导致一些莫名其妙的同步，占用那本就少得可怜的空间，整的人很不好。甚至于有次我同步了桌面后，桌面上所有东西都没了，然后通过“取消链接到此电脑”以及退出OneDrive，桌面上的东西才又回来……</p><p>​想到了OneDrive，是因为它确实很不像一个云盘。国内的很多网盘，需要先在桌面找到客户端，然后双击，登录，可能还要收个验证码，此时又要拿出手机收短信或者扫码，然后看着网盘里的文件，思考位置在哪里(如果比较熟练也可以跳过这个步骤)，然后下载，然后到本地去查看，有时候可能下到C盘，还要找地方移动文件……</p><p>​之前有搞过阿里云盘的本地挂载，虽然最后也不了了之，但是感觉OneDrive运用了这种思路。以下我个人认为的OneDrive的一些特点：</p><ol><li>它不需要一个很复杂花哨的客户端，也不需要每次登录的验证，借助微软账户就能开机自动登录，也就是说只要开了机，就能登录，因为用的是一个账户。</li><li>OneDrive的文件既存在云上，也有本地，但是这种本地不像百度网盘这种，需要现打开客户端下载文件，而是自动同步。这有些类似于手机的自动同步功能，包括相册同步以及iCloud的同步。但感觉还有些不同：一个是手机相册很少有修改的场景，大多数是往里加加加照片；另一个是手机同步往往要打开客户端，有后台才能同步，但是手机这种工具以及使用场景来说，往往几周才打开一些冷门软件，所以同步也不及时。</li><li>OneDrive几乎没有界面UI上的学习成本，它借助于微软Windows操作系统，直接内嵌在原本的文件系统内，就像是把云端的文件目录挂载到了本地，并且能够实时更新。只要见过微软的文件系统长什么样，用OneDrive完全不陌生。所以在UI上，就像是在浏览电脑本地上一个磁盘一样。对于具体文件，一般存到云中，等到下载下来，就还是存在本地磁盘。</li><li>对于每个文件，都有三种情况，下载、始终保存、释放。文件目录会在各个设备上实时自动更新，一般情况下，文件既然是从电脑A上传的，那么肯定在电脑A上，同时电脑B的文件目录也会自动更新，这时带着电脑B出去，只需要双击这个文件，就能自动从云端下载，然后打开，就彷佛它本来就在电脑B中一样。</li></ol><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>​OneDrive会在第一次登陆的时候让用户选择一个本地的路径，这就是自动同步的OneDrive文件夹，默认路径为“C:\用户[用户名]”。除了这个，“桌面”“文档”与“图片”文件夹也是可以自动同步的，只不过用户可以手动选择。</p><p>​一般地，将需要同步的文件或文件夹放入上述四个文件夹内，即可实现本地与OneDrive云端的文件同步。如果我们需要同步电脑中其它位置的文件或文件夹，可以将他们直接复制粘贴到上面四个文件夹内，但比较麻烦。因此，我们可以借助mklink 命令实现。（具体操作网络上有很多教程，此处不再赘述）</p><p><code>mklink /d &quot;Link&quot; &quot;Target&quot;</code></p><p>注意需要管理员权限。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>​有了这些准备，我将本地的一些必要的文件夹都上传到了OneDrive中，几万个文件花了几个小时才传完。然后笔记本就能无缝衔接主机之前的工作，主机也能无缝衔接笔记本的工作。</p><p>​不过还有另外一个很意外的惊喜：隔离期间用笔记本搭建了这个博客，回家后又开始使用主机，于是萌生了把博客文件夹也上传到OneDrive的想法。用笔记本把所有博客需要的文件都上传到OneDrive后，因为主机之前也装过nodejs和hexo，git这些软件，所以相当于文件和环境都有了。然后这时候再生成一个密钥，和GitHub认证一下，相当于主机本地密钥和GitHub也配对了，竟然可以直接在主机上写博客发布文章了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​不得不说，当有了多个设备后，同步的需求几乎是立刻就会产生。今日大谈OneDrive，绝无踩一捧一之意。实事求是来讲，多电脑同步的场景下，这种映射成为本地文件夹+自动同步确实很舒服。OneDrive也确实很适合个人在电脑上使用。</p><p>​不过OneDrive确实也有很多问题，比如网络方面，以及它绝无法取代百度网盘，因为OneDrive并没有在国内构建起以社交网络为基础的共享生态，而某网盘借助于微信小程序，成功渗透进了微信的社交网络中。即使OneDrive有共享功能，但是相比之下，可能大多数人还是更喜欢扫二维码吧，毕竟老板同事都在用百度网盘传文件，你又能做何选择呢？</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>OneDrive</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>观后感-阿尔卑斯山求生记</title>
    <link href="/post/13a30ca8.html"/>
    <url>/post/13a30ca8.html</url>
    
    <content type="html"><![CDATA[<h2 id="生命史诗与自然之魂！"><a href="#生命史诗与自然之魂！" class="headerlink" title="生命史诗与自然之魂！"></a>生命史诗与自然之魂！</h2><hr><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p><strong>天地有大美而不言</strong></p><p><strong>四时有明法而不议</strong></p><p><strong>万物有成理而不说</strong></p><p>人类会犯错，自然不会犯错 </p><p>被震撼的一次观影</p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>头狼为了自己的威信，向熊发起挑战</p><p>虽然最后伤病而死，但他难道输了吗？</p><p>若是，那么对于生命的赢又是什么？</p><p>动物也并非没有愿意用生命去捍卫的东西</p><p>雌性头狼离开狼群陪伴伴侣，谁说殉情只是古老的传说？</p><p>原有的狼群迅速选择新首领，谁又能说他们错了？</p><p>没有首领必然意味着群体的灭亡</p><p>自然不会错，只是我们难以理解</p><p>雌性头狼最终离开已经死去的头狼，是不敢殉情吗？</p><p>——她还怀着孩子</p><p>有时候生，并非意味着幸福</p><p>六甲之躯，跨越群山</p><p>共计公里万余三</p><p>只身孤影，克服万难</p><p>没有丰富的面部表情，不意味着没有感情</p><p>没有语言，不意味着没有想法</p><p>在如此情况下，六只狼崽全部存活</p><p>母性伟大之光辉震烁千古！</p><p>我又想起了那些把孩子生在厕所里的母亲</p><p>有时候精神的高尚</p><p><strong>不会随着直立行走而更加高大</strong></p><p><strong>亦不会随着身姿的匍匐而变得卑微</strong></p><p>刚生下狼崽，碰见猞猁</p><p>有些讨厌，人家刚生下孩子，你对人家幼崽虎视眈眈</p><p>就不能找点别的吃的吗</p><p>后来</p><p>原来她也是母亲</p><p>愚昧如我</p><p>自然没有对错，亦无好坏</p><p>走投无路的狼妈妈，将眼光看向了羊群 </p><p>若是生活没有如此艰难，谁愿意铤而走险？？</p><p>可生活就是这样，自前世而固然</p><p>高山环境恶劣 </p><p>导致残酷的竞争</p><p>可是却也恰恰因为恶劣的环境</p><p>合作显得尤为重要</p><p>视频结尾有一段话结束</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>在最艰难的条件下，能够生存下来的不是最强者，而是互相帮助的个体</p><p>环境越恶劣，团结协作的重要性就越发凸显</p><p>这就是我们从阿尔卑斯山的生物上学到的品质</p><p>在这里生活，他们都知道这一点：</p><p>雌性羱羊守望相助，一起照顾后代</p><p>鸟类聚集一起寻找食物</p><p>鹿紧紧挤在一起取暖</p><p>树木为老祖宗提供养分</p><p>狼为了守护族群不惜牺牲一切</p><p>瑞士松依靠星鸦把种子洒满山野</p><p>狼需要克服无数挑战才能与其他狼和平共处</p><p>人类需要依靠驯养的犬来守卫家畜</p><p>所有生物都知道自己不是最强大的</p><p>大山本身都比他们强大的多</p><p>所以他们才会这样相互依存</p><p>或许这就是自然吧：</p><p>它的魅力让我抓心挠肝，</p><p>它的美丽让我惊心动魄，</p><p>它的威严让我顶礼膜拜，</p><p>它的慈祥让我泪水常噙。</p><p>自然不会错</p>]]></content>
    
    
    <categories>
      
      <category>观影</category>
      
    </categories>
    
    
    <tags>
      
      <tag>纪录片</tag>
      
      <tag>观后感</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中国智慧与当代社会</title>
    <link href="/post/2454a085.html"/>
    <url>/post/2454a085.html</url>
    
    <content type="html"><![CDATA[<h3 id="人民有信仰，国家有力量，民族有希望"><a href="#人民有信仰，国家有力量，民族有希望" class="headerlink" title="人民有信仰，国家有力量，民族有希望"></a>人民有信仰，国家有力量，民族有希望</h3><p>层层递进的关系</p><h4 id="民族的信仰在哪里？"><a href="#民族的信仰在哪里？" class="headerlink" title="民族的信仰在哪里？"></a>民族的信仰在哪里？</h4><p>信仰：</p><ol><li>对生命价值的确认 </li><li>对人生意义的领会</li></ol><p>87年的深圳标语：时间就是金钱，效率就是生命，回答的正是这个问题。不可否认的是在当时，这两句话起到了积极的作用，但不能长久支持中华民族。</p><p>疫情让我们飞速发展的社会停下来，我们应该要思考改革开放几十年后所缺少的东西：</p><ol><li>敬重天道</li><li>敬畏人性</li></ol><p>中华民族有文化生命，诗经言：周虽旧邦，其命维新</p><p>科学给我们知识，但不等于智慧。在科学中不意味着在思想中。</p><p><strong>应无所住，而生其心。</strong></p><p>住：住相。相：世界上所有的事物与人都区分出高低贵贱。Eg.钻石与普通石头</p><p>高低贵贱并不是自然物本身的属性，人为区分。</p><p>相是客观的，有人类社会就有相。</p><p>不执著于相，显现本心。</p><p>教科书中是知识与对知识的论证。</p><p>​        当代人无法生出智慧，因为我们所生存的当代文明，已经高度复杂化，充满了知识与机巧，这种人离开智慧最为遥远。在朴素文明中生活的人，才有可能俯仰天地，领会天人之际。我们的智慧只能是对古代智慧的解读。</p><p>​        西汉初年为道家思想，无为而治。但无法长久，因为道家的学说无法为任何一个民族，为他的社会秩序，奠定一个精神基础。才有的罢黜百家，独尊儒术。中国的道统是儒家。</p><p>今天的中国人，从根本上来看，其对生命价值的确认，还是源于儒家。</p><p>儒家让我们站在大地上，这个大地就是<strong>亲情和亲情传递给我们的牵挂和责任</strong>。</p><p>无论如何学西方，根本上还是儒家。</p><p><strong>儒道互补</strong>：儒家讲原则、理想、社会的伦理精神</p><p>道家讲<strong>权变</strong></p><p>原则性与灵活性的高度统一</p><p>灵活性过头，导致以权变经，便会产生奸猾的人生态度。</p><p>菠萝，三昧均是音译，中国文化中没有对应的思想，也就没有对应的汉字。</p><p>唐朝佛学中国化，才有了众多的词语。</p><p>儒家讲性理（人性），道家讲玄理，佛家讲空里。</p><p>玄理：房间的四周墙壁的有，都是为了中间的无。有和无之间的关系。</p><p>玄之又玄，众妙之门。</p><p>​        人的生命对自身就是问题。人心的安顿，（对无限的一面，需要安顿）有限的一面是对周遭事物的经验与知识，因为其对象便是有限的。</p><p>筹划未来落空了，也就是有了烦恼。</p><p>​        大多数人在绝大多数时间同时具备着温饱，安全与健康，但我们仍然是烦恼不断。此之为<strong>无限心</strong>。</p><p>不仁者，不可以久处约，不可以长处乐。</p><p>（约：节约，贫贱的生活处境，不仁者：心没安顿好）</p><p>不仁者，贫贱难耐凄凉，富贵不能乐业。</p><p>无论你买的多豪华的东西，都是暂时的为你使用。<strong>无限的心又如何安顿在有限的事物中</strong></p><p>安顿心，只能两种方法：<strong>宗教与哲学</strong></p><p><strong>儒：无所为而为</strong>。做事并不是为了达成某个目标的途径与手段，事情自己就是自己的价值与意义，而不是其他任何事情。因此没有失败的人生——任何事情都不是为了其他事情的手段与途径。</p><p><strong>道：无为而无不为</strong>。人+为&#x3D;伪(造作) 减少做事时人为的因素。</p><p>生非贵之所能存，身非爱之所能厚；</p><p>生亦非贱之所能夭，身亦非轻之所能薄。</p><p>饮食：已饥方食，未饱先止。</p><p>伟大的哲学典籍，只需要懂几句话便可以终身受用（上善若水）</p><p><strong>佛：无心而为</strong>。做事是为了消业，希望没有结果才好。</p>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>人文情怀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>the-second-sex</title>
    <link href="/post/bf968ce7.html"/>
    <url>/post/bf968ce7.html</url>
    
    <content type="html"><![CDATA[<h1 id="第二性摘录"><a href="#第二性摘录" class="headerlink" title="第二性摘录"></a>第二性摘录</h1><ol><li>“女性是第二性，排除在男性以外的“他者”。权力归于男性，女性仅仅是附庸。附庸的庇护来自权力，歧视也来自于权力。事实就是如此，谁家生了女儿也还是叹惋一阵儿。连在性交中，女性都是处于被动和守势，像个容器，收纳男性的欲望。”</li><li>“夫妻是这样一个共同体，它的成员失去了独立性却不能够摆脱孤独；他们是一种静态的结合，是“同一个人”，而不是在维持一种动态的、充满活力的关系。”</li><li>“但情况依然是，女人打扮得越漂亮，她就越受到尊重；她越是需要工作，绝佳的外貌对她就越是有利；姣好容貌是一种武器，一面旗帜，一种防御，一封推荐信。”</li><li>“人们常说，女人打扮是为了引起别的女人的嫉妒，而这种嫉妒实际上是成功的明显标志；但这并不是唯一的目的。通过被人嫉妒、羡慕或赞赏，她想得到的是对她的美、她的典雅、她的情趣——对她自己的绝对肯定；她为了实现自己而展示自己。”</li><li>“服饰对许多女人之所以如此重要，是因为它们可以使女人凭借幻觉，同时重塑外部世界和她们的内在自我。”</li><li>“肖伯纳说，让人们受到束缚比让他们摆脱这种束缚更容易，只要这种束缚会带来利益。”</li><li>“打扮不仅仅是修饰，它还表明了女人的社会处境。”</li><li>“想想也真可悲，”米什莱写道，“女人，这个相对的人，只能作为夫妻中的一员来生活，她往往比男人孤独。他广交朋友，不断有新的接触。她若无家庭则什么也不是。而家庭是一种摧残人的负担；它的全部重量都压在她的肩上。”</li><li>“ 一种没有雄心也没有激情的金光闪闪的平庸，漫无目的，无限地周而复始的日子，缓缓地滑向死亡，不寻思原因的生活。原封不动地保存和重复世界，看来既不可取，也不可能。”</li><li>“女人不是天生的，而是造就的。”</li><li>“人们将女人关闭在厨房里或者闺房内，却惊奇于她的视野有限；人们折断了她的翅膀，却哀叹她不会飞翔。但愿人们给她开放未来，她就再也不会被迫待在目前。”</li><li>“一个人不是生下来就是女人，她是变成女人的。”</li><li>“男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</li><li>“如果女人只是一个消极的实体，男人所支配的不过虚无而已。他自以为他正在攫取使他丰富的东西，实际上那只是幻念。”</li><li>“真正的价值并不源于外在的事物，而是源于人心。”</li><li>“司汤达：妇女解放不只泛泛地打起自由的旗号，还要凭着个人幸福的名义。爱情决不会丧失什么东西，相反，当女人与男人平等之时，她越是能完全理解他，爱情便越是真诚。”</li><li>“几乎没有什么工作能比永远重复的家务劳动更像西绪弗斯所受的折磨了：干净的东西变脏，脏的东西又被搞干净，周而复始，日复一日。家庭主妇在原地踏步中消耗自己：她没有任何进展，永远只是在维持现状。她永远不会感到在夺取积极的善，宁可说是在与消极的恶做无休止的斗争。”</li><li>“然而事实上，当两个人一方面彼此憎恶，另一方面又必须相依为命时，这种关系并不是人类一切关系中最真诚、最动人的，宁可说是最可怜的。”</li><li>“爱是一种外向的活动，一种指向另一个人、指向与自己相分离并明显有别于自己的存在、指向可以见到的终点——未来的冲动。”</li><li>“婚姻的悲剧性并不在于它无法保障向女人许诺过的幸福（保障幸福这种事本来就不存在），而在于它摧残了她；它使她注定要过着周而复始的千篇一律的生活。”</li></ol>]]></content>
    
    
    <categories>
      
      <category>Reader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>波伏娃</tag>
      
      <tag>阅读</tag>
      
      <tag>女性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>blogOasis的诞生</title>
    <link href="/post/bc97fc50.html"/>
    <url>/post/bc97fc50.html</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说来惭愧，这是第4次搞博客了，前几次均以流产为终点。</p><p>所幸这次应该是走运了，配置成功</p><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>其中教程参考颇多，重点有以下几个，留作纪念：</p><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html">安装Node JS – Windows</a></p><p><a href="https://www.cnblogs.com/mingyue5826/p/11141324.html">安装Git以及配置SSH</a></p><p>(注：对于上面的SSH的两个密钥，我是这么考虑的：本地生成能够一一对应的共有密钥和私有密钥，私有存在本地，公有放在Github上。等提交更改时，用本地的私有与Github的共有密钥去进行匹配，这样既方便的同时也更安全——不用每次输入密码，防止忘记密码，并且单看长度也比自己的密码安全多了)</p><p>之后安装Hexo，在本地初始化文件夹存放博客，此处略过</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>其中由于之前有次安装博客但是夭折，遇到了一个历史遗留问题：存储库的访问被拒绝</p><p>因为我之前用另一个邮箱尝试建立过博客，这次用的新邮箱</p><p>关于这个问题，网络上有很多说法，并且也都成功解决了，链接如下：</p><p><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p><p><a href="https://blog.csdn.net/klxh2009/article/details/76019742">https://blog.csdn.net/klxh2009/article/details/76019742</a></p><p>我甚至重装了Git</p><p>但是并不适合于我</p><p>最后幸好有一位大佬相助，指出可能是https和ssh之间不能直接通用</p><p>于是在config.yml的配置文件中，把最后deploy的repo部分由https改成了ssh的链接，最终成功。</p><p>泪目！</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>此博客来之不易，希望以后能多写博客，好好珍惜。</p>]]></content>
    
    
    <categories>
      
      <category>Geek</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
