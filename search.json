[{"title":"the-second-sex","url":"/post/bf968ce7.html","content":"<h1 id=\"第二性摘录\"><a href=\"#第二性摘录\" class=\"headerlink\" title=\"第二性摘录\"></a>第二性摘录</h1><ol>\n<li>“女性是第二性，排除在男性以外的“他者”。权力归于男性，女性仅仅是附庸。附庸的庇护来自权力，歧视也来自于权力。事实就是如此，谁家生了女儿也还是叹惋一阵儿。连在性交中，女性都是处于被动和守势，像个容器，收纳男性的欲望。”</li>\n<li>“夫妻是这样一个共同体，它的成员失去了独立性却不能够摆脱孤独；他们是一种静态的结合，是“同一个人”，而不是在维持一种动态的、充满活力的关系。”</li>\n<li>“但情况依然是，女人打扮得越漂亮，她就越受到尊重；她越是需要工作，绝佳的外貌对她就越是有利；姣好容貌是一种武器，一面旗帜，一种防御，一封推荐信。”</li>\n<li>“人们常说，女人打扮是为了引起别的女人的嫉妒，而这种嫉妒实际上是成功的明显标志；但这并不是唯一的目的。通过被人嫉妒、羡慕或赞赏，她想得到的是对她的美、她的典雅、她的情趣——对她自己的绝对肯定；她为了实现自己而展示自己。”</li>\n<li>“服饰对许多女人之所以如此重要，是因为它们可以使女人凭借幻觉，同时重塑外部世界和她们的内在自我。”</li>\n<li>“肖伯纳说，让人们受到束缚比让他们摆脱这种束缚更容易，只要这种束缚会带来利益。”</li>\n<li>“打扮不仅仅是修饰，它还表明了女人的社会处境。”</li>\n<li>“想想也真可悲，”米什莱写道，“女人，这个相对的人，只能作为夫妻中的一员来生活，她往往比男人孤独。他广交朋友，不断有新的接触。她若无家庭则什么也不是。而家庭是一种摧残人的负担；它的全部重量都压在她的肩上。”</li>\n<li>“ 一种没有雄心也没有激情的金光闪闪的平庸，漫无目的，无限地周而复始的日子，缓缓地滑向死亡，不寻思原因的生活。原封不动地保存和重复世界，看来既不可取，也不可能。”</li>\n<li>“女人不是天生的，而是造就的。”</li>\n<li>“人们将女人关闭在厨房里或者闺房内，却惊奇于她的视野有限；人们折断了她的翅膀，却哀叹她不会飞翔。但愿人们给她开放未来，她就再也不会被迫待在目前。”</li>\n<li>“一个人不是生下来就是女人，她是变成女人的。”</li>\n<li>“男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</li>\n<li>“如果女人只是一个消极的实体，男人所支配的不过虚无而已。他自以为他正在攫取使他丰富的东西，实际上那只是幻念。”</li>\n<li>“真正的价值并不源于外在的事物，而是源于人心。”</li>\n<li>“司汤达：妇女解放不只泛泛地打起自由的旗号，还要凭着个人幸福的名义。爱情决不会丧失什么东西，相反，当女人与男人平等之时，她越是能完全理解他，爱情便越是真诚。”</li>\n<li>“几乎没有什么工作能比永远重复的家务劳动更像西绪弗斯所受的折磨了：干净的东西变脏，脏的东西又被搞干净，周而复始，日复一日。家庭主妇在原地踏步中消耗自己：她没有任何进展，永远只是在维持现状。她永远不会感到在夺取积极的善，宁可说是在与消极的恶做无休止的斗争。”</li>\n<li>“然而事实上，当两个人一方面彼此憎恶，另一方面又必须相依为命时，这种关系并不是人类一切关系中最真诚、最动人的，宁可说是最可怜的。”</li>\n<li>“爱是一种外向的活动，一种指向另一个人、指向与自己相分离并明显有别于自己的存在、指向可以见到的终点——未来的冲动。”</li>\n<li>“婚姻的悲剧性并不在于它无法保障向女人许诺过的幸福（保障幸福这种事本来就不存在），而在于它摧残了她；它使她注定要过着周而复始的千篇一律的生活。”</li>\n</ol>\n","categories":["Reader"],"tags":["波伏娃","阅读","女性"]},{"title":"NieR-Automata通关感言","url":"/post/b988b94d.html","content":"<p>尼尔一场大梦，人生几度秋凉</p>\n<span id=\"more\"></span>\n\n<p>没想到最后还是哭了</p>\n<h2 id=\"一段人生，一次经历\"><a href=\"#一段人生，一次经历\" class=\"headerlink\" title=\"一段人生，一次经历\"></a>一段人生，一次经历</h2><p>尼尔里面有什么</p>\n<p>有机械，有主角</p>\n<p>有战斗，有音乐</p>\n<p>有喜悦，有痛苦</p>\n<p>有虚拟，有现实</p>\n<p>有游戏，有人生</p>\n<h2 id=\"从头到尾的虚拟\"><a href=\"#从头到尾的虚拟\" class=\"headerlink\" title=\"从头到尾的虚拟\"></a>从头到尾的虚拟</h2><p>一切的一切都是假的</p>\n<p>甚至包括你的名字</p>\n<p>只是为了服务于某个更高阶层</p>\n<p>服务于更为宏大的目标</p>\n<p>服务于从头到尾都是虚假的人类荣耀永存</p>\n<p>战斗员戴着眼罩</p>\n<p>通讯官戴着口罩</p>\n<p>行凶者不知真相，知真相者口不能言</p>\n<p>没有谁能够毫无理由就去战斗，我们需要能够为之奉献的神</p>\n<p>——尼尔-机械纪元</p>\n<h2 id=\"机械的感情\"><a href=\"#机械的感情\" class=\"headerlink\" title=\"机械的感情\"></a>机械的感情</h2><p>为了毫不留情地将所有的机械消灭，只能不断灌输机械没有感情，寄叶部队也相信着它。</p>\n<p>然而无休止唱歌的歌姬</p>\n<p>亚当与夏娃</p>\n<p>帕斯卡的村庄</p>\n<p>因恐惧自杀的孩童</p>\n<p>抵抗军的军营</p>\n<p>森林里的王</p>\n<p>迪瓦拉和波波拉</p>\n<p>甚至包括2B，9S，A2他们自身</p>\n<p>以及辅助机</p>\n<p>都在演绎着人类的情感</p>\n<p>开心难过痛苦绝望</p>\n<p>分离的不舍，重聚的欢欣</p>\n<p>全作无一个人类</p>\n<p>却处处是人类</p>\n<p>自以为能够拯救世界，可到头来终究是一场空</p>\n<p>数据被删除后，往事皆随风，又是一次轮回的开始</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>不知道最后的E结局是不是封神之作</p>\n<p>但确确实实感动到了我</p>\n<p>最终打所有制作人员的操作别出心裁，或许是想让玩家泄愤</p>\n<p>然而打是打不过的</p>\n<p>每一次死亡，都会被问道：</p>\n<p><strong>“你承认自己已经战败了吗”</strong></p>\n<p><strong>“这一切都是白费力气吗”</strong></p>\n<p><strong>“你认为区区游戏实在很愚蠢吗”</strong></p>\n<p><strong>“你承认这个世界没有意义吗”</strong></p>\n<p><strong>“要在此放弃吗”</strong></p>\n<p><strong>“要接受救援吗”</strong></p>\n<p>看来我一共死了六次，第六次来了救援</p>\n <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fca9875f1-5bbf-4e12-a69c-d818bb59d52b%2FUntitled.jpeg?table=block&id=50f9441c-1615-4dab-bc63-ef4611b6b888\" style=\"zoom: 50%;\" />\n\n<p>然后弹药突然变多</p>\n<p>但是每死一个，都会提示xx的数据丢失了</p>\n<p>总之火力猛了果然还是过了</p>\n<p> <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdbfcebc7-62a1-4de7-956e-9e7caf1e66d2%2FUntitled.jpeg?table=block&id=a029abb2-314a-4863-868b-6e4e1b192a9c\"></p>\n<p>这时候辅助机发问：</p>\n<p>你有什么话要说</p>\n<p>看到这个格式，我才明白</p>\n<p>之前的每一条留言</p>\n<p>都是一位玩家贡献出来的</p>\n<p>你打不打算拯救弱者？</p>\n<p>只要选择这个选项，你就能拯救世界上的某人</p>\n<p>代价是失去所有的保存资料</p>\n<p>即便如此。你仍愿意拯救某个素不相识的人吗？</p>\n<p>（看到这里我才知道原来之前的每个帮助我的人都放弃了自己几十个小时的游戏存档）</p>\n<p>拯救的对象随机选择</p>\n<p>所以</p>\n<p>向你求救的对象</p>\n<p>可能是你讨厌的人</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>你拼命才解锁的选择章节功能（我甚至还没有体验过）</p>\n<p>也会无法使用</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>即使你拯救他人，或许也不会被感谢</p>\n<p>你的行为可能会被视为伪善</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>真的，真的要继续吗</p>\n<p>以所有数据当作代价</p>\n<p>我会把你的意思告诉这个世界</p>\n<p> <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4c9c919c-2512-4f19-9610-57cc29be1868%2F20220810151300_1.jpg?table=block&id=c903fa57-9803-4f21-bddb-3a3cd8a460da\"></p>\n<h2 id=\"活着的意义\"><a href=\"#活着的意义\" class=\"headerlink\" title=\"活着的意义\"></a>活着的意义</h2><p>开始的一段话结尾：</p>\n<p>他们被设计成能毁灭一切的存在</p>\n<p>在生与死的螺旋中</p>\n<p>他们一直被囚禁着</p>\n<p>但是</p>\n<p>在那些轮回中的挣扎</p>\n<p>便是活着的意义</p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3ce249f3-6a1e-4eff-887c-3c932ec8844d%2F20220810151425_1.jpg?table=block&id=d3c9e4df-31c0-4d4d-8ea5-109299a7ff8c\"></p>\n<p><code>A2&amp;2B&amp;9s</code></p>\n<p><code>All(A2) is gonna to be(2B) nice(9S)</code></p>\n<h2 id=\"几张美图\"><a href=\"#几张美图\" class=\"headerlink\" title=\"几张美图\"></a>几张美图</h2><p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fabb6b423-46e6-4a0d-9dde-2d5a5b4e6724%2F20220417174024_1.jpg?table=block&id=d6fbe8a5-0a26-486b-b4d9-9a171295baa6\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F72c4a688-9df6-4663-8697-e30faba01022%2F20220421154328_1.jpg?table=block&id=59d64fe3-4c2d-429c-bb20-8b0420aead4d\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8a5f17c8-eb72-4d4e-a9cf-7e91abf9d325%2F20220421165918_1.jpg?table=block&id=ae4ab0a5-54fa-443b-93e5-fb4340f188c7\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5351dd02-d256-4934-af5c-1b4497090693%2F20220423134020_1.jpg?table=block&id=96903f94-2b51-474d-92d7-d4676d95b8ce\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F28c12106-2187-4c17-be9b-38c9393593ce%2F20220423134122_1.jpg?table=block&id=b222c905-0004-4685-b5d9-1c09a40cd4c6\"></p>\n","categories":["Game"],"tags":["Game","NieR"]},{"title":"C++空类大小的探讨","url":"/post/347fef97.html","content":"<p>对几个网站的内容整合了一下，结尾有参考链接</p>\n<h2 id=\"GeeksforGeeks\"><a href=\"#GeeksforGeeks\" class=\"headerlink\" title=\"GeeksforGeeks\"></a>GeeksforGeeks</h2><p><strong>Empty class:</strong> It is a class that does not contain any data members (e.g. int a, float b, char c, and string d, etc.) However, an empty class may contain member functions. </p>\n<p>Suppose, if a class does not have any size, what would be stored on the memory location? That’s the reason when we create an object of an empty class in a C++ program, it needs some memory to get stored, and the minimum amount of memory that can be reserved is 1 byte. Hence, if we create multiple objects of an empty class, every object will have a unique address.</p>\n<p><em>There is an interesting rule that says that an empty base class need not be represented by a separate byte. So compilers are free to make optimization in case of empty base classes.</em> </p>\n<h2 id=\"StackOverflow\"><a href=\"#StackOverflow\" class=\"headerlink\" title=\"StackOverflow\"></a>StackOverflow</h2><p>That’s really an implementation detail. Once long ago, I thought it could be zero bytes or a thousand bytes, that it has no bearing on the language specification. But, after looking at the C++17 standard (<code>expr.sizeof</code>), <code>sizeof</code> is defined as always returning one or greater, no matter what.</p>\n<blockquote>\n<p>The size of a most derived class shall be greater than zero.</p>\n</blockquote>\n<p>This is required for, among other things, allowing you to handle arrays of objects and pointers to them. If your elements were allowed to be zero-sized then <code>&amp;(array[0])</code> would be identical to <code>&amp;(array[42])</code>, which is going to cause all sorts of havoc to your processing loops.</p>\n<hr>\n<p>The C++ standard guarantees that the size of any class is at least one. The C++ standard states that no object shall have the same memory address as another object. There are several good reasons for this.</p>\n<ol>\n<li>To guarantee that <code>new</code> will always return a pointer to a distinct memory address.</li>\n<li>To avoid some divisions by zero. For instance, pointer arithmetics (many of which done automatically by the compiler) involve dividing by <code>sizeof(T)</code>.</li>\n</ol>\n<h2 id=\"sizeof-测试\"><a href=\"#sizeof-测试\" class=\"headerlink\" title=\"sizeof 测试\"></a>sizeof 测试</h2><p>来源：<a href=\"https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/\">geeksforgeeks</a></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Empty</span> &#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derived1</span> : <span class=\"hljs-keyword\">public</span> Empty &#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derived2</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Empty &#123;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derived3</span> : <span class=\"hljs-keyword\">public</span> Empty &#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Derived4</span> : <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-keyword\">public</span> Empty &#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dummy</span> &#123;<br>\t<span class=\"hljs-type\">char</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>大小分别是：1，1，8，1，16，1</p>\n<p>原因：</p>\n<ul>\n<li>一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间</li>\n<li>类中声明了虚函数（不管是1个还是多个），那么在实例化对象时，编译器会自动在对象里安插一个指针vPtr指向虚函数表VTable</li>\n<li>虚继承：涉及到虚函数表和虚基表，会增加一个vfPtr指针指向虚函数表vfTable（多重虚继承下对应多个）；一个vbPtr指针指向虚基表vbTable，这两者所占的空间大小为：8（或8乘以多继承时父类的个数）</li>\n<li>内存对齐</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ol>\n<li>让任意两个对象的内存不同</li>\n<li>标准规定，实现保证</li>\n<li>能保证new出来的都是独一无二的地址</li>\n<li>能保证某些宏内的计算数组大小的算法：<code>#define ARRAY_SIZE((A)) sizeof((A)) / sizeof((A[0]))</code>不会出现除数为0的错误</li>\n</ol>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p><a href=\"https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/\">https://www.geeksforgeeks.org/why-is-the-size-of-an-empty-class-not-zero-in-c/</a></p>\n<p><a href=\"https://stackoverflow.com/questions/2362097/why-is-the-size-of-an-empty-class-in-c-not-zero\">https://stackoverflow.com/questions/2362097/why-is-the-size-of-an-empty-class-in-c-not-zero</a></p>\n<p><a href=\"https://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class\">https://stackoverflow.com/questions/621616/c-what-is-the-size-of-an-object-of-an-empty-class</a></p>\n<p><a href=\"https://blog.csdn.net/qq_22203741/article/details/106797215\">https://blog.csdn.net/qq_22203741/article/details/106797215</a></p>\n<p>该图片由<a href=\"https://pixabay.com/zh/users/mammiya-12752456/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7549449\">Mariya 🌸🌺🌼</a>在<a href=\"https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7549449\">Pixabay</a>上发布</p>\n","categories":["Geek"],"tags":["C++","Developer","Programming","技术"]},{"title":"Algorithms","url":"/post/e67bc23f.html","content":"<p>一些算法思路， 持续更新。。。</p>\n<span id=\"more\"></span>\n\n<p>理解一个算法没有任何意义</p>\n<p>多练多写才是王道（应试角度）</p>\n<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>基于<strong>分治</strong>思想，最难的是划分</p>\n<ol>\n<li>确定分界点</li>\n<li>调整区间</li>\n<li>递归处理左右两边</li>\n</ol>\n<p>有边界问题建议模板 </p>\n<h3 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">quick_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> q[], <span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(l &gt;= r) <span class=\"hljs-keyword\">return</span>; <br>\t<span class=\"hljs-type\">int</span> x = q[l], i = l - <span class=\"hljs-number\">1</span>, j = r + <span class=\"hljs-number\">1</span>;<br>\t<br>\t<span class=\"hljs-keyword\">while</span>(i &lt; j) &#123;<br>\t\t<span class=\"hljs-keyword\">do</span> i++; <span class=\"hljs-keyword\">while</span>(q[i] &lt; x);<br>\t\t<span class=\"hljs-keyword\">do</span> j--; <span class=\"hljs-keyword\">while</span>(q[j] &gt; x);<br>\t\t<span class=\"hljs-keyword\">if</span>(i &lt; j) <span class=\"hljs-built_in\">swap</span>(q[i], q[j]);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">quick_sort</span>(q, l, j);<br>\t<span class=\"hljs-built_in\">quick_sort</span>(q, j + <span class=\"hljs-number\">1</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果在递归函数中用i，注意x不可以取q[l]，否则容易发生死循环</p>\n<p>最开始的边界，如果是在最左侧或者最右侧，然后极端情况下，i与j没有交换过，在边界处相遇，此时下一次递归时，有一个区间会无限递归。比如取x为q[l]，在最左侧，然后i与j都是0，递归时又选择了i，递归区间是[0, -1]和[0, n-1]，无限递归。如果取x为q[r]，在最右侧，i与j都是n-1，递归时选择了j，递归区间为[0, n-1]和[n, n-1]，还是有无限递归。而且即使是x取q[(r+l)&#x2F;2]，也要注意向上向下取整的问题，不能取到某个边界。所以必须一左一右</p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p>基本思想也是分治，最难的是归并</p>\n<ol>\n<li>找分界点（中间）</li>\n<li>递归</li>\n<li>归并 —— 合二为一  O(n)</li>\n</ol>\n<p>利用<strong>双指针</strong>算法，遇到相同的，可以把第一个数组的元素先放进去，因为归并一般是稳定的。快排也可以是稳定的，只要能保证所有元素都不同即可，那如何保证呢？可以把数组的下标也参与到排序中，构建一个二元组，即可保证不同。</p>\n<p>时间复杂度：O(nlogn)</p>\n<h3 id=\"模板-1\"><a href=\"#模板-1\" class=\"headerlink\" title=\"模板\"></a>模板</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">merge_sort</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> q[], <span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(l &gt;= r) <span class=\"hljs-keyword\">return</span>;<br>    <br>    <span class=\"hljs-type\">int</span> mid = (l + r) &gt;&gt; <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">merge_sort</span>(q, l, mid); <span class=\"hljs-comment\">// 闭区间</span><br>    <span class=\"hljs-built_in\">merge_sort</span>(q, mid + <span class=\"hljs-number\">1</span>, r);<br>    <br>    <span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>, i = l, j = mid + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>        <span class=\"hljs-keyword\">if</span>(q[i] &lt;= q[j]) temp[k++] = q[i++];<br>        <span class=\"hljs-keyword\">else</span> temp[k++] = q[j++];<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">while</span>(i &lt;= mid) temp[k++] = q[i++];<br>    <span class=\"hljs-keyword\">while</span>(j &lt;= r) temp[k++] = q[j++];<br>    <br>    <span class=\"hljs-comment\">// target数组 ：q[l...r]</span><br>    <span class=\"hljs-keyword\">for</span> (i = l, j = <span class=\"hljs-number\">0</span>; i &lt;= r; i++, j++) &#123;<br>        q[i] = temp[j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h1><h2 id=\"整数二分\"><a href=\"#整数二分\" class=\"headerlink\" title=\"整数二分\"></a>整数二分</h2><p>本质：有单调性一定可以二分，但是二分的不一定都是单调性。二分的本质是边界。某个性质在左侧满足，右侧不满足，这种边界点就可以二分找到。</p>\n<p>直接上边界，没有边界的只是特殊情况。</p>\n<p>从左到右的最后一个：<code>if(true) l=mid; else r=mid-1</code>，此时mid需要加上1</p>\n<p>从右到左最后一个：<code>if(true) r=mid; else l=mid+1</code>，mid不需要加1.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bsearch_1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (l &lt; r)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> mid = (r - l) / <span class=\"hljs-number\">2</span> + l;<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">check</span>(mid)) r = mid;<br>        <span class=\"hljs-keyword\">else</span> l = mid + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。在于对左值的处理，这里左值的处理是 left = mid。因为正常的left+mid&gt;&gt;1都是向下取整，如果不加上1，left=mid会死循环</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bsearch_2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">while</span> (l &lt; r)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> mid = l + r + <span class=\"hljs-number\">1</span> &gt;&gt; <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-comment\">// int mid = (r - l + 1) / 2 + l;</span><br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">check</span>(mid)) l = mid;<br>        <span class=\"hljs-keyword\">else</span> r = mid - <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>选择模板，看如何更新，根据更新结果去改mid，因为C++<strong>整除都是向下取整</strong>，所以如果更新了l，那么mid需要加1，如果更新的是r，mid就不变。为什么更新l要加1的例子：如果l&#x3D;r-1，算出来mid等于l，如果又true了，那么l&#x3D;mid，区间没变，死循环。</p>\n<p>eg：数的二分，check时，不是单调或者大小，二是性质，先定性质，而不是大小关系（当然大小关系可以作为性质）。比如大于等于x或者小于x，再比如大于x和小于等于x，不同的性质就可二分。但同时也要注意，一个性质取反后并不一定正确，比如想找到小于等于x的最后一个数字，此时不可用大于x的第一个数字作为性质，会多一个。</p>\n<h2 id=\"浮点数二分\"><a href=\"#浮点数二分\" class=\"headerlink\" title=\"浮点数二分\"></a>浮点数二分</h2><p>不需要处理边界，因此更加简单。当区间长度很小时，我们就可以认为找到了答案。区间长度往往比要求的精度再小两个数量级。</p>\n<p>浮点数二分甚至可以直接循环100次。不再管精度，相当于把区间长度除以2的100次方。</p>\n<h1 id=\"高精度\"><a href=\"#高精度\" class=\"headerlink\" title=\"高精度\"></a>高精度</h1><h2 id=\"大整数相加\"><a href=\"#大整数相加\" class=\"headerlink\" title=\"大整数相加\"></a>大整数相加</h2><p>模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; A, vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; B)</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; C;<br>    <br>    <span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; A.<span class=\"hljs-built_in\">size</span>() || i &lt; B.<span class=\"hljs-built_in\">size</span>(); i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(i &lt; A.<span class=\"hljs-built_in\">size</span>()) t+=A[i];<br>        <span class=\"hljs-keyword\">if</span>(i &lt; B.<span class=\"hljs-built_in\">size</span>()) t+=B[i];<br>        <br>        C.<span class=\"hljs-built_in\">push_back</span>(t % <span class=\"hljs-number\">10</span>);<br>        t /= <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">// 进位</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"前缀和-amp-差分\"><a href=\"#前缀和-amp-差分\" class=\"headerlink\" title=\"前缀和&amp;差分\"></a>前缀和&amp;差分</h1><h2 id=\"前缀和\"><a href=\"#前缀和\" class=\"headerlink\" title=\"前缀和\"></a>前缀和</h2><h3 id=\"一维\"><a href=\"#一维\" class=\"headerlink\" title=\"一维\"></a>一维</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">s[i] = a[<span class=\"hljs-number\">1</span>] + a[<span class=\"hljs-number\">2</span>] +...+a[i];<br></code></pre></td></tr></table></figure>\n\n<p>如何求S[i]：for循环</p>\n<p>作用：快速求出原数组中一段数字的和，基本也是唯一的应用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">S[r] - S[l<span class=\"hljs-number\">-1</span>] = Sum[l, r]<br></code></pre></td></tr></table></figure>\n\n<p>tips：<strong>S[0] &#x3D; 0</strong>，好处：方便处理边界。不仅求区间和，也能求前缀和。</p>\n<h3 id=\"二维\"><a href=\"#二维\" class=\"headerlink\" title=\"二维\"></a>二维</h3><p>求前缀和：二维矩阵。</p>\n<p><code>s[i][j]</code>如何计算：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">s[i][j] = s[i - <span class=\"hljs-number\">1</span>][j] + s[i][j - <span class=\"hljs-number\">1</span>] - s[i - <span class=\"hljs-number\">1</span>][j - <span class=\"hljs-number\">1</span>] + a[i][j];<br></code></pre></td></tr></table></figure>\n\n<p>用前缀和，子矩阵内所有元素的和：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">s[x2][y2] - s[x1 - <span class=\"hljs-number\">1</span>][y2] - s[x2][y1 - <span class=\"hljs-number\">1</span>] + s[x1 - <span class=\"hljs-number\">1</span>][y1 - <span class=\"hljs-number\">1</span>];<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"差分\"><a href=\"#差分\" class=\"headerlink\" title=\"差分\"></a>差分</h2><p>前缀和逆运算</p>\n<p>给定a数组，构造一个数组b，使得给定数组是该数组的前缀和。</p>\n<p>差分主要应对的场景：对于给定A数组一段区间的元素，统一进行加或减的操作，将O(n)变为O(1)</p>\n<p>【l，r】区间中加c，则令<code>b[l] += c, b[r + 1] -= c</code>，从而达到修改原数组的效果。等到用原数组的时候再O(n)改回原数组。</p>\n<p>差分<strong>没有构造</strong>的过程，可以认为a和b初始都是0，每一个初始值都可以认为是在[x, x]这个长度为1的区间加上c。也就是只有一个操作。</p>\n<h3 id=\"一维模板\"><a href=\"#一维模板\" class=\"headerlink\" title=\"一维模板\"></a>一维模板</h3><p>构造：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l, <span class=\"hljs-type\">int</span> r, <span class=\"hljs-type\">int</span> c)</span> </span>&#123;<br>    b[l] += c;<br>    b[r + <span class=\"hljs-number\">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>改回：</p>\n<p>（所有b依次加起来是对应位置的a）</p>\n<p><code>a[i] = b[i] + a[i - 1];</code></p>\n<h3 id=\"二维模板\"><a href=\"#二维模板\" class=\"headerlink\" title=\"二维模板\"></a>二维模板</h3><p>核心操作：以（x1, y1）为左上角，（x2，y2）为右下角的子矩阵的所有数同时加上C。</p>\n<p>构造：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x1, <span class=\"hljs-type\">int</span> y1, <span class=\"hljs-type\">int</span> x2, <span class=\"hljs-type\">int</span> y2, <span class=\"hljs-type\">int</span> c)</span> </span>&#123;<br>    b[x1][y1] += c;<br>    b[x1][y2 + <span class=\"hljs-number\">1</span>] -= c;<br>    b[x2][y1 + <span class=\"hljs-number\">1</span>] -= c;<br>    b[x2 + <span class=\"hljs-number\">1</span>][y2 + <span class=\"hljs-number\">1</span>] += c;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>改回：(b是相邻元素的差，因此用所有b加起来是a，而且要分开，使得b元素更新，不然下一次用的还是旧的)</p>\n<p><code>a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + b[i][j];</code></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><p>一般两大类，一类单线双向奔赴（快速排序），一类双线单向（归并排序），还有单线单向（一般借助单调性）</p>\n<p>所有双指针算法都是O(n) , 能够将n方优化到O(n)</p>\n<p>模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>, j = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>    <span class=\"hljs-keyword\">while</span>(j &lt; n &amp;&amp; <span class=\"hljs-built_in\">check</span>(i, j)) j++;<br>    <br>    <span class=\"hljs-comment\">// other logic</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>一般都可以先从暴力开始，寻找是否有单调关系。单调性在于：当i向一个方向变化时，j是否只可能向一个方向变化，能够证明这点，基本就可以双指针。</p>\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h2 id=\"常见操作：\"><a href=\"#常见操作：\" class=\"headerlink\" title=\"常见操作：\"></a>常见操作：</h2><ul>\n<li>求第k位：<code>n &gt;&gt; k &amp; 1</code></li>\n<li>返回x的最后一位1，<code>Lowbit(x) = x &amp; (-x)</code></li>\n<li>lowbit的常见用法：求1的个数</li>\n</ul>\n<h2 id=\"为什么用补码：\"><a href=\"#为什么用补码：\" class=\"headerlink\" title=\"为什么用补码：\"></a>为什么用补码：</h2><p>计算机里面没有减法，我们是用加法做减法。</p>\n<p>一个数的负数，应该满足的是<code>x + (-x) = 0</code>，所以<code>-x = 0 - x</code>，在用0减去x的时候我们需要在最前面借一位1，变成1000.000减去x，也就等价于x取反后再加1。</p>\n<h1 id=\"离散化\"><a href=\"#离散化\" class=\"headerlink\" title=\"离散化\"></a>离散化</h1><p>有些数据本身很大， 自身无法作为数组的下标保存对应的属性。如果这时只是需要这堆数据的相对属性， 那么可以对其进行离散化处理。当数据只与它们之间的<strong>相对大小</strong>有关，而与具体是多少无关时，可以进行离散化。</p>\n<p>难点：</p>\n<ul>\n<li>去重</li>\n<li>如何算出离散化后的值（二分）</li>\n</ul>\n<p>Essentially, we map the original number to a value which is the index of the discretization array. And the mapping rule is based on the order of the number.</p>\n<p>离散化的本质是将<code>数字本身key</code>映射为它在数组中的索引<code>index</code>。所以通过二分求索引（value -&gt; index)是离散化的本质。二分时，求的是数字离散化后将会在哪里，也就是下标。比如一个数组是[1, 5, 100, 2000]，通过二分，左边界是0，右边界是大小，我们将数字映射成他在数组中的大小顺序，也就是1，2，3，4。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">discretize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, r = alls.<span class=\"hljs-built_in\">size</span>();<br><br>    <span class=\"hljs-keyword\">while</span> (l &lt; r)<br>    &#123;<br>        <span class=\"hljs-type\">int</span> mid = (r - l) / <span class=\"hljs-number\">2</span> + l;<br>        <span class=\"hljs-keyword\">if</span> (alls[mid] &gt;= x)<br>            r = mid;<br>        <span class=\"hljs-keyword\">else</span><br>            l = mid + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> r + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// plus one because we want to map original data to [1...n]</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>每种数据结构都有自己的特点，优点或缺点，而我们使用数据结构一般都是看中了它<strong>能快速地支持某种操作</strong>。</p>\n<h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><p>结构体加指针效率较低，尤其是new节点，一般十万个节点，平时笔试一般不会动态链表的方式，直接上数组。</p>\n<p>数组模拟单链表（应用的较多的是邻接表（n个链表），邻接表最多的用处又是存储图和树，这样是用单链表做的）</p>\n<p>模拟双链表，用来优化某些问题。</p>\n<h2 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span><br><span class=\"hljs-type\">int</span> head, e[N], ne[N], idx;<br><br><span class=\"hljs-comment\">// 初始化</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    head = <span class=\"hljs-number\">-1</span>;<br>    idx = <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 在链表头插入一个数a</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>&#125;<br><br><span class=\"hljs-comment\">// 将头结点删除，需要保证头结点存在</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// add x after k</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> k, <span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    e[idx] = x;<br>    r[idx] = r[k];<br>    l[idx] = k;<br>    l[r[k]] = idx;<br>    r[k] = idx;<br>    idx++;<br>&#125;<br><br><span class=\"hljs-comment\">// remove the k-th number</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> k)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    r[l[k]] = r[k];<br>    l[r[k]] = l[k];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><strong>邻接表</strong>：把每个点的临边保存下来，就是n个单链表，可以用来保存图和树</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><p>数组模拟比STL的好处：快</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N;<br><span class=\"hljs-type\">int</span> stack[N], top;<br><br><span class=\"hljs-comment\">// add element</span><br>stack[++top] = x;<br><br><span class=\"hljs-comment\">//remove element</span><br>top--;<br><br><span class=\"hljs-comment\">// is empty</span><br><span class=\"hljs-keyword\">if</span>(top &gt; <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">not</span> empty<br><span class=\"hljs-keyword\">else</span> empty<br><br><span class=\"hljs-comment\">// top</span><br>stack[top]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N;<br><span class=\"hljs-type\">int</span> queue[N], head, tail = <span class=\"hljs-number\">-1</span>;<br><br><span class=\"hljs-comment\">// insert element</span><br>q[ ++ tail] = x;<br><br><span class=\"hljs-comment\">// pop element</span><br>head++;<br><br><span class=\"hljs-comment\">// is empty</span><br><span class=\"hljs-keyword\">if</span>(head &lt;= tail) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span><br><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br><br><span class=\"hljs-comment\">// get head</span><br>queue[head];<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h1><p>常见的只有一类题型</p>\n<p>给定一个序列，找到每一个数的左边比他小的 离他最近的数（或者右边）</p>\n<p>同样先尝试暴力，然后抽象</p>\n<p>随着<code>i</code>向右移动，<code>j</code>向左移动，我们可以把<code>i</code>左边所有的数字放到一个栈里，然后遍历这个栈，（从栈顶开始）。</p>\n<p>那么这个栈有什么性质？或者说栈中是否有一些元素，他们永远不可能被输出？——如果<code>x</code>与<code>y</code>都在栈中，x在前，y在后，且y更小，那么x后续便不会被输出，所以栈中没有逆序对（x&lt;y 且 a[x] &gt; a[y]），也就是单调的了</p>\n<p>每个元素只有一次进栈与出栈，因此复杂度是2n</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span> tt = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">auto</span> x : a) &#123;<br>    <span class=\"hljs-keyword\">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt--;<br>    stk[++top] = x;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h1><p>滑动窗口里面的最大值和最小值</p>\n<p>先暴力，发现找最大值最小值是O(k)的复杂度，然后我们看看能不能转变成O(1)的复杂度（通过单调性，把没用的元素删掉），挖掘要点，转变</p>\n<p>取最值的话是端点，找一个值可以二分</p>\n<p>窗口是用队列去维护的，看看哪些元素是没用的</p>\n<p>找最大值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N;<br><span class=\"hljs-type\">int</span> a[N], q[N];<br><br><span class=\"hljs-comment\">// 最小值</span><br><span class=\"hljs-type\">int</span> hh = <span class=\"hljs-number\">0</span>, tt = <span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class=\"hljs-comment\">// add a element to q</span><br>    <span class=\"hljs-comment\">// q[hh]是窗口起点下标，如果太小，说明头该出去了</span><br>    <span class=\"hljs-keyword\">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class=\"hljs-number\">1</span>) hh++;<br>    <span class=\"hljs-comment\">// 缩小其实是从后向前缩小</span><br>    <span class=\"hljs-keyword\">while</span> (hh &lt;= tt &amp;&amp; a[i] &lt;= a[q[tt]]) tt--;<br>    <br>    q[++tt] = i; <span class=\"hljs-comment\">// 先加进去，因为i可能是最小值（唯一的）</span><br>    <span class=\"hljs-keyword\">if</span>(i &gt;= k - <span class=\"hljs-number\">1</span>) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, a[q[hh]]);<span class=\"hljs-comment\">//minimum</span><br>\t<br>    <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 最大值</span><br>hh = <span class=\"hljs-number\">0</span>, tt = <span class=\"hljs-number\">-1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++)<br>&#123;<br>    <span class=\"hljs-keyword\">if</span>(hh &lt;= tt &amp;&amp; q[hh] &lt; i - k + <span class=\"hljs-number\">1</span>) hh++;<br>    <br>    <span class=\"hljs-keyword\">while</span>(hh &lt;= tt &amp;&amp; a[i] &gt;= a[q[tt]]) tt--;<br>    <br>    q[++tt] = i;<br>    <br>    <span class=\"hljs-keyword\">if</span>(i &gt;= k - <span class=\"hljs-number\">1</span>) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, a[q[hh]]);<br>&#125;<br><br><span class=\"hljs-comment\">// 实际上是双端队列</span><br></code></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li>暴力算法怎么做</li>\n<li>如何优化</li>\n</ul>\n<h1 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h1><p>快速存储字符串集合的数据结构</p>\n<p>Trie树一般字符不多，要么全大写要么全小写</p>\n<p>模板：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N;<br><span class=\"hljs-type\">int</span> son[N][<span class=\"hljs-number\">26</span>]; <span class=\"hljs-comment\">// 存储树中每个节点的子节点</span><br><span class=\"hljs-type\">int</span> cnt[N]; <span class=\"hljs-comment\">// 每个元素的出现次数（统计词频）</span><br><span class=\"hljs-type\">int</span> idx; <span class=\"hljs-comment\">// 为每个元素赋一个编号</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(string str)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 第几层</span><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> ch : str) &#123;<br>        <span class=\"hljs-type\">int</span> x = ch - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>        <span class=\"hljs-keyword\">if</span> (son[p][x] == <span class=\"hljs-number\">0</span>) son[p][x] = ++idx;<br>        p = son[p][x];<br>    &#125;<br>    cnt[p]++;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(string str)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> p = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> ch : str) &#123;<br>        <span class=\"hljs-type\">int</span> x = ch - <span class=\"hljs-string\">&#x27;a&#x27;</span>;<br>        <span class=\"hljs-keyword\">if</span> (son[p][x] == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>        p = son[p][x];<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> cnt[p];<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><p><strong>思路精巧，代码比较短，很受面试官喜欢</strong></p>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>并查集用来：</p>\n<ul>\n<li>将两个集合合并</li>\n<li>询问两个元素是否在一个集合中</li>\n</ul>\n<p>并查集能以近乎O(1)的复杂度中实现。</p>\n<p>用树的形式维护集合，树根节点的编号就是集合的编号。每个节点存储他的父节点。p[x] 表示x的父节点。</p>\n<h2 id=\"使用操作\"><a href=\"#使用操作\" class=\"headerlink\" title=\"使用操作\"></a>使用操作</h2><ul>\n<li><p>判断树根：<code>p[x] == x</code></p>\n</li>\n<li><p>求x的集合编号：<code>while(p[x] != x) x=p[x]; </code></p>\n</li>\n<li><p>求x与y 是否在一个集合中：分别求编号</p>\n</li>\n<li><p>合并集合：把一个树根放到另一个树上即可</p>\n</li>\n</ul>\n<h2 id=\"优化——路径压缩\"><a href=\"#优化——路径压缩\" class=\"headerlink\" title=\"优化——路径压缩\"></a>优化——路径压缩</h2><p>求编号的优化（之前是与树的高度成正比，需要n的循环）</p>\n<p>如何优化：一旦找到某条路径的根节点，我们就把这条路上所有的节点都指向根节点。这样每一个点，最多走n步，之后每次都是一步。</p>\n<p>模板</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (p[x] != x) p[x] = <span class=\"hljs-built_in\">find</span>(x); <span class=\"hljs-comment\">// 这里既递归处理，同时也有路径优化</span><br>    <span class=\"hljs-keyword\">return</span> p[x];<br>&#125;<br><br><span class=\"hljs-comment\">// merge set a and set b</span><br>p[<span class=\"hljs-built_in\">find</span>(x)] = <span class=\"hljs-built_in\">find</span>(b);<br><br><span class=\"hljs-comment\">// Query a and b</span><br><span class=\"hljs-built_in\">find</span>(a) = = <span class=\"hljs-built_in\">find</span>(b);<br></code></pre></td></tr></table></figure>\n\n<p>加上当前集合有多少元素（附加操作）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// when merge</span><br>size[<span class=\"hljs-built_in\">find</span>(b)] += size[<span class=\"hljs-built_in\">find</span>(a)];<br>p[<span class=\"hljs-built_in\">find</span>(x)] = <span class=\"hljs-built_in\">find</span>(b);<br><br><span class=\"hljs-comment\">//之后直接返回size[find(a)]即可找到当前集合元素的个数</span><br></code></pre></td></tr></table></figure>\n\n<p>加上距离根节点的距离信息</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> p[N], d[N];<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(p[x] != x) &#123;<br>        <span class=\"hljs-type\">int</span> par = <span class=\"hljs-built_in\">find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = par;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> p[x];<br>&#125;<br><span class=\"hljs-comment\">// 初始化时d[i] = 0</span><br><br><span class=\"hljs-comment\">// 合并时</span><br>p[<span class=\"hljs-built_in\">find</span>(a)] = <span class=\"hljs-built_in\">find</span>(b); <span class=\"hljs-comment\">// a加入b</span><br>d[<span class=\"hljs-built_in\">find</span>(a)] = distance; <span class=\"hljs-comment\">// 根据具体问题，初始化find(a) 偏移量</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>堆是一个完全二叉树，使用数组存储</p>\n<p>两个基本操作：<code>down(x)</code> —— 往下调整， <code>up(x)</code> —— 往上调整</p>\n<p><strong>背景：小根堆</strong></p>\n<p>如果把一个数字变大了，那么我们应该把数字向下移动——down操作</p>\n<p>如果把一个数字变小了，那么我们应该把数字向上走——up操作</p>\n<p><strong>注意堆的下标从1开始，因为如果从0开始，但是0的左儿子还是0，冲突</strong></p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ul>\n<li>插入一个数 : <code>heap[++ size] = x; up(x);</code></li>\n<li>求最小值 : <code>heap[1];</code></li>\n<li>删除最小值 : <code>heap[1] = heap[size]; size--; down(1);</code></li>\n<li>删除k处 : <code>heap[k] = heap[size]; size--; down(k); up(k);</code></li>\n<li>修改任何一个元素 : <code>heap[k] = x; down(k); up(k); </code>可能变大变小，于是我们就都做一遍，注意这两个函数实际只会执行一个。</li>\n<li>（后两个STL中没有）</li>\n</ul>\n<p>建立堆：一个一个插是nlogn，我们可以实现n。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = size / <span class=\"hljs-number\">2</span>; i ; i--) <span class=\"hljs-built_in\">down</span>(i);<br><span class=\"hljs-comment\">// 最下一层不用down</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"down\"><a href=\"#down\" class=\"headerlink\" title=\"down\"></a>down</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> h[N];<br><span class=\"hljs-type\">int</span> size;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">down</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> t = u; <span class=\"hljs-comment\">// u is original </span><br>    <span class=\"hljs-keyword\">if</span>(u * <span class=\"hljs-number\">2</span> &lt;= size &amp;&amp; h[u * <span class=\"hljs-number\">2</span>] &lt; h[t]) t = u * <span class=\"hljs-number\">2</span>;<br>    <span class=\"hljs-keyword\">if</span>(u * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span> &lt;= size &amp;&amp; h[u * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>] &lt; h[t]) t = u * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">if</span>(u != t)<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(h[u], h[t]);<br>        <span class=\"hljs-built_in\">down</span>(t); <span class=\"hljs-comment\">// 大的换到了t，继续down(t)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"up\"><a href=\"#up\" class=\"headerlink\" title=\"up\"></a>up</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">up</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(u / <span class=\"hljs-number\">2</span> &amp;&amp; h[u] &lt; h[u / <span class=\"hljs-number\">2</span>])<br>    &#123;<br>        <span class=\"hljs-built_in\">swap</span>(h[u], h[u / <span class=\"hljs-number\">2</span>]);<br>        u /= <span class=\"hljs-number\">2</span>;<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">// 更简单，因为up只有一个父节点</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"idx\"><a href=\"#idx\" class=\"headerlink\" title=\"idx\"></a>idx</h1><p>不管是链表，Trie树还是堆，他们的基本单元都是一个个结点连接构成的，可以成为“链”式结构。这个结点包含两个基本的属性：本身的值和指向下一个结点的指针。按道理，应该按照结构体的方式来实现这些数据结构的，但是用数组模拟，主要是因为比较快。</p>\n<p>原来这两个属性都是以结构体的方式联系在一起的，现在如果用数组模拟，如何才能把这两个属性联系起来呢，如何区分各个结点呢？</p>\n<p>idx的操作总是++idx，这就保证了不同的idx值对应不同的结点，这样就可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。</p>\n<p>对于<strong>单链表</strong>，利用idx联系结构体本身的值和next指针，因此e[idx]可以作为结点的值，ne[idx]可以作为next指针。同理可以理解双链表。</p>\n<p><strong>Trie树</strong>中有个二维数组 son[N] [26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗<strong>多叉树</strong>，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：<strong>son[1] [0]&#x3D;2表示1结点的一个值为a的子结点为结点2</strong>;如果son[1] [0] &#x3D; 0，则意味着没有值为a子结点。这里的son[N] [26]相当于链表中的ne[N]。</p>\n<p><strong>堆</strong>中的每次插入都是在堆尾，但是堆中经常有up和down操作。所以结点与结点的关系并不是用一个ne[idx] [2]可以很好地维护的。但是好在堆是个完全二叉树。子父节点的关系可以通过下标来联系（左儿子2n，右儿子2n+1）。就数组模拟来说，知道数组的下标就知道结点在堆中的位置。所以核心就在于即使有down和up操作也能维护堆数组的下标（k）和结点（idx）的映射关系。 </p>\n<h1 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h1><h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>map，将一个大的集合空间，映射到从0到n的一个较小区间内。</p>\n<p>实现快速添加与查找某个数</p>\n<p>但可能会出现冲突，根据处理冲突的不同，分为两种：开放寻址与拉链法</p>\n<h2 id=\"存储结构\"><a href=\"#存储结构\" class=\"headerlink\" title=\"存储结构\"></a>存储结构</h2><h3 id=\"开放寻址法\"><a href=\"#开放寻址法\" class=\"headerlink\" title=\"开放寻址法\"></a>开放寻址法</h3><p>不断找下一个可以允许的地方，找到目标地址后，不断向后看</p>\n<p>只开一个一维数组，但要原数组的两到三倍，一般能够把冲突降低到比较小</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">find</span><span class=\"hljs-params\">(x)</span> <span class=\"hljs-comment\">// 如果找到x，返回下标，如果没有，返回应该存储的位置</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> k = (x % N + N) % N;<br>    <span class=\"hljs-keyword\">while</span>(h[k] != null &amp;&amp; h[k] != x) &#123;<br>        k++;<br>        <span class=\"hljs-keyword\">if</span>(k == N) k = <span class=\"hljs-number\">0</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> k;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>注：</p>\n<p>设置一个常量用来代表“无穷大”。</p>\n<p>比如对于int类型的数，采用INT_MAX，即0x7fffffff作为无穷大。但是以INT_MAX为无穷大，加一个正数会溢出。</p>\n<p>所以常采用0x3f3f3f3f来作为无穷大。0x3f3f3f3f主要有如下好处：</p>\n<ul>\n<li>0x3f3f3f3f的十进制为1061109567，和INT_MAX一个数量级，即10^9数量级，而一般场合下的数据都是小于10^9的。</li>\n<li>0x3f3f3f3f * 2 &#x3D; 2122219134，无穷大相加依然不会溢出。</li>\n<li>可以使用memset(array, 0x3f, sizeof(array))来为数组设初值为0x3f3f3f3f，因为这个数的每个字节都是0x3f。</li>\n</ul>\n<h3 id=\"拉链法\"><a href=\"#拉链法\" class=\"headerlink\" title=\"拉链法\"></a>拉链法</h3><p>第一次映射后得到的其实是链表，每个槽是一个链（单链表），期望链的长度是1</p>\n<p>其实也就是邻接表，在存储图的时候也是用这个方法</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> h[N], e[N], ne[N], idx = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> k = (x % N + N) % N; <span class=\"hljs-comment\">// N一般是一个质数，大于最大范围的质数</span><br>    e[idx] = x;<br>    ne[idx] = h[k];<br>    h[k] = idx++;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">query</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> k = (x % N + N) % N;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[k]; i != <span class=\"hljs-number\">-1</span>; i = ne[i]) &#123;<br>        <span class=\"hljs-keyword\">if</span>(e[i] == x) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"字符串哈希\"><a href=\"#字符串哈希\" class=\"headerlink\" title=\"字符串哈希\"></a>字符串哈希</h2><p>将字符串看作p进制数，转换成数字，但是数字可能比较大，再去取模</p>\n<ul>\n<li>不能映射成0（A和AA一样）</li>\n<li>p&#x3D;131或者13331，Q等于2的64次方，可以假定没有冲突。2的64次方，刚好是无符号long long的大小，所以我们会发现不用取模，直接计算。每次溢出的时候，就等价于模2的64次方</li>\n<li>前缀哈希，可以获得子串哈希值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> ULL;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N;<br>ULL h[N], p[N];<br><br><span class=\"hljs-comment\">// !!! notice p[0] = 1</span><br>p[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>    p[i] = p[i - <span class=\"hljs-number\">1</span>] * P; <span class=\"hljs-comment\">// 位权</span><br>&#125;<br><br><span class=\"hljs-function\">ULL <span class=\"hljs-title\">hash</span><span class=\"hljs-params\">(string str)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>        h[i] = h[i - <span class=\"hljs-number\">1</span>] * P + str[i];<br>    &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// str1 == str2</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">equal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> l1, <span class=\"hljs-type\">int</span> r1, <span class=\"hljs-type\">int</span> l2, <span class=\"hljs-type\">int</span> r2)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> h[r1] - h[l1] * p[r1 - l1 + <span class=\"hljs-number\">1</span>] == h[r2] - h[l2] * p[r2 - l2 + <span class=\"hljs-number\">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"STL\"><a href=\"#STL\" class=\"headerlink\" title=\"STL\"></a>STL</h1><p>公共的：size，empty，clear（队列无）</p>\n<p>系统分配空间时，所需的时间与空间大小无关，与申请次数有关。因此vector采用倍增。不够的时候，再申请两倍，然后把之前的copy过来。如果申请n个元素，第一次copy1个，然后2个，4个，8个，最后到了n&#x2F;2个，<strong>申请次数是logn</strong>，但copy次数均摊下来每个元素都近似O(1)</p>\n<h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><p><code>front, back, push_back, pop_back</code></p>\n<p>支持比较运算</p>\n<h2 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h2><p>二元组，两种属性，且需要排序</p>\n<p>相当于两个变量的结构体加上一个比较函数</p>\n<h2 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h2><ul>\n<li>substr：begin and length</li>\n<li>c_str: char array</li>\n</ul>\n<h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><p><code>push pop back front</code></p>\n<h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2><p><code>push top pop</code></p>\n<p>用堆实现，默认大根堆。如何小根堆</p>\n<ul>\n<li>插入时插入-x，取出时再变成原来的数字</li>\n<li>定义时：<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt;</code></li>\n</ul>\n<h2 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h2><p><code>push pop top</code></p>\n<h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><p><code>front back push_back pop_back push_front pop_front []</code></p>\n<h2 id=\"set-x2F-multiset\"><a href=\"#set-x2F-multiset\" class=\"headerlink\" title=\"set&#x2F;multiset\"></a>set&#x2F;multiset</h2><p><code>insert find count erase</code></p>\n<ul>\n<li>erase : 参数为x：删除所有x；参数为迭代器，删一个</li>\n<li>lower_bound：返回大于等于x的最小的数</li>\n<li>upper_bound：返回大于x的最小的数</li>\n</ul>\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><p>根据索引取值—— [ ] – 时间复杂度是logn</p>\n<h2 id=\"无序家族\"><a href=\"#无序家族\" class=\"headerlink\" title=\"无序家族\"></a>无序家族</h2><p>基本都是O1，但不支持lower_bound，upper_bound（因为无序），++，–</p>\n<h1 id=\"DFS-amp-BFS\"><a href=\"#DFS-amp-BFS\" class=\"headerlink\" title=\"DFS &amp; BFS\"></a>DFS &amp; BFS</h1><p>DFS空间需要O(h) , 与树高度成正比。BFS空间则是2的h次方，但是BFS有最短路的概念，能够用于找最短的东西。</p>\n<h2 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h2><p>每个DFS都一定对应一个搜索树</p>\n<p><strong>关键是想清楚顺序</strong>，两个要点：回溯（恢复现场）和剪枝</p>\n<h3 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(u == n) &#123;<br>        <span class=\"hljs-keyword\">for</span>() <span class=\"hljs-comment\">// output</span><br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123; <span class=\"hljs-comment\">// 树横向扩</span><br>        <span class=\"hljs-keyword\">if</span>(!st[i]) &#123; <span class=\"hljs-comment\">// unused</span><br>            path[u] = i;<br>            st[i] = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-built_in\">dfs</span>(u + <span class=\"hljs-number\">1</span>);<br>            st[i] = <span class=\"hljs-literal\">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"八皇后\"><a href=\"#八皇后\" class=\"headerlink\" title=\"八皇后\"></a>八皇后</h3><p>多种思路</p>\n<p>如果分析出每一行只可能会有一个皇后，那么唯一的变数就是皇后在每一行的位置了（也就是列），所以可以使用全排列的思路做，大小为n的全排列（以行为单位枚举）</p>\n<p>时间复杂度为n乘以n的阶乘</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(u == n) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, chess[i]);<br>            <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>        &#125;<br>        <span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;&quot;</span>);<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++) &#123; <span class=\"hljs-comment\">// i is col</span><br>        <span class=\"hljs-comment\">// [u, i]这个点在哪条对角线上面</span><br>        <span class=\"hljs-keyword\">if</span>(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n + u - i]) &#123;<br>            chess[u][i] = <span class=\"hljs-string\">&#x27;Q&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class=\"hljs-literal\">true</span>;<br>            <span class=\"hljs-built_in\">dfs</span>(u + <span class=\"hljs-number\">1</span>);<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class=\"hljs-literal\">false</span>;<br>            chess[u][i] = <span class=\"hljs-string\">&#x27;.&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>但也可以<strong>格子为单位</strong>去枚举，每一个格子都有放和不放两种可能</p>\n<p>时间复杂度为2的n方次方</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> s)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span>(y == n) y = <span class=\"hljs-number\">0</span>, x++; <span class=\"hljs-comment\">// next line</span><br>    <span class=\"hljs-comment\">// 代替了二重循环的格式</span><br>    <br>    <span class=\"hljs-keyword\">if</span>(x == n) &#123;<br>        <span class=\"hljs-keyword\">if</span>(s == n) &#123;<br>            <span class=\"hljs-comment\">// print</span><br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-built_in\">dfs</span>(x, y + <span class=\"hljs-number\">1</span>, s); <span class=\"hljs-comment\">// 不放</span><br>    <br>    <span class=\"hljs-comment\">// 放</span><br>    <span class=\"hljs-keyword\">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[n + x - y]) &#123;<br>        chess[x][y] = <span class=\"hljs-string\">&#x27;Q&#x27;</span>;<br>        row[x] = col[y] = dg[x + y] = udg[n + x - y] = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-built_in\">dfs</span>(x, y + <span class=\"hljs-number\">1</span>, s + <span class=\"hljs-number\">1</span>);<br>        row[x] = col[y] = dg[x + y] = udg[n + x - y] = <span class=\"hljs-literal\">false</span>;<br>        chess[x][y] = <span class=\"hljs-string\">&#x27;.&#x27;</span>;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h2><p>dp问题和最短路问题其实是互通的，dp是一种特殊的最短路问题（无环存在的最短路问题）</p>\n<p>边权为1 时，BFS才能做最短路</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    queue q;<br>    q.<span class=\"hljs-built_in\">push</span>(init);<br>    <br>    <span class=\"hljs-keyword\">while</span>(!q.<span class=\"hljs-built_in\">empty</span>())<br>    &#123;<br>        <span class=\"hljs-keyword\">auto</span> h = q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        <span class=\"hljs-comment\">// extense other data</span><br>        q.<span class=\"hljs-built_in\">push</span>(xxxxx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Tree-amp-Graph\"><a href=\"#Tree-amp-Graph\" class=\"headerlink\" title=\"Tree &amp; Graph\"></a>Tree &amp; Graph</h1><p>树是一种特殊的图，无环连通图</p>\n<p>图：有向图和无向图（无向图是特殊的有向图）</p>\n<p>邻接矩阵储存（不常用）</p>\n<h2 id=\"邻接表\"><a href=\"#邻接表\" class=\"headerlink\" title=\"邻接表\"></a>邻接表</h2><p>每个节点都是单链表</p>\n<p><code>tip：输入超过1M的时候cin和scanf才有区别</code></p>\n<p>树和图的深度优先遍历和宽度优先遍历，是一种特殊的深度优先搜索和宽度优先搜索。</p>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = <span class=\"hljs-number\">10e5</span>;<br><span class=\"hljs-type\">int</span> h[N], e[N * <span class=\"hljs-number\">2</span>], ne[N * <span class=\"hljs-number\">2</span>];<br><span class=\"hljs-type\">bool</span> st[N]; <span class=\"hljs-comment\">// flag</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    st[u] = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// been searched</span><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[u]; i != - <span class=\"hljs-number\">1</span>; i = ne[i]) &#123; <span class=\"hljs-comment\">// u的所有出边</span><br>        <span class=\"hljs-type\">int</span> j = e[i];<br>        <span class=\"hljs-keyword\">if</span>(!st[j]) <span class=\"hljs-built_in\">dfs</span>(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"广度优先\"><a href=\"#广度优先\" class=\"headerlink\" title=\"广度优先\"></a>广度优先</h2><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">// 求最短路（需要权重为1）</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bfs</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(d, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-keyword\">sizeof</span> d);<br>    d[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>    <br>    queue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-keyword\">while</span>(q.<span class=\"hljs-built_in\">size</span>())<br>    &#123;<br>        <span class=\"hljs-type\">int</span> t = q.<span class=\"hljs-built_in\">front</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        <br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[t]; i != <span class=\"hljs-number\">-1</span>; i = ne[i]) &#123;<br>            <span class=\"hljs-type\">int</span> j = e[i];<br>            <span class=\"hljs-keyword\">if</span>(d[j] == <span class=\"hljs-number\">-1</span>) &#123;<br>                d[j] = d[t] + <span class=\"hljs-number\">1</span>;<br>                q.<span class=\"hljs-built_in\">push</span>(j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> d[n];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"图宽搜的应用-拓扑排序\"><a href=\"#图宽搜的应用-拓扑排序\" class=\"headerlink\" title=\"图宽搜的应用 - 拓扑排序\"></a>图宽搜的应用 - 拓扑排序</h2><p>求有向图的拓扑排序</p>\n<p>拓扑序列所有边都是从前指向后面的。因此有环图不可能有拓扑序列。</p>\n<p>有向无环图 &#x3D; 拓扑图</p>\n<p>入度、出度。</p>\n<p>因此所有入度为0的点都可以作为起点</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">d[N]; <span class=\"hljs-comment\">// ru du</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">topo_sort</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> hh = <span class=\"hljs-number\">0</span>, tt =<span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>        <span class=\"hljs-keyword\">if</span>(d[i] == <span class=\"hljs-number\">0</span>) q[++tt] = i;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">while</span>(hh &lt;= tt) &#123;<br>        <span class=\"hljs-type\">int</span> t = q[hh++];<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[t]; i != <span class=\"hljs-number\">-1</span>; i++) &#123;<br>            <span class=\"hljs-type\">int</span> j = e[i];<br>            <span class=\"hljs-keyword\">if</span>(--d[j] == <span class=\"hljs-number\">0</span>) &#123;<br>                q[++tt] = j;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> tt == n - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// tt start from 0, when tt is n - 1, all points have entered the queue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"最短路\"><a href=\"#最短路\" class=\"headerlink\" title=\"最短路\"></a>最短路</h1><p>不证明算法的正确性，考察问题抽象，使得原问题变成一个最短路问题，抽象边与顶点</p>\n<p>图论侧重于实现，不在于原理</p>\n<h2 id=\"单源最短路\"><a href=\"#单源最短路\" class=\"headerlink\" title=\"单源最短路\"></a>单源最短路</h2><p>源：起点，汇：终点</p>\n<p>n: 顶点数量，m：边数量</p>\n<p>稠密图：m是n^2级别</p>\n<p>稀疏图：m与n是一个级别</p>\n<h3 id=\"无负权\"><a href=\"#无负权\" class=\"headerlink\" title=\"无负权\"></a>无负权</h3><h4 id=\"朴素Dijkstra算法\"><a href=\"#朴素Dijkstra算法\" class=\"headerlink\" title=\"朴素Dijkstra算法\"></a>朴素Dijkstra算法</h4><p>O(n^2), 与边无关，适应于<strong>稠密图</strong>（存储用邻接矩阵），边多</p>\n<p>伪代码：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><code class=\"hljs py\"><span class=\"hljs-number\">1.</span> dist[src] = <span class=\"hljs-number\">0</span>, dist[other] = +infinite<br>\ts：当前已经确定最短距离的点的集合<br><span class=\"hljs-number\">2.</span> <span class=\"hljs-keyword\">for</span> v : i —&gt; n<br>\t\tt =  不在s中的距离最近的点<br>    \t把t加入到s中<br>        用t更新其他点的距离<br></code></pre></td></tr></table></figure>\n\n<p><strong>基于贪心思想</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">dijkstra</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">0x3f</span>, <span class=\"hljs-keyword\">sizeof</span> dist);<br>    dist[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// node start from 1</span><br>    <br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i++ )&#123;<br>        <span class=\"hljs-type\">int</span> min_dist = <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; j++) &#123;<br>            <span class=\"hljs-keyword\">if</span>(!st[j] &amp;&amp; (min_dist == <span class=\"hljs-number\">-1</span> || dist[min_dist] &gt; dist[j])) &#123;<br>                min_dist = j;<br>            &#125;<br>        &#125;<br>        <br>        st[min_dist] = <span class=\"hljs-literal\">true</span>;<br>        <br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; j ++) &#123;<br>            dist[j] = <span class=\"hljs-built_in\">min</span>(dist[j], dist[min_dist] + g[min_dist][j]);<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(dist[n] == <span class=\"hljs-number\">0x3f3f3f3f</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"堆优化的Dijkstra算法\"><a href=\"#堆优化的Dijkstra算法\" class=\"headerlink\" title=\"堆优化的Dijkstra算法\"></a>堆优化的Dijkstra算法</h4><p>O(mlogn) ，适应于<strong>稀疏图</strong>（存储用邻接表），如果边多，变成O(n^2logn)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">dijkstra</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">0x3f</span>, <span class=\"hljs-keyword\">sizeof</span> dist);<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;<br>    q.<span class=\"hljs-built_in\">push</span>(&#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>&#125;);<br>    dist[<span class=\"hljs-number\">1</span>]= <span class=\"hljs-number\">0</span>;<br>    <br>    <span class=\"hljs-keyword\">while</span>(q.<span class=\"hljs-built_in\">size</span>())<br>    &#123;<br>        <span class=\"hljs-keyword\">auto</span> t = q.<span class=\"hljs-built_in\">top</span>();<br>        q.<span class=\"hljs-built_in\">pop</span>();<br>        \t<br>        <span class=\"hljs-type\">int</span> distance = t.dirst, num = t.second;<br>        <br>        <span class=\"hljs-keyword\">if</span>(st[num]) <span class=\"hljs-keyword\">continue</span>;<br>        st[num] = <span class=\"hljs-literal\">true</span>;<br>        <br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[num]; i != <span class=\"hljs-number\">-1</span>; i = ne[i]) &#123;<br>            <span class=\"hljs-type\">int</span> j = e[i]; <span class=\"hljs-comment\">// j是节点编号，i是一个节点（idx）</span><br>            <span class=\"hljs-keyword\">if</span>(dist[j] &gt; dist[num] + w[i]) &#123;<br>                dist[j] = dist[num] + w[i];<br>                q.<span class=\"hljs-built_in\">push</span>(&#123;dist[j], j&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">if</span>(dist[n] == <span class=\"hljs-number\">0x3f3f3f3f</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>    <span class=\"hljs-keyword\">return</span> dist[n];<br>&#125; <br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"有负权\"><a href=\"#有负权\" class=\"headerlink\" title=\"有负权\"></a>有负权</h3><h4 id=\"Bellman-Ford\"><a href=\"#Bellman-Ford\" class=\"headerlink\" title=\"Bellman-Ford\"></a>Bellman-Ford</h4><p>贝尔曼-福特算法与<a href=\"https://zh.wikipedia.org/wiki/%E8%BF%AA%E7%A7%91%E6%96%AF%E5%BD%BB%E7%AE%97%E6%B3%95\">迪科斯彻算法</a>类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以<a href=\"https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95\">贪心法</a>选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共 |V| - 1次，其中 V 是图的点的数量。在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。</p>\n<p><strong>循环</strong></p>\n<p>每次循环操作实际上是对相邻节点的访问，第 k 次循环操作保证了所有深度为 k 的路径最短。由于图的最短路径最长不会经过超过 V - 1条边，所以可知贝尔曼-福特算法所得为最短路径。</p>\n<p>迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。</p>\n<p>O(nm)，可以用来求不超过k条边的最短路</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-number\">1</span> : n <span class=\"hljs-comment\">// 经过k次，k的意义：经过不超过k条边，走到每个点的最短距离</span><br>    <span class=\"hljs-keyword\">for</span> edge a, b, w<br>        dist[b] = <span class=\"hljs-built_in\">min</span>(dist[b], w); <span class=\"hljs-comment\">// 松弛操作</span><br><br><span class=\"hljs-comment\">// 经过循环，dist[b] &lt;= dist[a] + w （三角公式）</span><br></code></pre></td></tr></table></figure>\n\n<p>n次迭代，每一次循环所有边，a, b, w</p>\n<p>如果迭代n次，第n次还有更新，说明经过n条边，n条边意味着n+1个顶点，所以有环，但是由于条件是选更小的路径，说明有负环。（可以求负环，但不怎么用）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> dist[N], backup[N];<br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span> &#123;<br>    <span class=\"hljs-type\">int</span> a, b, w;<br>&#125; edges[N];<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">bellman</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">0x3f</span>, <span class=\"hljs-keyword\">sizeof</span> dist);<br>    dist[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; k; i++) &#123; <br>        <span class=\"hljs-built_in\">memcpy</span>(backup, dist, <span class=\"hljs-keyword\">sizeof</span> dist);<br>        <span class=\"hljs-comment\">// k is the limit of edge number</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= m; j++) &#123; <span class=\"hljs-comment\">// </span><br>            <span class=\"hljs-type\">int</span> a = edges[j].a, b = edges[i].b, w = edges[i].w;<br>            dist[b] = <span class=\"hljs-built_in\">min</span>(dist[b], backup[a] + w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"SPFA\"><a href=\"#SPFA\" class=\"headerlink\" title=\"SPFA\"></a>SPFA</h4><p>SPFA：对上面<strong>优化</strong>，一般是O(m)，最坏O(nm)</p>\n<p>思路：一个边要想更新，那么这条路径上他前面的边必须先更新。换句话说，只有更新过的边才有资格去更新别人。因此可以用一个队列去保存更新过的边。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-type\">int</span> h[N], e[N], ne[N], w[N];<br><span class=\"hljs-type\">int</span> st[N], dist[N];<br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> </span>&#123; e[idx] = b, ne[b] = h[a], h[a]=idx++;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">spfa</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">0x3f</span>, <span class=\"hljs-keyword\">sizeof</span> dist);<br>    queue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>    <br>    dist[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>    q.<span class=\"hljs-built_in\">push</span>(<span class=\"hljs-number\">1</span>);<br>    <br>    <span class=\"hljs-keyword\">while</span>(q.<span class=\"hljs-built_in\">size</span>())<br>    &#123;<br>        <span class=\"hljs-keyword\">auto</span> t = q.<span class=\"hljs-built_in\">front</span>(), q.<span class=\"hljs-built_in\">pop</span>();<br>        st[t] = <span class=\"hljs-literal\">false</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[t]; i != <span class=\"hljs-number\">-1</span>; i = ne[i]) &#123;<br>            <span class=\"hljs-type\">int</span> j = e[i];<br>            <span class=\"hljs-keyword\">if</span>(dist[j] &gt; dist[i] + w[i]) &#123;<br>                dist[j] = <span class=\"hljs-built_in\">min</span>(dist[j], dist[t] + w[i]);<br>                <span class=\"hljs-keyword\">if</span>(!st[j]) &#123;<br>                \tst[j] = <span class=\"hljs-literal\">true</span>;<br>                \tq.<span class=\"hljs-built_in\">push</span>(j);<br>            \t&#125;<br>            &#125;<br>            <br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(dist[n] &gt; <span class=\"hljs-number\">0x3f3f3f3f</span> / <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-100</span>;<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"spfa判断负环\"><a href=\"#spfa判断负环\" class=\"headerlink\" title=\"spfa判断负环\"></a>spfa判断负环</h4><p>在寻找最短路过程中，记录一个cnt数组，只要在寻找过程中出现了大于等于n的路径，那么说明有n+1个点，说明有环，找的是最短的，所以是负环。</p>\n<p><strong>注意：此时初始化时不能只放起点，因为可能有负环但是某个点到不了，所以需要把所有的点放进去</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">spfa</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tqueue&lt;<span class=\"hljs-type\">int</span>&gt; q;<br>\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>\t\tst[i] = <span class=\"hljs-literal\">true</span>;<br>\t\tq.<span class=\"hljs-built_in\">push</span>(i);<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span>(q.<span class=\"hljs-built_in\">size</span>())<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">auto</span> t = q.<span class=\"hljs-built_in\">front</span>();<br>\t\tq.<span class=\"hljs-built_in\">pop</span>();<br><br>\t\tst[k] = <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = h[t]; i != <span class=\"hljs-number\">-1</span>; i = ne[i]) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span> j = e[i];<br>\t\t\t<span class=\"hljs-keyword\">if</span>(dist[j] &gt; dist[t] + w[i]) &#123;<br>\t\t\t\tdist[j] = dist[t] + w[i]; <br>                <span class=\"hljs-comment\">// 利用的是最短路去找负环，这样才能在找到n条边的时候断定有负环</span><br>\t\t\t\tcnt[j] = cnt[t] + <span class=\"hljs-number\">1</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(cnt[j] &gt;= n) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">if</span>(!st[j]) &#123;<br>\t\t\t\t\tst[j] = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t\tq.<span class=\"hljs-built_in\">push</span>(j);<br>\t\t\t\t&#125;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"多源汇最短路\"><a href=\"#多源汇最短路\" class=\"headerlink\" title=\"多源汇最短路\"></a>多源汇最短路</h2><p>任意两个点的最短路</p>\n<p>Floyd算法——O(n^3) （动态规划）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">1</span>; k &lt;= n; k++) &#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i++) &#123;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j =<span class=\"hljs-number\">1</span>; j &lt;= n; j++) &#123;<br>            dist[i][j] = <span class=\"hljs-built_in\">min</span>(dist[i][j], dist[i][k] + dist[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>d[k,i,j] : 从i点开始，经过1到k的中间点，到达j的最短距离</p>\n<p>k是阶段，先枚举k，从k-1转移过来</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">dist[k, i, j] = dist[k - <span class=\"hljs-number\">1</span>, i, k] + dist[k - <span class=\"hljs-number\">1</span>, k, j]<br></code></pre></td></tr></table></figure>\n\n<p>从i到j经过1到k &#x3D; 1到k-1的阶段，加上第k个点，就是从i到k，再从k到j</p>\n<h1 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h1><h2 id=\"Prim\"><a href=\"#Prim\" class=\"headerlink\" title=\"Prim\"></a>Prim</h2><ul>\n<li>初始化距离最大值</li>\n<li>n次循环，每次找到集合外的到集合最近的点<code>t</code>，用<code>t</code>更新其他点到集合的距离</li>\n<li>prim中的<code>dist[t]</code>，代表的是t这个点到集合的最短距离</li>\n<li>对于重边，保留最小值，对于自环，不用管，因为最小生成树里面没有环，实际上只要我们把一个有自环的点放入进去，后续就不会再管到自环</li>\n<li>与Dijkstra算法很像，不同点在于<code>dist[t]</code>的意义，D代表的是t这个点到起点的最短距离，P中代表的是到集合的最短距离</li>\n<li>先累加再更新，否则自环对于权值计算有影响，一个有自环的点，是经过其他的边进入的集合，和负权自环无影响，但是如果更新了，那么这个点到集合的最短距离可能变成了自环上的负数，有影响。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">prim</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-built_in\">memset</span>(dist, <span class=\"hljs-number\">0x3f</span>, <span class=\"hljs-keyword\">sizeof</span> dist);<br>    <span class=\"hljs-type\">int</span> res = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; i ++) &#123;<br>\t\t<span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">-1</span>;<br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; j ++) &#123;<br>            <span class=\"hljs-keyword\">if</span>(!st[j] &amp;&amp; (t == <span class=\"hljs-number\">-1</span> || dist[j] &lt; dist[t])) &#123;<br>                t = j;<br>            &#125;<br>        &#125;<br>        <br>        <span class=\"hljs-keyword\">if</span>(i &amp;&amp; dist[t] == INF) <span class=\"hljs-keyword\">return</span> INF;<br>        <br>        st[t] = <span class=\"hljs-literal\">true</span>;<br>        <span class=\"hljs-keyword\">if</span>(i) res += dist[t];<br>        <span class=\"hljs-comment\">// 第一个点到集合距离应该为0</span><br>        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">1</span>; j &lt;= n; j++) &#123;<br>            dist[j] = <span class=\"hljs-built_in\">min</span>(dist[j], g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Kruskal\"><a href=\"#Kruskal\" class=\"headerlink\" title=\"Kruskal\"></a>Kruskal</h2><ul>\n<li>将所有边按照权重从小到大排序 O(mlogm)，快排，但是快排常数小</li>\n<li>枚举每条边，如果两个点不在一个集合，加入到一个集合，更新res</li>\n<li>由于该算法只关注边，不关注顶点，所以直接<strong>结构体</strong>存储即可，不需要邻接</li>\n</ul>\n<h1 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h1><h2 id=\"染色法\"><a href=\"#染色法\" class=\"headerlink\" title=\"染色法\"></a>染色法</h2><ul>\n<li>判断一个图是不是二分图</li>\n<li>一个图是二分图当且仅当图中不含有奇数环</li>\n</ul>\n<h2 id=\"匈牙利\"><a href=\"#匈牙利\" class=\"headerlink\" title=\"匈牙利\"></a>匈牙利</h2><h1 id=\"数学知识\"><a href=\"#数学知识\" class=\"headerlink\" title=\"数学知识\"></a>数学知识</h1><h2 id=\"质数\"><a href=\"#质数\" class=\"headerlink\" title=\"质数\"></a>质数</h2><h3 id=\"质数判定——试除法\"><a href=\"#质数判定——试除法\" class=\"headerlink\" title=\"质数判定——试除法\"></a>质数判定——试除法</h3><p>b | a表示b整除a，即a是b的倍数</p>\n<p>循环除法找到，但是O(n)，同时利用约数的性质，约数都是一对一对出现的，如果b | a, 那么 a&#x2F;b | a，所以不需要枚举到a - 1，只需要枚举到a&#x2F;b即可，变成logn</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">is_prime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt;= n / i; i++ ) &#123;<br>        <span class=\"hljs-keyword\">if</span>(n % i == <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分解质因数——试除法\"><a href=\"#分解质因数——试除法\" class=\"headerlink\" title=\"分解质因数——试除法\"></a>分解质因数——试除法</h3><ul>\n<li>从小到大枚举所有因数(brust)——枚举所有数也可以，不需要仅枚举质数。因为当我们枚举到i的时候，n中已经不包含任何2到n-1的质因子了</li>\n<li>n中最多只包含一个大于根号n的质因子，因为如果有两个的话，相乘大于n，否定。因此只需要先枚举到根号n的地方，剩下的如果大于1，就是大于根号n的质因子，最后一个</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">divide</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt;= n / i; i ++)&#123;<br>        <span class=\"hljs-keyword\">if</span>(n % i == <span class=\"hljs-number\">0</span>) &#123; <span class=\"hljs-comment\">// i must be 质数</span><br>            <span class=\"hljs-type\">int</span> cnt = <span class=\"hljs-number\">0</span>;<br>            <span class=\"hljs-keyword\">while</span>(n % i == <span class=\"hljs-number\">0</span>) &#123;<br>                n /= i;<br>                cnt++;<br>            &#125;<br>            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; cnt &lt;&lt; endl;;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span>(n &gt; <span class=\"hljs-number\">1</span>) cout &lt;&lt; n &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"筛选质数\"><a href=\"#筛选质数\" class=\"headerlink\" title=\"筛选质数\"></a>筛选质数</h3><p>如果循环再依次判断，复杂度较高</p>\n<p>每当遍历到一个，直接将他所有的倍数去除，也就是for循环每次加自己即可</p>\n<p>优化后能够达到O(n)，只把质数的倍数去掉即可</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt;= n; i ++ ) &#123;<br>        <span class=\"hljs-keyword\">if</span>(!st[i]) &#123;<br>            primes[cnt ++ ] = i;<br>            <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> j = i + i; j &lt;= n; j += i) &#123;<br>                st[j] = <span class=\"hljs-literal\">true</span>; <span class=\"hljs-comment\">// 遍历过，且必为合数</span><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"约数\"><a href=\"#约数\" class=\"headerlink\" title=\"约数\"></a>约数</h2><h3 id=\"求约数\"><a href=\"#求约数\" class=\"headerlink\" title=\"求约数\"></a>求约数</h3><ul>\n<li>试除法，成对出现，与质数类似</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">get_divisors</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; res;<br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt;= n; i ++ ) &#123;<br>        <span class=\"hljs-keyword\">if</span>(n % i == <span class=\"hljs-number\">0</span>)<br>        &#123;<br>            res.<span class=\"hljs-built_in\">push_back</span>(i);<br>            <span class=\"hljs-keyword\">if</span>(i != n / i) &#123;<br>                res.<span class=\"hljs-built_in\">push_back</span>(n / i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-built_in\">sort</span>(res.<span class=\"hljs-built_in\">begin</span>(), res.<span class=\"hljs-built_in\">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"约数个数\"><a href=\"#约数个数\" class=\"headerlink\" title=\"约数个数\"></a>约数个数</h3><p>基于约数个数定理</p>\n<p><img src=\"https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221106202640167.png\" alt=\"image-20221106202640167\"></p>\n<p>知道质因数组成，则对a进行组合即可，每种组合对应一个约数</p>\n<ul>\n<li><p>int范围内最多也就是1500多个约数</p>\n</li>\n<li><p>12 ：1，2，3，4，6，12</p>\n</li>\n<li><p>12 &#x3D; 2 * 2 * 3</p>\n</li>\n</ul>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>模型（如背包）、线性DP，区间DP，状态压缩DP</p>\n<p>状态表示：<code>f[i][j]</code>，考虑好需要几维来表示状态，每一个状态的含义是什么</p>\n<ul>\n<li>状态的集合是什么<ul>\n<li>所有选法</li>\n<li>只从前i个物品里面选</li>\n<li>总体积 &lt;&#x3D; j</li>\n<li>满足上面两个<strong>条件</strong>的所有选法的集合</li>\n</ul>\n</li>\n<li><code>f[i][j]</code>的数值就是状态的属性是什么（最大值，最小值，数量）</li>\n</ul>\n<p>状态计算：把每一个状态计算出来</p>\n<ul>\n<li>集合的划分</li>\n<li>背包中，分为两大类：含i和不含i</li>\n<li>划分：不重复、不漏掉</li>\n<li>不含i的最大值，就是从1到i-1，选择的最大值</li>\n<li>含i的最大值，直接求不好求，可以先把i去掉，同时体积也减去vi，再加上第i个物品的价值（这种条件下，反正都是要选择第i个物品的，那么我们把第i个物品的价值先拿出来，最大的价值还是最大的，此时最大的情况是i-1 和 j - vi，再统一加上第i个物品的价值）</li>\n<li>但是要注意，含i的情况，可能不存在，就是指现在背包的容量已经装不下第i个物品了</li>\n</ul>\n<p>优化：一般都是对方程作等价变形，先做朴素的</p>\n<p>状态的集合，i和j就变成了元素的属性</p>\n<h2 id=\"背包\"><a href=\"#背包\" class=\"headerlink\" title=\"背包\"></a>背包</h2><ul>\n<li>01背包（一个物品用一次）</li>\n<li>完全背包（没有限制）</li>\n<li>多重背包（每种物品数量不一样）</li>\n<li>分组背包（n组，每一组里有若干种，每一组选一个）</li>\n</ul>\n<h3 id=\"01背包\"><a href=\"#01背包\" class=\"headerlink\" title=\"01背包\"></a>01背包</h3>","categories":["Geek"],"tags":["Developer","Programming","技术","算法"]},{"title":"git learning","url":"/post/dbf237bf.html","content":"<p>用一棵树，维护所有的代码历史记录</p>\n<ul>\n<li>一个人的代码版本回顾</li>\n<li>多个人的代码协同开发</li>\n<li>版本管理、可持久化、多人协作</li>\n</ul>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li>工作区：本地看git的文件夹，即当前工作目录，与分支无关</li>\n<li>版本库：repository，存储所有提交到本地的代码版本</li>\n<li>暂存区：工作区与版本库之间的桥梁，多次本地工作，但是尚未构成一次提交，可以先到暂存区，本次阶段完成后，进入版本库。<strong>与分支独立，所有的分支其实是共用一个暂存区</strong></li>\n</ul>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ul>\n<li><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<code>~/.gitconfig</code>文件中</li>\n<li><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在<code>~/.gitconfig</code>文件中</li>\n<li><code>ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</code>: 生成一个新的密钥</li>\n</ul>\n<h3 id=\"本地操作\"><a href=\"#本地操作\" class=\"headerlink\" title=\"本地操作\"></a>本地操作</h3><ul>\n<li><code>git init</code> :  把当前目录变成一个git仓库</li>\n<li><code>git status</code>: 显示状态，untracked就是未加入到暂存区</li>\n<li><code>git add &lt;filename&gt;</code>：加入filename到暂存区中</li>\n<li><code>git add .</code>：将所有待加入暂存区的文件加入到暂存区（忽略.gitignore）</li>\n<li><code>git commit -m &quot;message&quot;</code>：把暂存区内容加入到当前分支</li>\n<li><code>git diff XX</code>: 查看某个文件相对于当前分支的最新版本修改了哪些内容（即commit的与尚未add的，版本库的内容与尚未add的内容）</li>\n<li><code>git rm --cached XX</code>: 将某个文件从暂存区删除出来，并且我也不管理它</li>\n<li><code>git restore --staged XX</code>: 将某个文件从暂存区删除，但是还要管理（相比于上面，不需要再次add）</li>\n<li><code>git log</code>：查看当前分支的所有版本（从最开始到HEAD所在位置）</li>\n<li><code>git reset --hard HEAD^</code>: 将代码回滚一个版本，一个三角一个版本，100个版本加数字</li>\n<li><code>git reflog</code>：HEAD的移动记录</li>\n<li><code>git reset --hard &#123;hashval&#125;</code>：回滚到任意版本，借助上一条命令得到哈希值</li>\n<li><code>git restore &lt;filename&gt;</code>: <strong>撤销该文件所有工作区</strong>的修改，<strong>回滚到暂存区</strong>的阶段，如果暂存区没有内容，那么就是回滚到头节点指向的那个阶段。（即使是删除文件，也可以回滚）</li>\n<li><code>git restore --staged XX</code>: 将某个文件<strong>从暂存区删除</strong>，回到了工作区</li>\n<li><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支</li>\n<li><code>git branch branch_name</code>：创建新分支</li>\n</ul>\n<h3 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h3><ul>\n<li><code>git remote add origin git@github.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库</li>\n<li><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支</li>\n<li><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应</li>\n<li><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</li>\n<li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li>\n<li><code>git checkout -t origin/branch_name</code> 将远程的branch_name分支拉取到本地</li>\n</ul>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><h4 id=\"1-add\"><a href=\"#1-add\" class=\"headerlink\" title=\"1. add\"></a>1. add</h4><p>如果创建一个文件，此时尚未add，则未track任何文件，会提示哪些未track</p>\n<p>这个新文件，未add之前，无论如何修改，git status给的提示都一样</p>\n<p>add之后，会显示有一个新文件，此时如果继续修改，则变成两份：一份是待提交给版本库的commit，也就是add过的那个版本；另一份是没有add的修改</p>\n<ul>\n<li><p>此时如果继续add，则两次add内容合并，git只显示你创建了一个新文件</p>\n</li>\n<li><p>此时如果先把之前的commit，则只把add之前的那个版本提交，add后修改的不动，此时查询状态，是修改状态(且尚未提交)。</p>\n</li>\n</ul>\n<p>删除文件的操作也可以加入到暂存区中，删除是一种特殊的修改</p>\n<h4 id=\"2-commit\"><a href=\"#2-commit\" class=\"headerlink\" title=\"2. commit\"></a>2. commit</h4><ul>\n<li><p>一次commit之后，就会根据当前在哪一个分支，在这个分支下新开一个节点，之前节点+新commit的这些加入到这个新节点中，然后修改HEAD指针，指向这个新节点</p>\n</li>\n<li><p>实际上是将暂存区持久化，如果某个文件在工作区，没有被放到暂存区，那么这个文件也不会被提交。</p>\n</li>\n<li><p>所有的节点都是commit出来的</p>\n</li>\n<li><p><strong>提交commit一次之后，当前目录下的暂存区清空，git的track状态变为null，即不再追踪任何文件</strong></p>\n</li>\n</ul>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p>该图片由<a href=\"https://pixabay.com/zh/users/skorec-16694100/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7522129\">Daniel Skovran</a>在<a href=\"https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7522129\">Pixabay</a>上发布</p>\n","categories":["Geek"],"tags":["Developer","技术","git"]},{"title":"Computer Network Notes","url":"/post/c78e5236.html","content":"<h1 id=\"数据链路\"><a href=\"#数据链路\" class=\"headerlink\" title=\"数据链路\"></a>数据链路</h1><p>两台相邻机器实现可靠通信（相邻是通过信道连接起来）</p>\n<h2 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h2><ul>\n<li>向网络层提供服务接口</li>\n<li>处理传输错误</li>\n<li>调节数据流</li>\n</ul>\n<p>提供的服务：</p>\n<ul>\n<li>无确认的无连接服务（差错很少或者实时场景）</li>\n<li>有确认的无连接（帧要确认是否收到，比如无线系统）</li>\n<li>有确认的有连接</li>\n</ul>\n<h2 id=\"成帧\"><a href=\"#成帧\" class=\"headerlink\" title=\"成帧\"></a>成帧</h2><p>由于接收到的可能出错，因此需要校验，方便校验， 使用帧的概念。每一个帧都有令牌检验</p>\n<h3 id=\"成帧方式\"><a href=\"#成帧方式\" class=\"headerlink\" title=\"成帧方式\"></a>成帧方式</h3><ul>\n<li>字节计数</li>\n<li>字节填充的标志字节（缺点：必须以该字节的大小（比如8比特）作为传输基本单元）</li>\n<li>比特填充的标志比特（任意大小单元组成二进制流）</li>\n</ul>\n<p>后两者副作用：帧大小取决于帧的数据内容</p>\n<h2 id=\"差错控制\"><a href=\"#差错控制\" class=\"headerlink\" title=\"差错控制\"></a>差错控制</h2><p>确保可靠，我们要有<strong>反馈</strong>信息。接收方返回控制帧，进行肯定或否定的确认。但可能会有<strong>帧丢失</strong>的情况，这样如何反应？需要引入<strong>计时器</strong>，但是计时器会造成这种问题：接收方接收到两个一样的帧，多次传给了网络层，所以又需要为<strong>帧分配序号</strong>，从而使接收方区分原始帧和重传帧。</p>\n<h3 id=\"纠错码\"><a href=\"#纠错码\" class=\"headerlink\" title=\"纠错码\"></a>纠错码</h3><ul>\n<li>码字，码率，海明距离</li>\n</ul>\n<p>为了检测d位错误，需要一个距离为d+1的编码方案，因为在这样的编码方案中，d位错误不可能将一个有效码字变成另一个有效码字。</p>\n<p>为了纠正d位错误，需要距离为2d+1的编码方案，这样，合法码字足够远，即使发生了d位变化，也还是离原来的码字更近。<strong>在不太可能有更多错误的假设下，可以唯一确认原来的码字，从而纠错</strong>。</p>\n<h3 id=\"检错码\"><a href=\"#检错码\" class=\"headerlink\" title=\"检错码\"></a>检错码</h3><p>纠错码被用于无线系统，而光纤铜线等更加可靠，因此使用差错检测和重传更高效。</p>\n<ul>\n<li>奇偶校验</li>\n<li>校验和</li>\n<li>CRC</li>\n</ul>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><p>基于反馈的流量控制</p>\n<ul>\n<li><p>物理层进程和某些数据链路层进程运行在一个称为NIC（网络接口卡）的硬件上，也就是网卡</p>\n</li>\n<li><p>网络层永远得不到任何帧头的信息，这是因为要保持网络层和数据链路层的完全分离。只要网络层对数据链路层和帧格式一无所知，那么当数据链路层协议改变时，网络层软件不用作出任何改变。（比如换了个网卡）</p>\n</li>\n<li><p>一个帧由4个字段组成：kind, seq, ack, info，前三个是控制信息，合称帧头</p>\n</li>\n</ul>\n<h2 id=\"基本协议\"><a href=\"#基本协议\" class=\"headerlink\" title=\"基本协议\"></a>基本协议</h2><ul>\n<li>乌托邦式的协议</li>\n<li>无错，单工停等式协议——只是接受，接受到就可以发下一个</li>\n<li>有错，单工停等式协议——计时器+序号（区分新帧老帧）</li>\n<li>如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议叫自动重复请求（ARQ），常用的ARQ有SAW（停等）、GBN（回退N）、SRP（选择重传）</li>\n<li>滑动窗口协议（最大区别-双向的）同一个链路传输两个方向，<strong>并且使用捎带确认</strong>，增大利用率</li>\n</ul>\n<h3 id=\"SAW（停等）\"><a href=\"#SAW（停等）\" class=\"headerlink\" title=\"SAW（停等）\"></a>SAW（停等）</h3><ul>\n<li>发送后等ACk</li>\n<li>设置计时器</li>\n<li>设置序号区分</li>\n<li>为了标识ACK，使用捎带确认</li>\n</ul>\n<h3 id=\"一位窗口滑动协议\"><a href=\"#一位窗口滑动协议\" class=\"headerlink\" title=\"一位窗口滑动协议\"></a>一位窗口滑动协议</h3><h3 id=\"回退N协议\"><a href=\"#回退N协议\" class=\"headerlink\" title=\"回退N协议\"></a>回退N协议</h3><h4 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h4><ul>\n<li>发送窗口：<ul>\n<li>收缩：包发出去了</li>\n<li>扩展：收到了包对应的ACK</li>\n</ul>\n</li>\n<li>接收窗口：<ul>\n<li>收缩：包收到了</li>\n<li>扩展：发出了ACK</li>\n</ul>\n</li>\n</ul>\n<p>考虑到传输时延，使用管道化。</p>\n<p>为了处理管道化的错误，两种协议，回退N和选择重传</p>\n<p>回退N对应于窗口大小为1的情形，选择重传的窗口大小大于1</p>\n<p>计时器过期时间 T &gt; W * L &#x2F; R（先把窗口的传出去）</p>\n<p>发现错误后也有基于ACK的和NAK的两种方法</p>\n<p>可能丢帧，也可能丢ACK（计时器触发）</p>\n<p>在GBN下，不是每个帧都要独立ACK</p>\n<h3 id=\"选择重传协议\"><a href=\"#选择重传协议\" class=\"headerlink\" title=\"选择重传协议\"></a>选择重传协议</h3><p>通常和否定策略结合，即发送否定确认。</p>\n<p>每个帧都需要单独确认</p>\n<p>效率：min（1，W*t&#x2F;S）,t是传输时延，S是一个的总时间</p>\n<p>GBN和SRP效率都是这个</p>\n<h2 id=\"数据链路总结\"><a href=\"#数据链路总结\" class=\"headerlink\" title=\"数据链路总结\"></a>数据链路总结</h2><p>提供无错的比特流</p>\n<ul>\n<li>成帧（三种方法）</li>\n<li>差错控制<ul>\n<li>编码（检错纠错）</li>\n<li>海明码</li>\n<li>奇偶</li>\n<li>CRC</li>\n</ul>\n</li>\n<li>ARQ差错恢复：重发<ul>\n<li>发送者处理丢失的帧，接收者处理出错的帧</li>\n<li>SAW思想</li>\n<li>滑动窗口<ul>\n<li>SAW</li>\n<li>GBN</li>\n<li>SPR</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"MAC\"><a href=\"#MAC\" class=\"headerlink\" title=\"MAC\"></a>MAC</h1><h2 id=\"作用-1\"><a href=\"#作用-1\" class=\"headerlink\" title=\"作用\"></a>作用</h2><p>分配channel：单一（固定）&amp; 随机（动态）</p>\n<p>core: Who can transmit at when</p>\n<h2 id=\"多人访问链接\"><a href=\"#多人访问链接\" class=\"headerlink\" title=\"多人访问链接\"></a>多人访问链接</h2><p>包含两部分：</p>\n<p>点对点连接：终端和交换机（台式）<br>广播连接：以太网 ，无线连接</p>\n<p>多人访问并非只有动态，也可能有p to p</p>\n<h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><ul>\n<li>ALOHA</li>\n<li>CSMA</li>\n<li>Taking turns</li>\n<li>collision free</li>\n<li>limited-contention</li>\n<li>Ethernet</li>\n<li>Wireless LAN</li>\n</ul>\n<p>要解决的核心：<strong>冲突检测、恢复</strong></p>\n<h3 id=\"term\"><a href=\"#term\" class=\"headerlink\" title=\"term\"></a>term</h3><ul>\n<li>frame  time：transmission delay</li>\n<li>N : new frames</li>\n<li>G : generated frames &#x2F; frame time(considering retransmission)</li>\n</ul>\n<h3 id=\"pure-ALOHA\"><a href=\"#pure-ALOHA\" class=\"headerlink\" title=\"pure ALOHA\"></a>pure ALOHA</h3><ul>\n<li><p>检测：听</p>\n</li>\n<li><p>恢复：等随机时间再重发</p>\n</li>\n<li><p>Vulnerable time：2t（t 是 transmission delay）</p>\n</li>\n<li><p>max throughput : 0.184</p>\n</li>\n</ul>\n<h3 id=\"Slotted-ALOHA\"><a href=\"#Slotted-ALOHA\" class=\"headerlink\" title=\"Slotted ALOHA\"></a>Slotted ALOHA</h3><ul>\n<li>Time is cut into slots.</li>\n<li>need sync</li>\n<li>Vulnerable time : t</li>\n<li>max throughput : 0.368</li>\n</ul>\n<p>ALOHO 的主要问题：吞吐量太低了</p>\n<p>本着提高信道利用率，下面是CSMA</p>\n<h3 id=\"CSMA\"><a href=\"#CSMA\" class=\"headerlink\" title=\"CSMA\"></a>CSMA</h3><p><strong>check before transmit</strong>（提高信道利用率）</p>\n<ul>\n<li>scenario : LAN (propagation delay is small)</li>\n<li>p-Persistence CSMA &amp; Non-Persistence CSMA<ul>\n<li>if persist, the node listen to the channel continuously, and transmit frame with probability of p.</li>\n<li>if not persist, node doesn’t listen continuously, check channel after random time</li>\n</ul>\n</li>\n<li>Collision may still happen because of propagation delay</li>\n<li>p越小，其实吞吐量越大，倾向于conservative</li>\n<li>主要是为了提高利用率，但冲突还是会发生，一旦发生，帧就要浪费</li>\n</ul>\n<p>为了减少不必要的浪费，<strong>添加冲突检测</strong>，检测到就直接停止</p>\n<h3 id=\"CSMA-x2F-CD（Ethernet）\"><a href=\"#CSMA-x2F-CD（Ethernet）\" class=\"headerlink\" title=\"CSMA&#x2F;CD（Ethernet）\"></a>CSMA&#x2F;CD（Ethernet）</h3><p>如何检测？</p>\n<ul>\n<li>有线：听到的和发出的一样不</li>\n<li>无线：难以检测<ul>\n<li>硬件限制（只能取一）</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"检测\"><a href=\"#检测\" class=\"headerlink\" title=\"检测\"></a>检测</h4><ul>\n<li>contention</li>\n<li>idle</li>\n<li>transmission</li>\n</ul>\n<h4 id=\"检测时间\"><a href=\"#检测时间\" class=\"headerlink\" title=\"检测时间\"></a>检测时间</h4><ul>\n<li><p>最小：t（prop）</p>\n</li>\n<li><p>最大：2t（RTT）</p>\n</li>\n</ul>\n<p>CSMA&#x2F;CD &#x3D; slotted ALOHA with slot of length 2t</p>\n<p>静态的适合高负载，动态的适合低负载</p>\n<h3 id=\"Collision-Free-Protocol\"><a href=\"#Collision-Free-Protocol\" class=\"headerlink\" title=\"Collision-Free Protocol\"></a>Collision-Free Protocol</h3><ul>\n<li>polling(轮询)</li>\n<li>token ring</li>\n<li>bit-map（适合人多）reserve</li>\n<li>binary countdown（有优先级）reserve</li>\n</ul>\n<h3 id=\"Limited-Contention-Protocols\"><a href=\"#Limited-Contention-Protocols\" class=\"headerlink\" title=\"Limited Contention Protocols\"></a>Limited Contention Protocols</h3><p>低负载竞争（延迟小），高负载无冲突（利用率高）</p>\n<p>做法：分组：组内竞争一个时间slot</p>\n<p>关键在于动态分配时间槽</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><h3 id=\"Ethernet\"><a href=\"#Ethernet\" class=\"headerlink\" title=\"Ethernet\"></a>Ethernet</h3><p>LAN</p>\n<p><strong>Encapsulation</strong>: IP datagram -&gt; Ethernet frame</p>\n<ul>\n<li>frame structure：Preamble，Address(Dest &amp; Source)，Type（higher-layer）Data，CRC</li>\n<li>many different Ethernet standards（a family）</li>\n<li>不可靠、无连接</li>\n</ul>\n<h3 id=\"经典以太网\"><a href=\"#经典以太网\" class=\"headerlink\" title=\"经典以太网\"></a>经典以太网</h3><h4 id=\"帧结构\"><a href=\"#帧结构\" class=\"headerlink\" title=\"帧结构\"></a>帧结构</h4><ul>\n<li><p>目标地址第一位：0是普通地址，1是组地址，该组中的所有站都要接受（组播），全1是广播</p>\n</li>\n<li><p>type：网络层可能有多个协议，因此需要知道谁来处理</p>\n</li>\n<li><p>Data：不能太大，太大了收发器没有足够的内存来存储完整帧；不能太小，太小了</p>\n<ul>\n<li>冲突后会截断，截断的更短，要能区分有效帧和截断的无效数据</li>\n<li>（更重要原因）—— 传完了，但是冲突了。冲突时接收方发出突发噪声，让发送方知道冲突了。但如果帧太短，发送方已经传完了，那么它就知道自己已经传成功了，结论错误。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h4><ul>\n<li>NIC收到网络层的数据，构建帧</li>\n<li>监听信道96 bit time，如果空闲就传，否则等待</li>\n<li>无冲突，传输成功</li>\n<li>有冲突，放弃并且传48bit的jam signal（突发信号），等待随机时间</li>\n</ul>\n<p>随机时间如何确定？</p>\n<h4 id=\"二进制指数后退\"><a href=\"#二进制指数后退\" class=\"headerlink\" title=\"二进制指数后退\"></a>二进制指数后退</h4><p>两个站冲突后等待，如果等待时间一样，那么会一直冲突</p>\n<p>如果冲突了m次，那么下次就从0到2的m次方-1，这些数中随机选择。期望增加</p>\n<p>最大1023，还冲突发失败报告</p>\n<h4 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h4><p>帧越长，效率越高，但是那样变成只为一个人服务了</p>\n<h3 id=\"集线器-hub-x2F-中继器\"><a href=\"#集线器-hub-x2F-中继器\" class=\"headerlink\" title=\"集线器 hub &#x2F; 中继器\"></a>集线器 hub &#x2F; 中继器</h3><ul>\n<li><p>无脑传输，一个来，其余所有路线传出去</p>\n</li>\n<li><p>共同组成一个大的冲突域</p>\n</li>\n<li><p>主机需要使用CSMA&#x2F;CD</p>\n</li>\n</ul>\n<h3 id=\"交换机\"><a href=\"#交换机\" class=\"headerlink\" title=\"交换机\"></a>交换机</h3><ul>\n<li>有缓存 ：store and forward</li>\n<li>传输有目标，只传到目标地址的主机</li>\n<li>全双工，无冲突</li>\n<li>自学习，交换表</li>\n</ul>\n<h3 id=\"无线网络LAN\"><a href=\"#无线网络LAN\" class=\"headerlink\" title=\"无线网络ＬＡＮ\"></a>无线网络ＬＡＮ</h3><p>基站 : 无线和有线之间的桥梁</p>\n<h4 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h4><ul>\n<li>衰减</li>\n<li>干扰</li>\n<li>多径效应(反射的存在)</li>\n</ul>\n<p>SNR很重要</p>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><ul>\n<li>隐藏终端问题 – 由于竞争者离得太远而导致站无法检测到潜在的竞争者</li>\n<li>暴露终端问题 – 发送方由于离得近, 导致不敢发送(其实方向不一样可以发送)</li>\n</ul>\n<p>CSMA还是可以工作,但是无法检测冲突,只能避免冲突</p>\n<h4 id=\"CSMA-x2F-CA\"><a href=\"#CSMA-x2F-CA\" class=\"headerlink\" title=\"CSMA&#x2F;CA\"></a>CSMA&#x2F;CA</h4><p>发送前要等一段时间(发送方和接收方都是)</p>\n<p><strong>RTS - CTS</strong></p>\n<ul>\n<li><p>如果有基站: 发送者发RTS,听到的人知道附近有人在发东西, 先别发, 接收方返回CTS, 其他人听到CTS, 也等着(CTS里面有帧长度信息所以知道等多长时间)</p>\n</li>\n<li><p>没有基站, 有隐藏终端和暴露终端的问题. 与上面不同的一点, 如果一个站点听到了RTS, 但是没有听到CTS, 说明这个站点和接收方实际上很远, 可以发送</p>\n</li>\n</ul>\n<p>真正希望知道的是接收方附近是否有无线电活动</p>\n<hr>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><p>数据链路就是将帧从一端传到另一端，而网络层是处理端到端数据传输的最底层。因此需要知道整个网络的拓扑结构，选择路径、选择路由</p>\n<h2 id=\"提供服务\"><a href=\"#提供服务\" class=\"headerlink\" title=\"提供服务\"></a>提供服务</h2><ul>\n<li>向传输层提供服务需要独立于路由器（数量种类与拓扑）</li>\n<li>传输层需要的网络地址需要一个统一的编址方案</li>\n<li>无连接和连接的争论</li>\n</ul>\n<p>面向连接，数据报——数据报网络</p>\n<p>不面向连接，虚电路——虚电路网络</p>\n<h2 id=\"路由算法\"><a href=\"#路由算法\" class=\"headerlink\" title=\"路由算法\"></a>路由算法</h2><p>是网络层软件的一部分，负责确定一个入境数据包应该发送到哪个输出线路上。</p>\n<p>路由：对使用哪一条路径作出决策</p>\n<p>转发：数据包到达后采取什么决策（查表）</p>\n<p>路由算法：生成和更新路由表</p>\n<hr>\n<h1 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h1><p>该封面图片由<a href=\"https://pixabay.com/zh/users/xiserge-15871962/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887\">xiSerge</a>在<a href=\"https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887\">Pixabay</a>上发布</p>\n","categories":["Geek"],"tags":["技术","计算机网络"]},{"title":"Navicat无法连接MySQL","url":"/post/32e06ea.html","content":"<h1 id=\"Navicat无法连接到MySQL数据库\"><a href=\"#Navicat无法连接到MySQL数据库\" class=\"headerlink\" title=\"Navicat无法连接到MySQL数据库\"></a>Navicat无法连接到MySQL数据库</h1><p>解决问题只需要一分钟，而发现问题则需要三小时。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"省流版：\"><a href=\"#省流版：\" class=\"headerlink\" title=\"省流版：\"></a>省流版：</h2><p>服务器没有开MySQL的端口。</p>\n<p>之所以还要写一篇文章，是因为开端口只需要一分钟，而根据各种现象与线索推断出没有开端口则需要三个小时。</p>\n<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在服务器上安装了Linux虚拟机，然后在虚拟机上安装MySQL。</p>\n<p>之前一直都是用xshell操纵MySQL，今天想使用Navicat连接。</p>\n<h2 id=\"my数据库\"><a href=\"#my数据库\" class=\"headerlink\" title=\"my数据库\"></a>my数据库</h2><p>MySQL的数据库如下：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc5659dfe-f48f-4459-b7be-2d779ed5c70c%2FUntitled.png?table=block&id=a9a7fa21-6960-4bed-b8cd-2a85a11fe85e&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>共两个数据库，一个myDB1，一个university数据库（其余为MySQL自带的数据库）</p>\n<p>此时我MySQL里面的用户如图：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5b287113-20e3-499e-81d5-59722b6b7c20%2FUntitled.png?table=block&id=ff3d3505-8259-45e3-b47e-1e294c563cfb&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>可以看到里面有三个用户，root，peng和user_for_db1。其中user_for_db1是之前建立的，根据名字可知，为user_for_db1赋予了myDB1数据库的所有权限，同时为peng用户赋予所有数据库的所有访问权限。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在Navicat中，建立了两个连接，如图：</p>\n<p>连接1：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7a37ed44-bebf-4d38-b693-46977d58f8c4%2FUntitled.png?table=block&id=8a6b4130-bd23-4c55-ba1b-ed989a18c8d6&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15714710-cf21-4afb-bb78-627d7e56b638%2FUntitled.png?table=block&id=4dc00da1-10bb-4d7e-a015-4f0da4a7fa68&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>可以看到连接成功，并且由于设置了访问权限，所以只有myDB1一个数据库。这个连接是很久之前建立的，当时忘记怎么连接的了（果然还是要养成记录的好习惯）。</p>\n<p>但是当用另一个用户连接的时候，却提醒<strong>连接出错</strong>，如图：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb09dfa26-c0a4-46d9-b9bc-5d72d067e117%2FUntitled.png?table=block&id=90a62de4-8525-4412-b366-45cf76e70770&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F433afe7e-5c47-4f58-8631-7a0c3af38bee%2FUntitled.png?table=block&id=453d6e96-5568-4986-8a68-3523f2b26b7d&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>另外也不是SSH连接的错误，因为都不行，这里只是没放截图。</p>\n<h2 id=\"请教大佬\"><a href=\"#请教大佬\" class=\"headerlink\" title=\"请教大佬\"></a>请教大佬</h2><p>在向大佬请教过程中，并没有直接问为什么连不上，因为很多背景会导致共同的问题，上来直接问往往讲不清背景。我先是注意到在XShell中，连接的端口是22，协议是SSH，而Navicat中的端口是3306，因此就先问了一下这两个端口的不同。</p>\n<p>大佬回答如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">22</span><span class=\"hljs-string\">这个端口，是用SSH连接服务器的默认端口；</span><br><span class=\"hljs-number\">3306</span><span class=\"hljs-string\">这个端口，是MySQL的默认端口。</span><br></code></pre></td></tr></table></figure>\n\n<p>当时还并没有十分清楚，大佬又来了一句：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-number\">3306</span><span class=\"hljs-string\">可以改的</span><br><span class=\"hljs-string\">开启MySQL时候换个端口就行</span><br></code></pre></td></tr></table></figure>\n\n<p>听了这句话之后，我也排除了端口冲突的问题，因为这两个连接并没有同时打开。</p>\n<p>之后向大佬讲了一下背景，也就是上文的内容，大佬听完后，也是不太清楚。。。。</p>\n<h2 id=\"峰回路转\"><a href=\"#峰回路转\" class=\"headerlink\" title=\"峰回路转\"></a>峰回路转</h2><p>其实一开始就感觉这个问题有点奇怪，所以并没有很失望，不过看着大佬跟我说的那句：3306可以改的，我陷入了沉思。</p>\n<p>MySQL怎么知道你把端口改了呢？</p>\n<p>突然又想到最初设置服务器的时候，在安全组里面设置过一些端口</p>\n<p>于是问了一下大佬要不要在服务器上添加允许这个新端口</p>\n<p>果不其然，需要在服务器上设置。</p>\n<p>然后，就想着在服务器上添加一个新端口，尝试用新端口连接。</p>\n<p>然后震惊地发现，我没有给MySQL开端口！！</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcadc8899-4cd3-4076-80c4-e3e7f16f14e0%2FUntitled.png?table=block&id=190f073f-a445-4388-9894-a0bd82f16227&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>发现这点后，我并没有立刻开放端口，而是开始思索，我之前怎么登录的呢？</p>\n<p>看着被允许的几个端口，尤其是<strong>22</strong>那个端口，事情逐渐明朗了起来</p>\n<p>我开了22的端口，而xshell也是用22连接的，也就是说，我用xshell连接，相当于是<strong>远程桌面</strong>。</p>\n<p>我是先通过22端口，连接到远程桌面，也就相当于登录到服务器这个计算机，然后在进入到mysql，这时的MySQL就相当于是远程计算机的本地应用了，所以不需要3306这个端口。</p>\n<p>但是我一开始怎么连接成功的呢？</p>\n<p>就是这个</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7a37ed44-bebf-4d38-b693-46977d58f8c4%2FUntitled.png?table=block&id=8a6b4130-bd23-4c55-ba1b-ed989a18c8d6&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>说实话想了好久也没想清楚，目前的推断是，在上图的安全组中（图7），有三个内网IP，有可能服务器认为我这个连接属于内网连接，所以可以通过（只是推测）。</p>\n<h2 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h2><p>开放端口后，确实连接成功了，但是发现没有任何数据库信息，于是通过网上查阅资料，知道是需要如下操作，简单记录一下：</p>\n<p>右键——编辑连接——数据库——选择对应的数据库（可能需要勾选使用自定义数据库列表）</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F76c93ef3-c8f6-4b72-aec7-e0b7c1f56533%2FUntitled.png?table=block&id=52f49902-8e18-4ce1-95d2-f79755247bcc&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>通过这次的问题，我明白了端口的重要性，端口和IP地址一样都是用来标识计算机的，通过这些标识赋予不同计算机的访问权限。</li>\n<li>熟悉了一些关于用户与数据库授权的知识，只有授权后才能在Navicat中显示。</li>\n<li>进一步感受到了如何正确的问问题：<ul>\n<li>自己必须先尝试一些方案，不要遇到问题就直接问，先自己尝试解决。</li>\n<li>同时要将对方代入到你的场景中，描述清楚背景是成功的一半。</li>\n<li>在问的过程中，也要不断给出自己的思路，自己多加思考，因为没人有义务无偿且天然地向你解答。</li>\n<li>即使到最后，这个解决方案，包括添加新端口与两个端口的差别，都是我自己引导着大佬去解答的。大佬并没有直接给出方案（可能还是由于描述不清，到最后他才知道我之前是用xShell登录的），自己才是最清楚历史原因的人，一定要多思考。</li>\n</ul>\n</li>\n<li>添加一个端口只需要一分钟，但知道为什么添加，却需要三个小时。</li>\n</ul>\n","categories":["Geek"],"tags":["Developer","技术","mysql","数据库","navicat"]},{"title":"onedrive - not just cloud drive","url":"/post/71ae5435.html","content":"<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>很多时候，一些问题与想法，必须要有多个设备的背景。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>​\t\t通过两台电脑的日常使用思考，展现OneDrive这一同步利器，以及OneDrive的理念与意义。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>​\t\t三月份由于一些原因，入手了一个主机，原来的笔记本一下子变成了键盘托，想起之前觉得30块钱的键盘托有些贵，如今用大几千的笔记本当键盘托确实有些好笑。</p>\n<p>​\t\tAngway，同步的问题刚开始显得不是那么重要，因为使用场景固定。无非是一些大文件的拷贝，这时用一个硬盘，就能轻松解决，而且300MB的顺序读写速度也让每次借硬盘、插线显得不是那么费劲。随后便在主机上舒舒服服地用了一段时间。</p>\n<p>​\t\t后来，由于地区解封的原因，需要隔离，而隔离7天，或许就只能用我的笔记本了。</p>\n<p>​\t\t但是我几个月来的工作文件基本都在主机上，如何同步，成了一个难题。</p>\n<p>​\t\t我不想直接把文件拷到U盘然后传到笔记本上，感觉这样有些原始……</p>\n<p>​\t\t也不想传到网盘里，因为要么某些太慢，要么感觉每次打开客户端太麻烦……</p>\n<p>​\t\t我想要做的，是等我换回主机工作的时候，如何避免再重复一遍文件同步的工作，也想避免以后每次在两台设备或者更多台更换时，我都要记得这段时间内在当前电脑上的修改，然后用网盘或者U盘的方式传文件。因为使用场景比较灵活，也不可能部署一个NAS系统存文件(太贵加没有地方放)，对于一些软件来讲，没有必要把软件本体都同步，软件在电脑上变动还是相对较小的，主要是文件。</p>\n<p>​\t\t我的理想目标是，能够像Git一样，有一个版本控制的功能，让我能够在多个客户端修改，之后每次修改完，能够通过一些指令(或者完全自动)比如git push传到某个云服务器上，然后更换设备时，只需要像git pull一样再从云端拉取下来，这样两台设备就可以无缝切换。</p>\n<h4 id=\"OneDrive-来了\"><a href=\"#OneDrive-来了\" class=\"headerlink\" title=\"OneDrive 来了\"></a>OneDrive 来了</h4><p>​\t\t之前也一直有用过OneDrive，毕竟是微软自家的，用着Windows想不注意都难。之前个人有个5G的免费空间，但是用的体验不太好，要么很容易满，然后提醒你升级到365；要么是本地写点文件时候，他就一直在同步，但我又不清楚到底哪些能够同步，哪些默认同步，导致一些莫名其妙的同步，占用那本就少得可怜的空间，整的人很不好。甚至于有次我同步了桌面后，桌面上所有东西都没了，然后通过“取消链接到此电脑”以及退出OneDrive，桌面上的东西才又回来……</p>\n<p>​\t\t想到了OneDrive，是因为它确实很不像一个云盘。国内的很多网盘，需要先在桌面找到客户端，然后双击，登录，可能还要收个验证码，此时又要拿出手机收短信或者扫码，然后看着网盘里的文件，思考位置在哪里(如果比较熟练也可以跳过这个步骤)，然后下载，然后到本地去查看，有时候可能下到C盘，还要找地方移动文件……</p>\n<p>​\t\t之前有搞过阿里云盘的本地挂载，虽然最后也不了了之，但是感觉OneDrive运用了这种思路。以下我个人认为的OneDrive的一些特点：</p>\n<ol>\n<li>它不需要一个很复杂花哨的客户端，也不需要每次登录的验证，借助微软账户就能开机自动登录，也就是说只要开了机，就能登录，因为用的是一个账户。</li>\n<li>OneDrive的文件既存在云上，也有本地，但是这种本地不像百度网盘这种，需要现打开客户端下载文件，而是自动同步。这有些类似于手机的自动同步功能，包括相册同步以及iCloud的同步。但感觉还有些不同：一个是手机相册很少有修改的场景，大多数是往里加加加照片；另一个是手机同步往往要打开客户端，有后台才能同步，但是手机这种工具以及使用场景来说，往往几周才打开一些冷门软件，所以同步也不及时。</li>\n<li>OneDrive几乎没有界面UI上的学习成本，它借助于微软Windows操作系统，直接内嵌在原本的文件系统内，就像是把云端的文件目录挂载到了本地，并且能够实时更新。只要见过微软的文件系统长什么样，用OneDrive完全不陌生。所以在UI上，就像是在浏览电脑本地上一个磁盘一样。对于具体文件，一般存到云中，等到下载下来，就还是存在本地磁盘。</li>\n<li>对于每个文件，都有三种情况，下载、始终保存、释放。文件目录会在各个设备上实时自动更新，一般情况下，文件既然是从电脑A上传的，那么肯定在电脑A上，同时电脑B的文件目录也会自动更新，这时带着电脑B出去，只需要双击这个文件，就能自动从云端下载，然后打开，就彷佛它本来就在电脑B中一样。</li>\n</ol>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>​\t\tOneDrive会在第一次登陆的时候让用户选择一个本地的路径，这就是自动同步的OneDrive文件夹，默认路径为“C:\\用户[用户名]”。除了这个，“桌面”“文档”与“图片”文件夹也是可以自动同步的，只不过用户可以手动选择。</p>\n<p>​\t\t一般地，将需要同步的文件或文件夹放入上述四个文件夹内，即可实现本地与OneDrive云端的文件同步。如果我们需要同步电脑中其它位置的文件或文件夹，可以将他们直接复制粘贴到上面四个文件夹内，但比较麻烦。因此，我们可以借助mklink 命令实现。（具体操作网络上有很多教程，此处不再赘述）</p>\n<p><code>mklink /d &quot;Link&quot; &quot;Target&quot;</code></p>\n<p>注意需要管理员权限。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>​\t\t有了这些准备，我将本地的一些必要的文件夹都上传到了OneDrive中，几万个文件花了几个小时才传完。然后笔记本就能无缝衔接主机之前的工作，主机也能无缝衔接笔记本的工作。</p>\n<p>​\t\t不过还有另外一个很意外的惊喜：隔离期间用笔记本搭建了这个博客，回家后又开始使用主机，于是萌生了把博客文件夹也上传到OneDrive的想法。用笔记本把所有博客需要的文件都上传到OneDrive后，因为主机之前也装过nodejs和hexo，git这些软件，所以相当于文件和环境都有了。然后这时候再生成一个密钥，和GitHub认证一下，相当于主机本地密钥和GitHub也配对了，竟然可以直接在主机上写博客发布文章了！</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​\t\t不得不说，当有了多个设备后，同步的需求几乎是立刻就会产生。今日大谈OneDrive，绝无踩一捧一之意。实事求是来讲，多电脑同步的场景下，这种映射成为本地文件夹+自动同步确实很舒服。OneDrive也确实很适合个人在电脑上使用。</p>\n<p>​\t\t不过OneDrive确实也有很多问题，比如网络方面，以及它绝无法取代百度网盘，因为OneDrive并没有在国内构建起以社交网络为基础的共享生态，而百度网盘借助于微信小程序，成功渗透进了微信的社交网络中。即使OneDrive有共享功能，但是相比之下，可能大多数人还是更喜欢扫二维码吧，毕竟老板同事都在用百度网盘传文件，你又能做何选择呢？</p>\n","categories":["Geek"],"tags":["技术","OneDrive"]},{"title":"override v.s. overload v.s. overwrite","url":"/post/9e1da285.html","content":"<p>简单讲讲C++与Java中的overload，overwrite，override的概念</p>\n<span id=\"more\"></span>\n\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p><code>stackoverflow:</code></p>\n<p>In C++ terminology, you have <em>overriding</em> (relating to virtual methods in a class hierarchy) and <em>overloading</em> (related to a function having the same name but taking different parameters). You also have <em>hiding</em> of names (via explicit declaration of the same name in a nested declarative region or scope).</p>\n<p>The C++ standard does not use the term “overwrite” except in its canonical English form (that is, to replace one value with a new value, as in the assignment <code>x = 10</code> which overwrites the previous value of <code>x</code>).</p>\n<p>也就是说，C++中在函数层面，并没有overwrite的概念。</p>\n<p>overloading，函数重载，更多适应于在面向过程编程时，<code>函数名相同</code>但是<code>参数列表不同</code>的函数。（注：重载的返回值可以不同，因为返回值并不是区分重载函数的条件。之所以不是，是因为并不是每次调用函数都会接收返回值，返回值只是一种状态）。</p>\n<p>override，函数重写，也称为覆盖，适用于在面向对象编程，并且使用到了继承的类结构体系时，子类重写父类方法，此时<code>函数名相同</code>并且<code>参数列表相同</code>。</p>\n<p>overwrite，类似hiding隐藏的概念，针对变量，可以重新赋值，就是隐藏了之前的值；针对文件，也是类似。</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><p>与C++基本相同。也有重写与重载的区别。</p>\n<p>重载：由于Java完全面向对象，因此没有面向过程的编程。所以重载，就只是在<code>一个类的内部</code>，<code>函数名一样</code>但是<code>参数列表不同</code>。</p>\n<p>重写：子类重写父类的<code>同名同参数</code>方法，java5以后还支持重写返回值（返回值可以不同）。如果返回值也一样，这种特殊的重写称为重构。</p>\n<p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p><a href=\"https://stackoverflow.com/questions/4738315/c-overriding-overwriting\">https://stackoverflow.com/questions/4738315/c-overriding-overwriting</a></p>\n<p><a href=\"https://www.runoob.com/java/java-override-overload.html\">https://www.runoob.com/java/java-override-overload.html</a></p>\n","categories":["Geek"],"tags":["C++","Developer","技术","Java"]},{"title":"java 学习笔记","url":"/post/eef4f581.html","content":"<p>持续更新。。。</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>JDK：Java Development Toolkit，JDK包括JRE（Java Runtime Environment）</p>\n</li>\n<li><p>Java中只有两种类型：基本类型和引用类型。引用类型引用对象（reference to object），而基本类型直接包含值（directly contain value）。所有类的&#x3D;都是引用，所以会互相影响。</p>\n</li>\n<li><p>Java中字符串是不可变的，都是通过引用去操作对象实例</p>\n</li>\n<li><p>数组为定长，不能增减</p>\n</li>\n<li><p>Java是面向对象的语言，Java的类把方法与数据连接在一起，构成了自包含式的处理单元。为了将基本类型也能当作对象去处理，Java为每个基本类型都提供了包装类，从而当作对象处理。</p>\n</li>\n<li><p>equal的默认方法是使用“&#x3D;&#x3D;”运算符去比较两个对象的引用地址，而不是去比较内容。如果想要对于自定义的类也去使用equal，那么需要重写该方法，从而比较内容。</p>\n</li>\n<li><p>向上转型，即子类对象赋值给引用父类的变量。背后思想在于“平行四边形也是一种四边形”，所以很自然地可以将平行四边形看作是一种四边形。这是从具体类到抽象类的转换，所以总是安全的。这也是多态机制的基本思想，也是工厂模式的基础。而在向下转型时，是将具体类赋值给一个引用抽象类的变量，会出问题，我们必须通过显式类型转换，告诉编译器，这个抽象类也是一个具体类，才不会出错（感觉就像是把父类没有的成员变量与方法声明了一下）</p>\n</li>\n<li><p>Java 的关键字都是小写，比如instanceof，能够检测一个对象到底是不是一个类的实例。</p>\n</li>\n<li><p>一切都是对象，为了得到某个对象，我们需要一个 key，通常这是reference。</p>\n</li>\n<li><p>增强型for循环，只能读，不能改，因为每次得到的元素都是一份copy</p>\n</li>\n<li><p>可预测型字符串，推荐用string builder</p>\n</li>\n<li><p>signature &#x3D; function name + params</p>\n</li>\n<li><p>Java一直都是pass by value</p>\n</li>\n<li><p>模糊参数，用int…，本质是一个array</p>\n</li>\n<li><p>在多态中，继承抽象类的所有子类需要重写父类的抽象方法。但是同样会有冗余代码。比如某个子类可能不需要这个抽象方法，但是又不得不重写。如果将不需要的分出一个抽象类，又会出现多继承。于是有了接口的概念。哪个类需要这个方法，哪个类就去实现这个接口。同时注意在接口中定义的任何字段默认都是static和final的。</p>\n</li>\n<li><p>向上转型为抽象接口也可，不仅是抽象类</p>\n</li>\n<li><p>Java不允许多重继承，但是使用接口就可以实现多重继承</p>\n</li>\n<li><p>被声明为final的对象引用只能指向唯一 一个对象，不能指向其他的对象。但由于一个对象本身的值是可变的，因此真正不可变，可以用<code>static final</code>，通过static，在内存中开辟恒定内存，保持不变。</p>\n</li>\n<li><p>Java中的全局常量，通常都是<code>public static final</code></p>\n</li>\n<li><p>定义为final的方法是不能被重写的。</p>\n</li>\n<li><p>内部类的实例必须要绑定在外部类的<strong>实例</strong>（注意不是外部类）上，内部类可以用外部类的东西，外部类<strong>不能</strong>用内部类的东西。</p>\n</li>\n<li><p>由于Java是面向对象的语言，所以在Java中异常也是以类的实例的形式出现的。</p>\n</li>\n<li><p>try结构发生异常后，直接执行catch的语句与之后的，try中异常语句后的不再执行。</p>\n</li>\n<li><p>在抛出异常的方法中处理异常，可以直接使用try-catch结构，而在方法的声明处写出throws结构，并给出要抛出的异常，是要把异常抛给方法调用者。然后在方法的调用处，因为可能会有异常，还是要有一个try-catch</p>\n</li>\n<li><p>throws是在方法声明处，可声明多个，可以一层一层向上抛出，但是始终要有处理的；</p>\n</li>\n<li><p>throw是在方法体内，执行到throw立刻停止，如果方法体内抛异常，则需要在声明里写出throws，之后再调用者处理。</p>\n</li>\n<li><p>所以写了throw就必须要写throws，但是写了throws可以不写throw。</p>\n</li>\n<li><p>一个try可以跟多个catch，对应不同的异常。</p>\n</li>\n<li><p>使用List集合时候通常声明为List类型，然后通过不同的实现类来实例化该集合。</p>\n</li>\n<li><p>Java反射可以在程序中访问已经装载到JVM中的Java对象的描述</p>\n</li>\n<li><p>Methods called from constructors should generally be declared final. 如果子类有重载A，并且A在父类构造函数中被调用，那么会调用子类的重写版函数，但是子类在此时尚未被实例化。所以在构造函数中调用的，需要被定义成final（推荐），是为了子类不会重写，将来调用的时候出现多态。</p>\n</li>\n<li><p>If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass <em>hides</em> the one in the superclass.</p>\n<p>The distinction between hiding a static method and overriding an instance method has important implications:</p>\n<ul>\n<li>The version of the overridden instance method that gets invoked is the one in the subclass.</li>\n<li>The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.</li>\n</ul>\n</li>\n<li><p>Methods called from constructors should generally be declared final.（引入如果调用一个普通函数，然后这个函数在子类中被重写了，那么子类在实例化时，由于多态，在父类中就会调用子类重写的函数，但是此时子类还没有被实例化出来，容易出问题）</p>\n</li>\n<li><p>抽象类和接口：</p>\n<ul>\n<li>抽象类：<ul>\n<li>want to share code among several closely related classes</li>\n<li>expect that classes extending the abstract class have many common methods or fields, or require access modifiers other than public</li>\n<li>want to declare non-static or non-final fields</li>\n</ul>\n</li>\n<li>接口<ul>\n<li>unrelated classes would implement your interface</li>\n<li>want to specify the behavior of a particular data type, but not concerned about who implements its behavior</li>\n<li>multiple inheritance</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计（C++11 开始（2011 年的时候）,C++就引入了多线程库），而 Java 语言却提供了多线程支持</p>\n</li>\n<li><p>Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便</p>\n</li>\n<li><p>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</p>\n</li>\n<li><p>Java 中，JVM 可以理解的代码就叫做字节码。不面向任何特定的处理器，只面向虚拟机。通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的）</p>\n</li>\n<li><p>.java -》javac编译 - 》.class文件 - 》解释器&amp;JIT - 》机器可以理解的代码。<code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>\n</li>\n<li><p>Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>\n</li>\n<li><p><strong>代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。</strong></p>\n</li>\n<li><p>静态方法为什么不能调用非静态方法：静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>\n</li>\n<li><p>可变参数只能作为函数的最后一个参数</p>\n</li>\n<li><p>包装类型可用于泛型，而基本类型不可以。</p>\n</li>\n<li><p>几乎所有对象实例都存在于堆中。</p>\n</li>\n<li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。<code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>\n</li>\n<li><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法（比如intValue，floatValue）。</p>\n</li>\n<li><p>性能差异是来自于这个语言的执行机制，而不是这个语言采用的编程范式。</p>\n</li>\n<li><p>new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>\n</li>\n<li><p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</p>\n</li>\n<li><p>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</p>\n</li>\n<li><p>Java 有两种数据类型，一种是基本类型，比如说 int，另外一种是引用类型，比如说 String。基本类型的变量存储的都是实际的值，而引用类型的变量存储的是对象的引用——对象在内存中的地址。值和引用存储在 stack中，而对象存储在 heap中。基本数据类型的值直接存储在栈中，每当作为参数传递时，都会将原始值（实参）复制一份新的出来，给形参用。形参将会在被调用方法结束时从栈中清除。每当引用类型作为参数传递时，都会创建一个对象引用（实参）的副本（形参），该形参保存的地址和实参一样。</p>\n</li>\n<li><p>The terms “pass-by-value” and “pass-by-reference” are talking about <em>variables.</em> Pass-by-value means that the <em>value</em> of a variable is passed to a function&#x2F;method. Pass-by-reference means that a <em>reference</em> to that variable is passed to the function. The latter gives the function a way to change the contents of the variable.</p>\n</li>\n<li><p>By those definitions, Java is always <strong>pass-by-value</strong>. Unfortunately, when we deal with variables holding objects we are really dealing with object-handles called <em>references</em> which are passed-by-value as well. </p>\n</li>\n<li><p>创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>\n</li>\n</ul>\n<h2 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h2><ul>\n<li><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。</p>\n</li>\n<li><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次</p>\n</li>\n<li><p>用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p>\n</li>\n<li><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork&#x2F;Join 框架（JSR166y）来拆分任务和加速处理过程。</p>\n</li>\n</ul>\n<h2 id=\"Write-and-Read-File\"><a href=\"#Write-and-Read-File\" class=\"headerlink\" title=\"Write and Read File\"></a>Write and Read File</h2><ul>\n<li><p>When constructing a reader or writer object, the default character encoding of the operating system is used</p>\n</li>\n<li><pre><code class=\"java\">FileReader reader = new FileReader(&quot;MyFile.txt&quot;);\nFileWriter writer = new FileWriter(&quot;YourFile.txt&quot;);\n<figure class=\"highlight vhdl\"><table><tr><td class=\"code\"><pre><code class=\"hljs vhdl\"><br>-   <span class=\"hljs-keyword\">if</span> we want <span class=\"hljs-keyword\">to</span> <span class=\"hljs-keyword\">use</span> a specific charset, <span class=\"hljs-keyword\">use</span> an **InputStreamReader** <span class=\"hljs-keyword\">or</span> **OutputStreamWriter** instead. <br><br>-   ```java<br>    InputStreamReader reader = <span class=\"hljs-keyword\">new</span> InputStreamReader(<br>              <span class=\"hljs-keyword\">new</span> FileInputStream(<span class=\"hljs-string\">&quot;MyFile.txt&quot;</span>), <span class=\"hljs-string\">&quot;UTF-16&quot;</span>);<br></code></pre></td></tr></table></figure>\n</code></pre>\n</li>\n<li><p>In case we want to use a <strong>BufferedReader</strong>, just wrap the <strong>InputStreamReader</strong> inside</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-type\">InputStreamReader</span> <span class=\"hljs-variable\">reader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">InputStreamReader</span>(<br>          <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FileInputStream</span>(<span class=\"hljs-string\">&quot;MyFile.txt&quot;</span>), <span class=\"hljs-string\">&quot;UTF-16&quot;</span>);<br><span class=\"hljs-type\">BufferedReader</span> <span class=\"hljs-variable\">bufReader</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BufferedReader</span>(reader);<br></code></pre></td></tr></table></figure></li>\n</ul>\n","categories":["Geek"],"tags":["Developer","技术","Java"]},{"title":"Linux Learning","url":"/post/49b9d038.html","content":"<h2 id=\"Linux-基础操作\"><a href=\"#Linux-基础操作\" class=\"headerlink\" title=\"Linux 基础操作\"></a>Linux 基础操作</h2><ul>\n<li><code>cd -</code> : return last directory</li>\n<li><code>cp</code>: 复制 + 粘贴 + 重命名</li>\n<li><code>mv</code>: 剪切 + 粘贴 + 重命名</li>\n<li><code>mkdir a/b/c -p</code>: -p: make parent directory as needed.</li>\n</ul>\n<h2 id=\"tmux\"><a href=\"#tmux\" class=\"headerlink\" title=\"tmux\"></a>tmux</h2><ul>\n<li>分屏</li>\n<li>后台运行</li>\n</ul>\n<p>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。</p>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><ul>\n<li><code>tmux</code> : 新建一个session，window，pane，pane里有个shell</li>\n<li>左右分屏：<code>ctrl + a , %</code></li>\n<li>上下分屏：<code>ctrl + a , &quot;</code></li>\n<li>关闭pane：<code>ctrl + d</code></li>\n<li>选择pane：<code>ctrl + a , direction key</code></li>\n<li>改变pane大小：鼠标拖</li>\n<li>全屏&#x2F;取消：<code>ctrl + a , z</code></li>\n<li>挂起session：<code>ctrl + a , d</code></li>\n<li>打开之前的session：<code>tmux a</code></li>\n<li>选择其他session：<code>ctrl + a, s , direction key</code></li>\n<li>创建新window：<code>ctrl + a , c</code></li>\n<li>选择其他window：<code>ctrl + a , w</code></li>\n<li>复制粘贴：<code>ctrl + a , [ , select text, ctrl + a , ]</code></li>\n</ul>\n<h2 id=\"Vim\"><a href=\"#Vim\" class=\"headerlink\" title=\"Vim\"></a>Vim</h2><h3 id=\"操作-1\"><a href=\"#操作-1\" class=\"headerlink\" title=\"操作\"></a>操作</h3><ul>\n<li>i：编辑</li>\n<li>esc：进入一般命令</li>\n<li>光标移动：方向键</li>\n<li>n+space：光标右移n个字符，自动换行</li>\n<li>n+enter：光标下移n行</li>\n<li>0&#x2F;home：光标到本行开头</li>\n<li>$&#x2F;end：本行结尾</li>\n<li>G：最后一行</li>\n<li>:n&#x2F;nG：光标移动到第n行</li>\n<li>gg：光标到第一行， &#x3D;&#x3D; 1G</li>\n<li>&#x2F;word：光标以后查找word字符串</li>\n<li>?word：光标前查找word字符串</li>\n<li>n：重复前一个查找</li>\n<li>N：重复后一个查找</li>\n<li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：在n1行到n2行之间寻找word1，并将该字符串替换为word2</li>\n<li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：全文word1换成word2</li>\n<li>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：全文替换，并且替换前需要用户确认</li>\n<li>v：选择文本</li>\n<li>d：删除文本</li>\n<li>dd：删除当前行</li>\n<li>y：复制选中的文本</li>\n<li>yy：复制当前行</li>\n<li>p：将复制的数据在光标下一行 &#x2F; 下一个位置粘贴</li>\n<li>u：撤销</li>\n<li>ctrl + r：取消撤销</li>\n<li>大于号 &gt; ：选中的文本整体向右缩进，小于号相反</li>\n<li>: ——进入命令行模式</li>\n<li>:w：保存</li>\n<li>:w!：强制保存</li>\n<li>:q ：退出</li>\n<li>:q! ：强制退出</li>\n<li>:wq：保存并退出</li>\n<li>:set nu：显示行号</li>\n<li>:set nonu ：隐藏行号</li>\n<li>gg&#x3D;G：全文格式化</li>\n<li>:noh : 关闭查找关键词高亮</li>\n<li>ctrl + q ：vim卡死，强制退出</li>\n</ul>\n","categories":["Geek"],"tags":["技术","Linux","Vim"]},{"title":"reference in c++ and c#","url":"/post/8a2f0ada.html","content":"<p>浅谈一下C#与C++中引用的区别</p>\n<span id=\"more\"></span>\n\n<p>C# 中有两种类型：引用类型和值类型。  引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（in、ref 和 out 参数变量除外——</p>\n<p><code>in</code> 关键字会导致按引用传递参数，但确保未修改参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它类似于 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref\">ref</a> 或 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier\">out</a> 关键字，不同之处在于 <code>in</code> 参数无法通过调用的方法进行修改。 <code>out</code> 参数必须由调用的方法进行修改，这些修改在调用上下文中是可观察的，而 <code>ref</code> 参数是可以修改的， 同时<code>ref</code> 要求在传递之前初始化变量。）</p>\n<h2 id=\"按值传递引用类型\"><a href=\"#按值传递引用类型\" class=\"headerlink\" title=\"按值传递引用类型\"></a>按值传递引用类型</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types\">引用类型</a>的变量不直接包含其数据；它包含对其数据的引用。 如果按值传递引用类型参数，则<strong>可能更改属于所引用对象的数据</strong>，例如类成员的值。 但是，<strong>不能更改引用本身的值</strong>；例如，不能使用相同引用为新对象分配内存，并将其保留在方法外部。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><code class=\"hljs c#\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PassingRefByVal</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Change</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>[] pArray</span>)</span><br>    &#123;<br>        pArray[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">888</span>;  <span class=\"hljs-comment\">// This change affects the original element.</span><br>        pArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">5</span>] &#123;<span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-4</span>&#125;;   <span class=\"hljs-comment\">// This change is local.</span><br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Main</span>()</span><br>    &#123;<br>        <span class=\"hljs-built_in\">int</span>[] arr = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class=\"hljs-number\">0</span>]);<br><br>        Change(arr);<br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/* Output:</span><br><span class=\"hljs-comment\">    Inside Main, before calling the method, the first element is: 1</span><br><span class=\"hljs-comment\">    Inside the method, the first element is: -3</span><br><span class=\"hljs-comment\">    Inside Main, after calling the method, the first element is: 888</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>在C++中，结果如下：</p>\n<p>如图：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">changeArray</span><span class=\"hljs-params\">(std::vector&lt;<span class=\"hljs-type\">int</span>&gt; a)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); ++i)<br>    &#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>    a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">999</span>;<br>    a = vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123; <span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span> &#125;;<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; a&#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span> &#125;;<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">changeArray</span>(a);<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出为</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><code class=\"hljs diff\">1<br>1 2 3<br><span class=\"hljs-deletion\">-1</span><br>1<br></code></pre></td></tr></table></figure>\n\n<p>可以看出C#自动传递引用类型，只不过按照值传递；而C++则是调用复制构造函数，直接产生一个新的数组，对函数外没有影响。</p>\n<h2 id=\"按引用传递引用类型\"><a href=\"#按引用传递引用类型\" class=\"headerlink\" title=\"按引用传递引用类型\"></a>按引用传递引用类型</h2><p>除了 <code>ref</code> 关键字添加到方法标头和调用，以下示例与上述示例相同。 方法中所作的任何更改都会影响调用程序中的原始变量。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><code class=\"hljs C#\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PassingRefByRef</span><br>&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Change</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">ref</span> <span class=\"hljs-built_in\">int</span>[] pArray</span>)</span><br>    &#123;<br>        <span class=\"hljs-comment\">// Both of the following changes will affect the original variables:</span><br>        pArray[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">888</span>;<br>        pArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">5</span>] &#123;<span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-3</span>, <span class=\"hljs-number\">-4</span>&#125;;<br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Main</span>()</span><br>    &#123;<br>        <span class=\"hljs-built_in\">int</span>[] arr = &#123;<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>&#125;;<br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class=\"hljs-number\">0</span>]);<br><br>        Change(<span class=\"hljs-keyword\">ref</span> arr);<br>        System.Console.WriteLine(<span class=\"hljs-string\">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class=\"hljs-number\">0</span>]);<br>    &#125;<br>&#125;<br><span class=\"hljs-comment\">/* Output:</span><br><span class=\"hljs-comment\">    Inside Main, before calling the method, the first element is: 1</span><br><span class=\"hljs-comment\">    Inside the method, the first element is: -3</span><br><span class=\"hljs-comment\">    Inside Main, after calling the method, the first element is: -3</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p>C++如下：（在上面C++的代码中加了一个&amp;）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">changeArray</span><span class=\"hljs-params\">(std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; a)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.<span class=\"hljs-built_in\">size</span>(); ++i)<br>    &#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class=\"hljs-string\">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;<span class=\"hljs-string\">&quot;\\n&quot;</span>;<br>    a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">999</span>;<br>    a = vector&lt;<span class=\"hljs-type\">int</span>&gt;&#123; <span class=\"hljs-number\">-1</span>,<span class=\"hljs-number\">23</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span> &#125;;<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    vector&lt;<span class=\"hljs-type\">int</span>&gt; a&#123; <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span> &#125;;<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>    <span class=\"hljs-built_in\">changeArray</span>(a);<br>    std::cout &lt;&lt; a[<span class=\"hljs-number\">0</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><code class=\"hljs diff\">1<br>1 2 3<br><span class=\"hljs-deletion\">-1</span><br><span class=\"hljs-deletion\">-1</span><br></code></pre></td></tr></table></figure>\n\n\n\n<p>C++ 应该是没有值类型和引用类型的说法的（或者说不存在与 C# 的引用类型和值类型相对应的概念）。但是 C++ 类型的行为默认是 C# 中值类型的行为。</p>\n<p>比如函数传递参数时，C++ 和 C# 的值类型都会把参数完整复制一份。C++ 往往用传递 const 引用的方式来省去复制的开销。而 C# 可以用 ref 关键词来传递值类型的引用。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>上述只是简单描述了其区别，但对原理尚未搞清楚，希望等到对引用了解深入以及进一步学习后再来看C++与C#的区别。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters\">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref\">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref</a></p>\n<p><a href=\"https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/\">https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</a></p>\n","categories":["Geek"],"tags":["C++","Developer","Programming","技术","C#"]},{"title":"blogOasis的诞生","url":"/post/bc97fc50.html","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>说来惭愧，这是第4次搞博客了，前几次均以流产为终点。</p>\n<p>所幸这次应该是走运了，配置成功</p>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>其中教程参考颇多，重点有以下几个，留作纪念：</p>\n<p><a href=\"https://www.cnblogs.com/zhouyu2017/p/6485265.html\">安装Node JS – Windows</a></p>\n<p><a href=\"https://www.cnblogs.com/mingyue5826/p/11141324.html\">安装Git以及配置SSH</a></p>\n<p>(注：对于上面的SSH的两个密钥，我是这么考虑的：本地生成能够一一对应的共有密钥和私有密钥，私有存在本地，公有放在Github上。等提交更改时，用本地的私有与Github的共有密钥去进行匹配，这样既方便的同时也更安全——不用每次输入密码，防止忘记密码，并且单看长度也比自己的密码安全多了)</p>\n<p>之后安装Hexo，在本地初始化文件夹存放博客，此处略过</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>其中由于之前有次安装博客但是夭折，遇到了一个历史遗留问题：</p>\n<p>存储库的访问被拒绝</p>\n<p><img src=\"C:\\Users\\voice\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220530230105921.png\" alt=\"image-20220530230105921\"></p>\n<p>因为我之前用另一个邮箱尝试建立过博客，这次用的新邮箱</p>\n<p>关于这个问题，网络上有很多说法，并且也都成功解决了，链接如下：</p>\n<p><a href=\"https://stackoverflow.com/questions/47465644/github-remote-permission-denied\">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p>\n<p><a href=\"https://blog.csdn.net/klxh2009/article/details/76019742\">https://blog.csdn.net/klxh2009/article/details/76019742</a></p>\n<p>我甚至重装了Git</p>\n<p>但是并不适合于我</p>\n<p>最后幸好有一位大佬相助，指出可能是https和ssh之间不能直接通用</p>\n<p>于是在config.yml的配置文件中，把最后deploy的repo部分由https改成了ssh的链接，最终成功。</p>\n<p>泪目！</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>此博客来之不易，希望以后能多写博客，好好珍惜。</p>\n","categories":["Geek"],"tags":["博客"]},{"title":"动态规划之爬楼梯","url":"/post/29a0832b.html","content":"<p>爬楼梯的三种题型</p>\n<span id=\"more\"></span>\n\n<!-- more -->\n\n<!-- more -->\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><code class=\"hljs excel\">question1：<br>假设你正在爬楼梯。需要<span class=\"hljs-built_in\">n</span>阶才能到达楼顶。<br>每次可以爬<span class=\"hljs-number\">1</span>或<span class=\"hljs-number\">2</span>个台阶。有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure>\n\n<p>当我们站在第n层台阶时，只能是由n-1阶或者n-2阶跳上去的。因此我们需要保存到达n-1和n-2级台阶的方法数。不妨设置大小为n+1的数组dp（dynamic programming），其中dp[i]代表到达第i级台阶的方法数。由上可知，有dp[i]&#x3D;dp[i-1]+dp[i-2]，不难看出此数组即位斐波那契数列。<br>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">solution1</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">3</span>)&#123;<br>        std::cout &lt;&lt; n;<span class=\"hljs-comment\">// 直接判断</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> dp[<span class=\"hljs-number\">51</span>] = &#123;&#125;; <span class=\"hljs-comment\">// 假设最多50级台阶</span><br>    dp[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">2</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt;= n; i++) &#123;<br>        dp[i] = dp[i - <span class=\"hljs-number\">1</span>] + dp[i - <span class=\"hljs-number\">2</span>];<br>    &#125;<br>    std::cout &lt;&lt; dp[n] &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>由于对于每一个台阶，只需要保存前一级台阶和前两级台阶，因此只需要两个变量的空间即可。</p>\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">solution2</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">3</span>)&#123;<br>        std::cout &lt;&lt; n;<span class=\"hljs-comment\">// 直接判断</span><br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <span class=\"hljs-type\">int</span> pre = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> prePre = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-type\">int</span> result = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt;= n; i++) &#123;<br>        result = pre + prePre;<br>        prePre = pre;<br>        pre = result;<br>    &#125;<br><br>    std::cout &lt;&lt; result &lt;&lt; std::endl;<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"提高\"><a href=\"#提高\" class=\"headerlink\" title=\"提高\"></a>提高</h2><figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><code class=\"hljs gcode\">questio<span class=\"hljs-symbol\">n2</span>：<br>爬楼梯。<br>每次可以爬<span class=\"hljs-number\">1</span>或<span class=\"hljs-number\">2</span>个台阶，并且不能连续跳两次二级台阶，有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure>\n\n<p>由于对两阶的连续性作出了限制，因此我们除了保存<strong>跳跃之前在哪一级台阶</strong>之外，还需要保存前一次是否跳了两阶。此时不妨设一个二维数组，对于<code>dp[i][j]</code>而言，其中i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**。最终到第n级台阶的总数就是<code>dp[n][0]+dp[n][1]</code>。对于第i级台阶来说，满足以下关系：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"code\"><pre><code class=\"hljs inform7\">dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[0]</span>=dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[0]</span>+dp<span class=\"hljs-comment\">[i-1]</span><span class=\"hljs-comment\">[1]</span>;<br>dp<span class=\"hljs-comment\">[i]</span><span class=\"hljs-comment\">[1]</span>=dp<span class=\"hljs-comment\">[i-2]</span><span class=\"hljs-comment\">[1]</span>;<br></code></pre></td></tr></table></figure>\n\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">solution3</span><span class=\"hljs-params\">()</span> </span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">3</span>)<br>    &#123;<br>        std::cout &lt;&lt; n;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> dp[<span class=\"hljs-number\">51</span>][<span class=\"hljs-number\">2</span>] = &#123;&#125;; <span class=\"hljs-comment\">//i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，dp[i][j]就代表连续j次跳了两级台阶后到达第i级台阶的方法数，j只能是0或1</span><br>    <span class=\"hljs-comment\">//所以最后返回dp[n][0]+dp[n][1]</span><br>    <span class=\"hljs-comment\">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]</span><br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br><br>    dp[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br><br>    dp[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt;= n; i++) &#123;<br>        dp[i][<span class=\"hljs-number\">0</span>] = dp[i - <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] + dp[i - <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>]; <span class=\"hljs-comment\">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有2种情况，分别是0次两级，1次两级</span><br>        dp[i][<span class=\"hljs-number\">1</span>] = dp[i - <span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是之前跳了一级然后到的前两级</span><br><br>    &#125;<br><br>    std::cout &lt;&lt; dp[n][<span class=\"hljs-number\">0</span>] + dp[n][<span class=\"hljs-number\">1</span>];<br>    <span class=\"hljs-keyword\">return</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"拓展一\"><a href=\"#拓展一\" class=\"headerlink\" title=\"拓展一\"></a>拓展一</h2><figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><code class=\"hljs gcode\">questio<span class=\"hljs-symbol\">n3</span>：<br>爬楼梯。<br>每次可以爬<span class=\"hljs-number\">1</span>或<span class=\"hljs-number\">2</span>个台阶，并且不能连续三次跳两级台阶，有多少种不同的方法可以爬到楼顶？<br></code></pre></td></tr></table></figure>\n\n<p>与第二种情况类似，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**，j只能是0，1，或者2。从<code>dp[i][j]</code>开始，可以有两种情况，一种是跳了一级到i+1级，且跳两级台阶的次数为0，即<code>dp[i+1][0]</code>,另一种跳了两级，到i+2级台阶，跳两级台阶的次数为j+1，即<code>dp[i+2][j+1]</code> 。</p>\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">sln</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    std::cin &gt;&gt; n;<br><br>    <span class=\"hljs-keyword\">if</span> (n &lt; <span class=\"hljs-number\">3</span>)<br>    &#123;<br>        std::cout &lt;&lt; n;<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br><br>    <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> dp[<span class=\"hljs-number\">51</span>][<span class=\"hljs-number\">3</span>] = &#123;&#125;; <span class=\"hljs-comment\">//二维数组dp的第二维 0 1 2表示的是: dp[i][j] 在第i级台阶，之前是有连续j次走了二级台阶的方法数</span><br>    <span class=\"hljs-comment\">//所以到达第n阶的总方法数就是dp[n][0]+dp[n][1]+dp[n][2]</span><br>    <span class=\"hljs-comment\">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]。</span><br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>    dp[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br><br>    dp[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">0</span>;<br>    dp[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br><br>    dp[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">1</span>;<br>    dp[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">0</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt;= n; i++) &#123;<br>        dp[i][<span class=\"hljs-number\">0</span>] = dp[i - <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] + dp[i - <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>] + dp[i - <span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">2</span>]; <span class=\"hljs-comment\">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有3种情况，分别是0次两级，1次两级，2次两级</span><br>        dp[i][<span class=\"hljs-number\">1</span>] = dp[i - <span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>];<span class=\"hljs-comment\">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 为保证最近仅一次跳了两级，唯一情况是跳了一级然后到的前两级</span><br>        dp[i][<span class=\"hljs-number\">2</span>] = dp[i - <span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">1</span>];<span class=\"hljs-comment\">// 到了第i级台阶，并且之前两次都是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是跳了两级然后到的前两级</span><br>    &#125;<br><br>    std::cout &lt;&lt; dp[n][<span class=\"hljs-number\">0</span>] + dp[n][<span class=\"hljs-number\">1</span>] + dp[n][<span class=\"hljs-number\">2</span>];<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>后两种情况也同样可以 用变量代替数组，但是对于理解来说数组更友好，因此没有给出变量版本。</p>\n<h2 id=\"拓展二：最小花费\"><a href=\"#拓展二：最小花费\" class=\"headerlink\" title=\"拓展二：最小花费\"></a>拓展二：最小花费</h2><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><code class=\"hljs css\">爬楼梯。<br>从楼梯第<span class=\"hljs-selector-tag\">i</span>个台阶向上爬需要支付cost<span class=\"hljs-selector-attr\">[i]</span>的费用。<br>一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>返回爬到楼顶需要的最小花费。<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">sln</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; cost)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">auto</span> size = cost.<span class=\"hljs-built_in\">size</span>();<br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-type\">int</span>&gt; <span class=\"hljs-title\">dp</span><span class=\"hljs-params\">(size + <span class=\"hljs-number\">1</span>)</span></span>; <br>    <span class=\"hljs-comment\">// dp[i] 是到第i层后的最小花费，其中包括第i层的花费</span><br>    dp[<span class=\"hljs-number\">0</span>] = cost[<span class=\"hljs-number\">0</span>];<br>    dp[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">min</span>(cost[<span class=\"hljs-number\">1</span>], cost[<span class=\"hljs-number\">0</span>] + cost[<span class=\"hljs-number\">1</span>]);<br><br>    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">2</span>; i &lt;= size; i++) &#123;<br>        dp[i] = (i == size ? <span class=\"hljs-number\">0</span> : cost[i]) + <span class=\"hljs-built_in\">min</span>(dp[i - <span class=\"hljs-number\">1</span>], dp[i - <span class=\"hljs-number\">2</span>]);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> dp[size];<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在上面的解决方法中，将<code>cost[i]</code>放在了<code>min</code>的外面，是因为基于这样的思路：到达第<code>i</code>级台阶后将立刻花费，所以放在外面，只需关注是前一级花费小还是前两级花费小即可。</p>\n<p>到达楼顶时，由于超出<code>cost</code>的范围，因此该层花费为0。</p>\n","categories":["Geek"],"tags":["Developer","Programming","技术","算法","动态规划"]},{"title":"虚基类","url":"/post/76401623.html","content":"<h2 id=\"问题引出\"><a href=\"#问题引出\" class=\"headerlink\" title=\"问题引出\"></a>问题引出</h2><p><img src=\"https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221028155803777.png\"></p>\n<p>问题：A中数据，在D中保存了两份。</p>\n<h2 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class）</p>\n<p><img src=\"https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221028155922106.png\"></p>\n<p>虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。（本例中，虚继承只影响D，对B和C无影响）</p>\n<h2 id=\"C-实例\"><a href=\"#C-实例\" class=\"headerlink\" title=\"C++实例\"></a>C++实例</h2><p>C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。</p>\n<h2 id=\"二义性\"><a href=\"#二义性\" class=\"headerlink\" title=\"二义性\"></a>二义性</h2><p>图2中的菱形继承为例，假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：</p>\n<ul>\n<li>如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。</li>\n<li>如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。</li>\n<li>如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。</li>\n</ul>\n<h2 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h2><p>对于每一个多态类型，其所有的虚函数的地址都以一个表格的方式存放在一起，每个函数的偏移量在基类型和导出类型中均相同，这使得虚函数相对于表格首地址的偏移量在可以在编译时确定。虚函数表格的首地址储存在每一个对象之中，称为虚(表)指针(vptr)或者虚函数指针(vfptr)，这个虚指针始终位于对象的起始地址。使用多态类型的引用或指针调用虚函数时，首先通过虚指针和偏移量计算出虚函数的地址，然后进行调用。</p>\n<h3 id=\"单继承\"><a href=\"#单继承\" class=\"headerlink\" title=\"单继承\"></a>单继承</h3><p>例子：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span><br>&#123;<br>    <span class=\"hljs-type\">int</span> ax; <span class=\"hljs-comment\">// 成员变量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f0</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">B</span> : <span class=\"hljs-keyword\">public</span> A<br>&#123;<br>    <span class=\"hljs-type\">int</span> bx; <span class=\"hljs-comment\">// 成员变量</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f0</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123;&#125;; <span class=\"hljs-comment\">// 重写f0</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>内存模型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">A</span><br> <span class=\"hljs-function\">object                                            A <span class=\"hljs-title\">VTable</span> <span class=\"hljs-params\">(不完整)</span></span><br><span class=\"hljs-function\">     0 - vptr_A --------------------------------&gt;  +--------------+</span><br><span class=\"hljs-function\">     8 - <span class=\"hljs-type\">int</span> ax                                    |    <span class=\"hljs-title\">A::f0</span><span class=\"hljs-params\">()</span>   |</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">sizeof</span><span class=\"hljs-params\">(A)</span>: <span class=\"hljs-number\">16</span>    align: <span class=\"hljs-number\">8</span>                          +--------------+</span><br><span class=\"hljs-function\">                                                   |    A::f1()   |</span><br><span class=\"hljs-function\">                                                   +--------------+</span><br><span class=\"hljs-function\"></span><br><span class=\"hljs-function\">struct B</span><br><span class=\"hljs-function\"> object                                         </span><br><span class=\"hljs-function\">     <span class=\"hljs-number\">0</span> - struct A                                  B VTable (不完整)</span><br><span class=\"hljs-function\">     <span class=\"hljs-number\">0</span> -   vptr_A ------------------------------&gt;  +--------------+</span><br><span class=\"hljs-function\">     <span class=\"hljs-number\">8</span> -   int ax                                  |    B::f0()   |</span><br><span class=\"hljs-function\">    <span class=\"hljs-number\">12</span> - int bx                                    +--------------+</span><br><span class=\"hljs-function\">sizeof(A): <span class=\"hljs-number\">16</span>    align: <span class=\"hljs-number\">8</span>                          |    A::f1()   |</span><br><span class=\"hljs-function\">                                                   +--------------+</span><br></code></pre></td></tr></table></figure>\n\n<p>对于多态类型，除了要在运行时确定虚函数地址外，还需要提供运行时类型信息(Run-Time Type Identification, RTTI)的支持。一个显然的解决方案是，将类型信息的地址加入到虚表之中。为了避免虚函数表长度对其位置的影响，g++将它放在虚函数表的前。</p>\n<p>在单链继承中，每一个派生类型都包含了其基类型的数据以及虚函数，这些虚函数可以按照继承顺序，依次排列在同一张虚表之中，因此只需要一个虚指针即可。并且由于每一个派生类都包含它的直接基类，且没有第二个直接基类，因此其数据在内存中也是线性排布的，这意味着实际类型与它所有的基类型都有着相同的起始地址。</p>\n<h3 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h3><p>与单链继承不同，由于两个父类完全独立，它们的虚函数没有顺序关系，即父类的第一个函数有着相同的偏移量，不可以顺序排布。 并且父类中的成员变量也是无关的，因此基类间也不具有包含关系。这使得两个父类必须要处于<strong>两个不相交的区域</strong>中，同时需要有<strong>两个虚指针</strong>分别对它们虚函数进行索引。 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\">                                                <span class=\"hljs-function\">C <span class=\"hljs-title\">Vtable</span> <span class=\"hljs-params\">(<span class=\"hljs-number\">7</span> entities)</span></span><br><span class=\"hljs-function\">                                                +--------------------+</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">struct</span> C                                        | <span class=\"hljs-title\">offset_to_top</span> <span class=\"hljs-params\">(<span class=\"hljs-number\">0</span>)</span>  |</span><br><span class=\"hljs-function\">object                                          +--------------------+</span><br><span class=\"hljs-function\">    0 - <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">A</span> <span class=\"hljs-params\">(primary base)</span>                 |     RTTI <span class=\"hljs-keyword\">for</span> C     |</span><br><span class=\"hljs-function\">    0 -   vptr_A -----------------------------&gt; +--------------------+       </span><br><span class=\"hljs-function\">    8 -   <span class=\"hljs-type\">int</span> ax                                |       <span class=\"hljs-title\">C::f0</span><span class=\"hljs-params\">()</span>      |</span><br><span class=\"hljs-function\">   16 - <span class=\"hljs-keyword\">struct</span> B                                +--------------------+</span><br><span class=\"hljs-function\">   16 -   vptr_B ----------------------+        |       <span class=\"hljs-title\">C::f1</span><span class=\"hljs-params\">()</span>      |</span><br><span class=\"hljs-function\">   24 -   <span class=\"hljs-type\">int</span> bx                       |        +--------------------+</span><br><span class=\"hljs-function\">   28 - <span class=\"hljs-type\">int</span> cx                         |        | <span class=\"hljs-title\">offset_to_top</span> <span class=\"hljs-params\">(<span class=\"hljs-number\">-16</span>)</span>|</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">sizeof</span><span class=\"hljs-params\">(C)</span>: <span class=\"hljs-number\">32</span>    align: <span class=\"hljs-number\">8</span>              |        +--------------------+</span><br><span class=\"hljs-function\">                                       |        |     RTTI for C     |</span><br><span class=\"hljs-function\">                                       +------&gt; +--------------------+</span><br><span class=\"hljs-function\">                                                |    Thunk C::f1()   |</span><br><span class=\"hljs-function\">                                                +--------------------+</span><br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"虚继承-1\"><a href=\"#虚继承-1\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h2><p>上述的模型中，对于派生类对象，它的基类相对于它的偏移量总是确定的，因此动态向下转换并不需要依赖额外的运行时信息。</p>\n<p>而虚继承破坏了这一条件。它表示虚基类相对于派生类的偏移量可以依实际类型不同而不同，且仅有一份拷贝，这使得虚基类的偏移量在运行时才可以确定。因此，我们需要对继承了虚基类的类型的虚表进行扩充，使其包含关于虚基类偏移量的信息。</p>\n<p>还是ABCD的菱形继承：</p>\n<p>对于形式类型为<code>B</code>的引用，在编译时，无法确定它的基类<code>A</code>它在内存中的偏移量。 因此，需要在虚表中额外再提供一个实体，表明运行时它的基类所在的位置，这个实体称为<code>vbase_offset</code>，位于<code>offset_to_top</code>上方。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p>该图片由<a href=\"https://pixabay.com/zh/users/larisa-k-1107275/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=219972\">Larisa Koshkina</a>在<a href=\"https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=219972\">Pixabay</a>上发布</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/41309205\">https://zhuanlan.zhihu.com/p/41309205</a></p>\n","categories":["Geek"],"tags":["C++","Developer","Programming","技术"]},{"title":"观后感-女佣浮生录","url":"/post/f0069d9c.html","content":"<p><strong>Each kind of situation has its own solution.</strong> </p>\n<p><strong>You would never lose hope as long as you insist.</strong></p>\n<span id=\"more\"></span>\n\n<p>Inspired by <a href=\"https://en.wikipedia.org/wiki/Stephanie_Land\">Stephanie Land</a>‘s memoir <em>Maid: Hard Work, Low Pay, and a Mother’s Will to Survive.</em>  It just shocked me.</p>\n<p>What A Helpless Situation!</p>\n<p>A single mother —-</p>\n<p>She has a alcoholic husband, a mother with mental problems, a three year old daughter and a abusive boyfriend.</p>\n<p>Her life is just like a mess.</p>\n<p>What makes me sad the most is that she could have gone to college and she had won a scholarship.</p>\n<p>But just because of a man and an unexpected baby, she gave up that opportunity.</p>\n<p>  In my initial and traditional perspective, a girl is a child or a princess spoiled by her parents, at least before she enters the society and start working. But in the play, the woman could be considered to be shamed and failed. People would be shamed by her behavior and tell their children not to be like her.</p>\n<p>​\tAnd this woman and this TV series totally changed my pervious thoughts. You can always make  it through as long as there is hope in your mind and there are some kind people who are willing to help you.</p>\n<p>​\tShe accepted help from lots of people. That’s coincidence, but also for her character, she is diligent, sticks to her principles even live in other’s home, she keep in mind that she is accepting other’s help or charity. Her love for daughter impressed many persons. </p>\n<p>​\tAt the beginning I think she could been had a better life, go to the college, hang out with her friends, meet a romantic love, find a decent job. She could do so many things that belongs to youth. Just due to the man and a baby, her life is ruined. But when she said: “Daughter is my life. “ I suddenly understood that she is happy and passionate for life just because of her daughter which is her whole world. I also understood mother’s power which should be respected by everyone.</p>\n<p>​\tWhen she got the scholarship again, she felt hope for the future. But her ex-boyfriend returned her car to another man and that means she can’t go to work, she can’t make money, so she also can’t go to college. Suddenly she lost all her hope and fell into despair. I was  very worried for her at that time. And eventually, she resumed her spirit and made it through again due to her cute daughter, she took her daughter away, away that house full of alcohol and violence. She took her daughter run out of the cage which is in her mind. She showed me how powerful she is again, not only as a woman, but also as a mother.</p>\n<p>​\tIn the end, when she drove to Montana with her daughter, drove to her future full of hope,   that plot hit my heart.</p>\n<p>​\tShe said: “I’m going to drive the fuck out of the town, I’m going to drive nine hours, 566 miles to Missoula, Montana, where I’m going to spend the next four years, learning to be a writer. Hopefully, there will be a lot of happy days during that time. And I know there will be hard ones. Most people would bet against a single mom putting herself through college. But they don’t know what it took to get here. Three hundred and thirty-eight toilets cleaned, seven types of government assistance, nine separate moves, one night on the ferry-station floor, and the entire third year of my daughter’s life. But, when we got to Missoula, I’m going to take Maddy(her daughter) up Sentinel Mountain, which looks over the town, and show her new home. I’ve been telling her all about the giant ‘M’ that’s at the tippy-top of the mountain. That the trail up there is long and zig-zaggy. The hike will be hard. But we’ll make it to the top. And when we do, I’m going to tell her that the <em>‘M’ stands for ‘Maddy’.</em> That this is whole new world for her “</p>\n<p>end</p>\n","categories":["观影"],"tags":["女性","电视剧","美剧","观后感"]},{"title":"二分法核心及算法细节","url":"/post/c96d2cc6.html","content":"<h2 id=\"核心：\"><a href=\"#核心：\" class=\"headerlink\" title=\"核心：\"></a>核心：</h2><ul>\n<li><p>二分并不是仅仅用于找数字的，二分的二，其本质是两种不同的状态，通过<strong>每次排除一半</strong>来逼近两种状态的分界线。</p>\n</li>\n<li><p><strong>二分</strong>的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用<strong>二分</strong>。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"二分细节\"><a href=\"#二分细节\" class=\"headerlink\" title=\"二分细节\"></a>二分细节</h2><h3 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h3><ol>\n<li><p>所有情况均为<code>if else</code>语句，更加清晰</p>\n</li>\n<li><p>注意防止mid溢出</p>\n</li>\n</ol>\n<h3 id=\"普通二分查找\"><a href=\"#普通二分查找\" class=\"headerlink\" title=\"普通二分查找\"></a>普通二分查找</h3><p>在nums中搜索target，找到返回下标，否则返回-1.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">binarySearch</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt; nums, <span class=\"hljs-type\">int</span> target)</span> </span>&#123;<br>    <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-type\">int</span> r = nums.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// @1</span><br>    <span class=\"hljs-keyword\">while</span>(l &lt;= r) <span class=\"hljs-comment\">// @2</span><br>    &#123;<br>        <span class=\"hljs-type\">int</span> m = (r - l) / <span class=\"hljs-number\">2</span> + l;<br>        <span class=\"hljs-keyword\">if</span>(nums[m] == target) <span class=\"hljs-keyword\">return</span> m; <span class=\"hljs-comment\">// 找到元素，返回下标</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[m] &lt; target) l = m + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// @3</span><br>        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// @4</span><br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>首先要明确，二分到最后肯定是不断逼近一个数字的，类比数学上二分找函数零点的思想。</p>\n<p>上述的四处@，是四个注意的点，下面分别说一下：</p>\n<ul>\n<li><p>@1： r是<code>nums.size()</code>还是<code>nums.size()-1</code>?，这个选择其实是自由的，因为我们二分的目标在于，用尽量少的次数去找到目标值，其本质还是基于遍历的思想（不知道这么说是否准确，我的理解是，二分每次可以舍弃一半，但是这一半的舍弃我们确定不会对结果产生影响，所以舍弃，但是不能舍弃掉未知的元素。举个例子，这个nums数组有n个元素，那就必须n个元素都考虑在内，不能从第2个元素开始遍历）。既然要遍历，那么我们这里的<code>r</code>和<code>l</code>，也就是在确定遍历的范围。我们知道元素的下标是<code>0</code>到<code>nums.size()-1</code>，因此这里选择<code>nums.size()</code>还是<code>nums.size()-1</code>无所谓，<strong>只要保证搜索区间范围包含所有元素即可</strong>。对于选择<code>nums.size()</code>，那我们的搜索区间就是<code>[l,r)</code>，选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code></p>\n</li>\n<li><p>@2： <code>l &lt;= r</code>还是<code>l &lt; r</code>，这里的范围是由上面的搜索区间决定的。</p>\n<ul>\n<li><p>如果选择<code>nums.size()</code>，搜索区间是<code>[l,r)</code>，那么这里就应该是<code>l &lt; r</code>，可以用反证法，如果是<code>l &lt;= r</code>，那么如果一直向<code>r</code>逼近的话，<code>r</code>保持不变，<code>l</code>最终等于<code>r</code>，就会越界，所以是<code>l &lt; r</code>。</p>\n</li>\n<li><p>选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code>，这里应该是<code>l &lt;= r</code>，这时不怕越界，如果是<code>l &lt; r</code>的话，<code>l</code>最大也就是<code>r - 1</code>，那么会导致最后一个元素漏掉。</p>\n</li>\n<li><p>对于最后返回-1，<code>l &lt;= r</code>，终止条件是<code>l 等于 r + 1</code>，区间为空，可直接返回；但如果选择<code>l &lt; r</code>，终止条件是<code>l 等于 r</code>，但可能会漏掉一个元素（之所以可能，是因为如果<code>l</code>等于<code>r</code>等于<code>nums.size()</code>，那么无所谓，但如果是在内部，那么这个地方就没有顾及到）</p>\n</li>\n<li><p>如果数组是<code>&#123;1, 2, 3, 4, 5, 6, 7&#125;</code>，目标是3，那么就会找不到（已运行验证（注意这里说的是 <code>r=nums.size()</code>并且<code>l &lt; r</code>的循环条件）)，所以为了防止漏掉，要检查这个地方，即</p>\n</li>\n<li><p>&#96;&#96;&#96;cpp<br>if(l &lt; nums.size() &amp;&amp; nums[l] &#x3D;&#x3D; target) return l;<br>else return -1;</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"code\"><pre><code class=\"hljs autohotkey\"><br>- @<span class=\"hljs-number\">3</span>： <span class=\"hljs-number\">3</span>与<span class=\"hljs-number\">4</span>是一个问题，放在一块说。有时候是`l = m`，有时候是`l = m + <span class=\"hljs-number\">1</span>`，这里还是由于搜索空间决定的，这里左右边界的变化，决定了下一次的搜索空间。对于这个题，我们要保证所有的都遍历过，而现在`nums[m]`已经遍历过，那么不再需要遍历，下一次的空间就应该是`[l, m - <span class=\"hljs-number\">1</span>]`或者`[m + <span class=\"hljs-number\">1</span>, r]`。这是由一开始的搜索空间决定的，如果一开始是`[l, r)`，那么经过m后，要保持相同格式，就应该是`[l, m)`与<br>  <br>  `[m +<span class=\"hljs-number\">1</span>, r)`。<br><br>### 边界二分查找<br><br>上面的二分可以查到目标值，但是如果有多个目标值，我们想要第一个或者最后一个的边界值又该怎么办呢？<br><br>要在下一次的**搜索空间**上下功夫：<br><br>#### 左边界二分<br><br>核心代码：<br><br>```cpp<br>while(l &lt; r) &#123; // 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是 &lt;<br>    int m = (r - l) / <span class=\"hljs-number\">2</span> + l<span class=\"hljs-comment\">;</span><br>    if(nums[m] == target) &#123;<br>        r = m<span class=\"hljs-comment\">; // @1</span><br>    &#125; else if(nums[m] &gt; target) &#123;<br>        r = m<span class=\"hljs-comment\">; // @2，m已经验证过，但这里保持m，是为了保持[l, r)的区间格式</span><br>    &#125; else if(nums[m] &lt; target) &#123;<br>        l = m + <span class=\"hljs-number\">1</span><span class=\"hljs-comment\">; // @3</span><br>    &#125;<br>&#125;<br>if(l &lt; nums.size() &amp;&amp; nums[l] == target) <span class=\"hljs-keyword\">return</span> l<span class=\"hljs-comment\">; // 原因上面已谈及</span><br>else <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span><span class=\"hljs-comment\">;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>@1： 当我们找到一个符合条件的，由于需要找最左边的，不能直接返回，而是缩小上界。那如果只出现一次，将其放在<code>r</code>中，但最后返回<code>l</code>，有影响吗？经验证，没有影响，如果只出现一次，在第一次遇见放到<code>r</code>中，那么<code>l</code>会不断逼近直到与<code>r</code>相等（这也就是循环条件），所以最后返回<code>l</code>也是可以的。</p>\n</li>\n</ul>\n<h4 id=\"右边界二分\"><a href=\"#右边界二分\" class=\"headerlink\" title=\"右边界二分\"></a>右边界二分</h4><p>核心代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">while</span>(l &lt; r) &#123; <span class=\"hljs-comment\">// 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是&lt;</span><br>    <span class=\"hljs-type\">int</span> m = (r - l) / <span class=\"hljs-number\">2</span> + l;<br>    <span class=\"hljs-keyword\">if</span>(nums[m] == target) &#123;<br>        l = m + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// @1</span><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[m] &gt; target) &#123;<br>        r = m; <span class=\"hljs-comment\">// 同上</span><br>    &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(nums[m] &lt; target) &#123;<br>        l = m + <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 同上</span><br>    &#125;<br>&#125;<br><span class=\"hljs-keyword\">if</span>(l &gt; <span class=\"hljs-number\">0</span> &amp;&amp; nums[l - <span class=\"hljs-number\">1</span>] == target) <span class=\"hljs-keyword\">return</span> l - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// @2</span><br><span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在找右侧边界时，即最后一个，那么如果当前的m大了，为保持左闭右开，<code>r = m</code>，如果m小了，<code>l = m + 1</code>。</p>\n<p>在@1中，可以看到是增大了下届(如果这里不加1，可能会出现死循环，因为m是向下取整，在只有两个数时，无法区分，比如3和4，中点是3，如果3不符合条件则会一直循环)，这里的+1对于返回值@2产生了影响，容易看到如果只有一个数字符合，这时候<code>l</code>又加1，那么应该返回<code>l - 1</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简要介绍了关于二分法在代码实现上的相关细节， 二分法思想比较简单，但是细节很多， 需要多注意。</p>\n","categories":["Geek"],"tags":["Developer","Programming","技术","算法","二分"]},{"title":"观后感-明日、我会成为谁的女友","url":"/post/663a0935.html","content":"<p>现在，在这个东京，仅是一个人想要生存下去，就需要很大的开销了，无论是优越的环境，还是强大的意志，要是缺少其中一样，就会连普通的生活都无法维持下去，这就是现实。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>在这个充满束缚的世界里，为了尽可能活着，活下去，我要用自己的脚一步一步走下去。所以，今天，我也会是某人的女友。</p>\n<p>彼时的东京，恰如此时的xx，都是一个这样的地方：<strong>金钱流通无息稍停，欲望增长尽日奔驰</strong>。</p>\n<p>之前看过一本关于东京女性纪实的书，大体上有这样的概念，即很多在东京的女性，尤其以年轻女性为主，都在try theirs’s best to make ends meet. 在这种情况下，不能完全说风俗店或者出租女友的服务完全不合理，它终究是有个原因，是一整个社会共同造成的。在这样的情况下，女性究竟是何种命运，是什么造就了这种情况，它将如何发展下去，似乎要再次回到更加广阔的历史生物与哲学背景中。</p>\n<p>但我自然没有如此之水平，再加上我是男性的身份，就决定了我既是法官，又是当事人，也就难以客观，值得怀疑。</p>\n<p>但值得瞩目的事情在于讨论区的女性朋友们大多将重点放在了感情线与杀猪盘上，并未想要去考虑在背后与整个日本经济社会政治方面的联想，我也无法有效联想，因为知识太浅，但个人确实比较喜欢这种讲两性的剧并作出联想。</p>\n<h2 id=\"情节\"><a href=\"#情节\" class=\"headerlink\" title=\"情节\"></a>情节</h2><p>对于整体的分析比较困难，还是拿几个情节来讲吧。</p>\n<h3 id=\"雪\"><a href=\"#雪\" class=\"headerlink\" title=\"雪\"></a>雪</h3><p>第一个在于不同人对于小雪伤疤的态度，几乎所有人都带有略带怜悯的眼光去同情她，但实际上可能这种人最希望追求的是normal，不是别人特殊的眼光，特殊的照顾，而是正常看待的眼光。这种情况下，一直坚持整容变美的彩反而作出了雪最想要的反应：正常看待，觉得有问题就解决，解决时候还要注意很多东西。而另两个，一个爱情一个友情，都没有作出这种选择，而是投以怜悯的目光，或许也是身未受故感不同吧。之前觉得彩执着于整容有些过头，然而却也是自己的选择，这种情况下，你很难去以一件事情就去对一个人作出自己对他的盖棺定论，事情不断变化，人也在不断发展，我们的认识也要不断变化，这才是实事求是。</p>\n<p>在剧中最理性的好像是雪，没有不良嗜好，行为也都有界限。所有的一切都是为了生活本身，而且对于未来也有一个比较清晰的规划。不得不说其原生家庭也不容易，<strong>并不是生了孩子就能变成母亲</strong>。</p>\n<h3 id=\"萌\"><a href=\"#萌\" class=\"headerlink\" title=\"萌\"></a>萌</h3><p>第二个是沉沦的萌，她的沉沦与前面对爱情的冷漠表面矛盾对立，然则好像一体两面一样，是完全统一的。就好像弹簧一般，前期由于自己外貌与身材，加上身边人的评价，她也只能无奈接受这种设定，暂时把对于一些东西的渴望隐藏起来，但它们并没有消失。当一旦遇到某一个愿意正常待他时，她的反应只会更加剧烈，其热烈程度反而会让自己深度沉迷，最终导致受伤。正如其心中所想：“大家都在看着我，这用金钱编织的关系，这充满谎言的世界，但是，在这个世界中，我像主人公一样。”幸好最后即时发现止损。</p>\n<p>一开始萌与枫之间就只是顾客与服务者的关系，因为有这样的一个恶性循环：萌想要多见枫，但她好像只能通过投入大量金钱与其他女性竞争来达到与枫的短暂见面机会，这样的金钱又迫使着萌去发展其他业务，使自己更加空虚后，又会继续到枫身上寻找依赖与慰藉。然而如果两个人真的情投意合好似天公作美的一对，那么第一步只能通过金钱的途径就会无效，枫自然会不断找时间与萌见面，恶性循环也就无从谈起。</p>\n<p>一开始好像都很清醒，都知道只是逢场作戏，然而人心不足蛇吞象，欲望会不断增长的。见一面后就想着见两面，散步一小时后就想着吃饭两小时，最后所有的时间都换算成了高昂的价钱。</p>\n<h2 id=\"劳动、产业、起源\"><a href=\"#劳动、产业、起源\" class=\"headerlink\" title=\"劳动、产业、起源\"></a>劳动、产业、起源</h2><p>剧中的五个人的共同点在于都选择了以自己的身体作为生产资料去进行售卖身体的活劳动，一定程度上是女性占比多一些。牛郎也有，但我潜在意识中还是会觉得女性多一些，因为产业发达程度与受众数量也就是用户多少有关。在这种情况下，当女性是为了一些目标去从事这种活动时，或者只是为了make ends meet，并不会去觉得有什么不妥。因为她们也是劳动者，比起某些利用权力去为虎作伥的人来说好太多了。但这种劳动的可怕之处，在于它的易沉迷性。不管思想上多么受折磨，这样如此的高薪仍然是少有的领域，即使是互联网也难以抗衡（对于普遍人来说）（当然这里的高薪我们必须要提到关于色情行业的产业升级，无论什么行业产业链的下游都是困难的，高薪是说那些在新时代中改变营业方式吸取客人的店）在这样的高薪后面，即使有相对难缠的客人，但拿到手里的货币的重量仍然不容小觑。所以我想说的论点在于：投入产出比很高。正如那句话所说，拼命的努力是为了让成功到来时能够心安理得。与之意思相近的一点是权力要与胸怀匹配，否则会给自己和下属都带来灾难。</p>\n<p>同样的，这种行业也会带来这样的不平衡。而且这样的劳动基本完全脱离成果。来钱过快过容易必然导致跨过思想层面的门槛变得极度容易，后续也会轻而易举地进入正反馈中：赚钱-&gt;大手花钱+因劳动脱离成果产生空虚-&gt;继续花钱-&gt;钱不够-&gt;继续赚钱。</p>\n<p>劳动脱离成果后，因为没有成果的反馈，消费便十分容易地脱离掉需要，只能通过大手的花钱来证明自己的价值，不断强化自己有价值的观点，等到习惯了大手花钱后，也就只能与快速赚钱的行业相绑定了。</p>\n<p>此时又不得不搬出那句话了：“男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>然而不得不提的一点在于，这并不是相当一部分女性的初心，这种情况下，很多问题都可以通过稳健到位的社会保障机制，及时高效合理的司法，有职业道德的教育工作者这三样东西去解决。日本高昂的大学贷款逼着年轻女性拼命地用尽一切方法维持生计，这并不是这部分女性的错。</p>\n<p>这是谁的错呢？</p>\n<p>或者更重要的一点，如何解决呢？</p>\n<p>I don’t know both.</p>\n","categories":["观影"],"tags":["女性","电视剧","观后感","日剧"]},{"title":"观后感-阿尔卑斯山求生记","url":"/post/13a30ca8.html","content":"<h2 id=\"生命史诗与自然之魂！\"><a href=\"#生命史诗与自然之魂！\" class=\"headerlink\" title=\"生命史诗与自然之魂！\"></a>生命史诗与自然之魂！</h2><hr>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p><strong>天地有大美而不言</strong></p>\n<p><strong>四时有明法而不议</strong></p>\n<p><strong>万物有成理而不说</strong></p>\n<p>人类会犯错，自然不会犯错 </p>\n<p>被震撼的一次观影</p>\n<hr>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>头狼为了自己的威信，向熊发起挑战</p>\n<p>虽然最后伤病而死，但他难道输了吗？</p>\n<p>若是，那么对于生命的赢又是什么？</p>\n<p>动物也并非没有愿意用生命去捍卫的东西</p>\n<p>雌性头狼离开狼群陪伴伴侣，谁说殉情只是古老的传说？</p>\n<p>原有的狼群迅速选择新首领，谁又能说他们错了？</p>\n<p>没有首领必然意味着群体的灭亡</p>\n<p>自然不会错，只是我们难以理解</p>\n<p>雌性头狼最终离开已经死去的头狼，是不敢殉情吗？</p>\n<p>——她还怀着孩子</p>\n<p>有时候生，并非意味着幸福</p>\n<p>六甲之躯，跨越群山</p>\n<p>共计公里万余三</p>\n<p>只身孤影，克服万难</p>\n<p>没有丰富的面部表情，不意味着没有感情</p>\n<p>没有语言，不意味着没有想法</p>\n<p>在如此情况下，六只狼崽全部存活</p>\n<p>母性伟大之光辉震烁千古！</p>\n<p>我又想起了那些把孩子生在厕所里的母亲</p>\n<p>有时候精神的高尚</p>\n<p><strong>不会随着直立行走而更加高大</strong></p>\n<p><strong>亦不会随着身姿的匍匐而变得卑微</strong></p>\n<p>刚生下狼崽，碰见猞猁</p>\n<p>有些讨厌，人家刚生下孩子，你对人家幼崽虎视眈眈</p>\n<p>就不能找点别的吃的吗</p>\n<p>后来</p>\n<p>原来她也是母亲</p>\n<p>愚昧如我</p>\n<p>自然没有对错，亦无好坏</p>\n<p>走投无路的狼妈妈，将眼光看向了羊群 </p>\n<p>若是生活没有如此艰难，谁愿意铤而走险？？</p>\n<p>可生活就是这样，自前世而固然</p>\n<p>高山环境恶劣 </p>\n<p>导致残酷的竞争</p>\n<p>可是却也恰恰因为恶劣的环境</p>\n<p>合作显得尤为重要</p>\n<p>视频结尾有一段话结束</p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>在最艰难的条件下，能够生存下来的不是最强者，而是互相帮助的个体</p>\n<p>环境越恶劣，团结协作的重要性就越发凸显</p>\n<p>这就是我们从阿尔卑斯山的生物上学到的品质</p>\n<p>在这里生活，他们都知道这一点：</p>\n<p>雌性羱羊守望相助，一起照顾后代</p>\n<p>鸟类聚集一起寻找食物</p>\n<p>鹿紧紧挤在一起取暖</p>\n<p>树木为老祖宗提供养分</p>\n<p>狼为了守护族群不惜牺牲一切</p>\n<p>瑞士松依靠星鸦把种子洒满山野</p>\n<p>狼需要克服无数挑战才能与其他狼和平共处</p>\n<p>人类需要依靠驯养的犬来守卫家畜</p>\n<p>所有生物都知道自己不是最强大的</p>\n<p>大山本身都比他们强大的多</p>\n<p>所以他们才会这样相互依存</p>\n<p>或许这就是自然吧：</p>\n<p>它的魅力让我抓心挠肝，</p>\n<p>它的美丽让我惊心动魄，</p>\n<p>它的威严让我顶礼膜拜，</p>\n<p>它的慈祥让我泪水常噙。</p>\n<p>自然不会错</p>\n","categories":["观影"],"tags":["观后感","纪录片"]},{"title":"中国智慧与当代社会","url":"/post/2454a085.html","content":"<h3 id=\"人民有信仰，国家有力量，民族有希望\"><a href=\"#人民有信仰，国家有力量，民族有希望\" class=\"headerlink\" title=\"人民有信仰，国家有力量，民族有希望\"></a>人民有信仰，国家有力量，民族有希望</h3><p>层层递进的关系</p>\n<h4 id=\"民族的信仰在哪里？\"><a href=\"#民族的信仰在哪里？\" class=\"headerlink\" title=\"民族的信仰在哪里？\"></a>民族的信仰在哪里？</h4><p>信仰：</p>\n<ol>\n<li>对生命价值的确认 </li>\n<li>对人生意义的领会</li>\n</ol>\n<p>87年的深圳标语：时间就是金钱，效率就是生命，回答的正是这个问题。不可否认的是在当时，这两句话起到了积极的作用，但不能长久支持中华民族。</p>\n<p>疫情让我们飞速发展的社会停下来，我们应该要思考改革开放几十年后所缺少的东西：</p>\n<ol>\n<li>敬重天道</li>\n<li>敬畏人性</li>\n</ol>\n<p>中华民族有文化生命，诗经言：周虽旧邦，其命维新</p>\n<p>科学给我们知识，但不等于智慧。在科学中不意味着在思想中。</p>\n<p><strong>应无所住，而生其心。</strong></p>\n<p>住：住相。相：世界上所有的事物与人都区分出高低贵贱。Eg.钻石与普通石头</p>\n<p>高低贵贱并不是自然物本身的属性，人为区分。</p>\n<p>相是客观的，有人类社会就有相。</p>\n<p>不执著于相，显现本心。</p>\n<p>教科书中是知识与对知识的论证。</p>\n<p>​        当代人无法生出智慧，因为我们所生存的当代文明，已经高度复杂化，充满了知识与机巧，这种人离开智慧最为遥远。在朴素文明中生活的人，才有可能俯仰天地，领会天人之际。我们的智慧只能是对古代智慧的解读。</p>\n<p>​        西汉初年为道家思想，无为而治。但无法长久，因为道家的学说无法为任何一个民族，为他的社会秩序，奠定一个精神基础。才有的罢黜百家，独尊儒术。中国的道统是儒家。</p>\n<p>今天的中国人，从根本上来看，其对生命价值的确认，还是源于儒家。</p>\n<p>儒家让我们站在大地上，这个大地就是<strong>亲情和亲情传递给我们的牵挂和责任</strong>。</p>\n<p>无论如何学西方，根本上还是儒家。</p>\n<p><strong>儒道互补</strong>：儒家讲原则、理想、社会的伦理精神</p>\n<p>道家讲<strong>权变</strong></p>\n<p>原则性与灵活性的高度统一</p>\n<p>灵活性过头，导致以权变经，便会产生奸猾的人生态度。</p>\n<p>菠萝，三昧均是音译，中国文化中没有对应的思想，也就没有对应的汉字。</p>\n<p>唐朝佛学中国化，才有了众多的词语。</p>\n<p>儒家讲性理（人性），道家讲玄理，佛家讲空里。</p>\n<p>玄理：房间的四周墙壁的有，都是为了中间的无。有和无之间的关系。</p>\n<p>玄之又玄，众妙之门。</p>\n<p>​        人的生命对自身就是问题。人心的安顿，（对无限的一面，需要安顿）有限的一面是对周遭事物的经验与知识，因为其对象便是有限的。</p>\n<p>筹划未来落空了，也就是有了烦恼。</p>\n<p>​        大多数人在绝大多数时间同时具备着温饱，安全与健康，但我们仍然是烦恼不断。此之为<strong>无限心</strong>。</p>\n<p>不仁者，不可以久处约，不可以长处乐。</p>\n<p>（约：节约，贫贱的生活处境，不仁者：心没安顿好）</p>\n<p>不仁者，贫贱难耐凄凉，富贵不能乐业。</p>\n<p>无论你买的多豪华的东西，都是暂时的为你使用。<strong>无限的心又如何安顿在有限的事物中</strong></p>\n<p>安顿心，只能两种方法：<strong>宗教与哲学</strong></p>\n<p><strong>儒：无所为而为</strong>。做事并不是为了达成某个目标的途径与手段，事情自己就是自己的价值与意义，而不是其他任何事情。因此没有失败的人生——任何事情都不是为了其他事情的手段与途径。</p>\n<p><strong>道：无为而无不为</strong>。人+为&#x3D;伪(造作) 减少做事时人为的因素。</p>\n<p>生非贵之所能存，身非爱之所能厚；</p>\n<p>生亦非贱之所能夭，身亦非轻之所能薄。</p>\n<p>饮食：已饥方食，未饱先止。</p>\n<p>伟大的哲学典籍，只需要懂几句话便可以终身受用（上善若水）</p>\n<p><strong>佛：无心而为</strong>。做事是为了消业，希望没有结果才好。</p>\n","categories":["IDEA"],"tags":["哲学","人文情怀"]},{"title":"资本论系列视频笔记","url":"/post/84e29d5d.html","content":"<p>资本论不是经济学，其副标题是政治经济学批判</p>\n<p><strong>物理事实 + 范畴 &#x3D; 社会事实</strong></p>\n<p>社会事实不是直接给予我们的，事实是被范畴所建构的，只能看到物理世界物理事件</p>\n<p>比如警匪事件就是政治概念，二者都属于暴力事件，但是匪是私人非法暴力，警是公共合法暴力。</p>\n<h2 id=\"资本雇佣劳动\"><a href=\"#资本雇佣劳动\" class=\"headerlink\" title=\"资本雇佣劳动\"></a>资本雇佣劳动</h2><p>经济事实：<strong>资本雇佣劳动</strong></p>\n<p>其中隐藏的三个经济范畴：资本——工资——商品</p>\n<p>劳动是作为商品——因为被购买，购买也就是雇佣的意思</p>\n<p>前资本主义的师徒关系只是半人身依附关系，没有市场行为，也就没有工资的范畴。</p>\n<p>这句话意思：资本的范畴拿出一部分（称为工资），工资用来雇佣（工资里隐藏着雇佣的范畴）作为商品范畴的劳动</p>\n<p>在其中发生了等价交换，隐含价值这个范畴</p>\n<p>资本主义生产关系被认为是人类迄今为止找到的最合理的生产关系，他没有政治强制，等级压迫。而是独立的个人在市场上实现等价交换</p>\n<p>如果把资本雇佣劳动中的三个范畴都去掉，即去掉资本，去掉工资，去掉商品这三个范畴，经济事实是没了，但是事情还在发生。因为如果没有资本，也就是没有过去积累起来的劳动。</p>\n<p>若我没钱，只有活劳动这种能力，为了保证自己的物质需求，那我必须去找那些拥有过去积累起来的劳动的人。（包括生产资料土地设施机器）</p>\n<p>人类积累起来的劳动有两种，一种是直接消费品，一种是生产消费品，后者可以用来生产新的消费品，也就是创造新的价值。</p>\n<p>当今人类生产的目的是价值的增殖。谁有生产资料，谁就可以拥有一种力量，使得没有生产资料的人的生命一部分时间由这些人所支配。</p>\n<p>把范畴去掉后，该经济事实变为事情本身，即<strong>生产资料行使对活劳动的支配权。</strong></p>\n<p>马克思的哲学革命就是在去除原本事实中的那些范畴，即现象学还原。</p>\n<p>范畴之间有逻辑关系，因此是理性的。理性的基础是价值，等价交换。以统一的尺度交换，这个尺度是货币。</p>\n<p><strong>价值增殖的竞争是积累起了的劳动对活劳动的支配权的竞争。</strong></p>\n<h2 id=\"社会权力\"><a href=\"#社会权力\" class=\"headerlink\" title=\"社会权力\"></a>社会权力</h2><p>社会权力：<strong>social power</strong>。</p>\n<p>对资本作理性的研究叫做经济学，但是如果发现资本实际上是一种权力，是支配别人的力量，就发现资本是当代社会权力。</p>\n<p>赚钱的目标：脱贫、安全、权力（代表支配别人和被别人支配），即使财务自由了，但离着权力还远，就会还以为自己很穷。</p>\n<p>还原后，一个合乎理性的事实变成了非理性的人与人的关系，power</p>\n<p>今天的国家机器如此强大是为了什么？20世纪基本完成国家独立，民族解放，为什么还要拥有如此多威力空前的杀人武器？按照国际理性法则做生意、外交，一切都已经正常了，为什么还要建立？</p>\n<p>根源不是我们比以往更饥饿了，根源在于社会权力。经济学家把资本的竞争描述为一个理性的活动。马克思告诉我们这是斗争，是非理性的，是一部分人统治另一部分人的活动。</p>\n<p>王国维：世界上的学问只有两种，一种可爱而不可信，一种可信而不可爱。经济学理论是可爱的，马克思学说是可信而不可爱。</p>\n<p>我们不喜欢斗争，我们要人道主义精神。</p>\n<p>比尔盖茨说：<strong>人类在科学技术方面所取得的所有成就都不足以让人们 自豪，人类在经济建设方面所取得的所有成就都不足以让人们自豪，人们只有在减轻或者消除人类不平等境遇方面所取得的所有成就才足以让人们自豪。</strong> 但今天我们一直在倒退，今天的市场经济是穷人为富人打工的经济，你口袋里的钱越多，整个市场为你服务的动力就越大，你口袋的钱越少，市场为你服务的动力就越小直至降低为零。当我们在歌颂当今市场经济的繁荣的时候，我们不要忘记地球上有十亿人口其每天的消费水平不足一美元。（当然现在中国人民已经不在其中了，因为我们实现全面小康了）</p>\n<p>比尔盖茨没说社会权力，而是说的不平等，这不是政治的不平等，我们都有投票权，你也可以主动离开老板。</p>\n<p>比尔盖茨想让市场为穷人服务，将企业的资本分为有形的与无形的。无形的就是社会声誉，他举例联合国向全球医疗企业招标，能不能以成本价向非洲投放疫苗，奖励是给予新药市场份额。这里说明他不懂马克思。</p>\n<p><strong>资本增殖的本身必然创造了一部分的相对贫困，造成社会分裂，之后再去消弭贫困，否则剩余价值无从谈起。</strong> 如果比尔盖茨一开始就是慈善家，他不可能成为世界首富。比尔盖茨觉得他没有创造相对贫困，他不应该为此负责，资本的本性如此。</p>\n<p>现代贫困不是等级压迫的结果，<strong>价值范畴的等价交换掩盖了贫困的不断被制造</strong>。</p>\n<p>法国的黄马甲运动，表面是燃油，但其实是通货膨胀导致相对贫困。</p>\n<p>英国脱欧是民众投票的，英国是靠的金融，那么为什么脱欧呢？最终脱欧说明在加入欧盟以及全球化过程中，获利的全都是英国的大资产阶级获利。一个金融，一个贸易。</p>\n<p>由此根据马克思的学说，逆全球化才是主导趋势。</p>\n<p>资本竞争，上升Social power上升到国际层面，国与国之间会穷兵黩武，国内则是社会分裂，或政党之间的斗争</p>\n<p>马克思说资本主义的每一次成功发展，必然伴随着社会权力的扩大，权力就是冲突、对抗，是非理性的。</p>\n<p>资本capital分为财富wealth和权力power，财富不以土地和牲畜的多少计算，这是使用价值多，资本增殖了才叫财富。研究资本的运动，也就是研究社会权力的变动。财富增加，权力必然同步扩大，导致社会矛盾。</p>\n<p>政治权力是国家机器，军队警察监狱，这是用于维护社会权力的。</p>\n<p>一个弱小的人如果有很多钱，首先他不会担心别人抢，因为有政治权力即国家机器保护社会权力；其次一大堆人会不断游说他让他投资，即求着他雇佣，求着他支配自己的一部分生命时间。这个过程，钱没说话，所以社会权力不是观念，不是idea，但我们说的话一直在承认它的力量。</p>\n<p>但是观念必然会来，观念把这个真实的感性的力量表达为right权利，法的范畴就上去了</p>\n<p>power——权力</p>\n<p>right——权利</p>\n<p>非理性的权力变成了理性的权利</p>\n<p>无论政策如果变，我手里有social power，最后谁听谁的？</p>\n<p>社会权力不能直接等同于政治权力。</p>\n<p>所以改革是不可避免的，国营企业拥有资本同时是政治权力，需要把政治拿掉，还原为社会权力才行。当时有投资饥饿症，也就是投资后利润达不到，但是不能倒闭，所以继续投资。</p>\n<p>所以我们改革，承认社会权力，承认体制外的经济活动，不承认的时候叫投机倒把，现在变成了搞活经济。这是意识形态的改变，观念的改变。</p>\n<p><strong>Power + ideology(意识形态) ——&gt; Right</strong></p>\n<p>政治权力承认了社会权力，将其表达为私有财产的权利，上升到了法的概念（2006年物权法）。</p>\n<p><strong>扩大开放：承认国外的social power</strong></p>\n<p><strong>深化改革：清洗掉国内在social power上的政治维度</strong></p>\n<p>不是Right让你拥有了支配别人的力量，而是social power</p>\n<p>所以改革开放并不是观念的改变，不是思想解放的结果，这是历史唯心主义。而是在计划经济晚期，产生了异质的要素，这是不能容纳在计划经济内的。产生的原因则是因为有货币。只要有货币，有商品交换，价值规律就一直在起作用。因此社会主义计划经济体制本身包含着与自身相异的要素。</p>\n<p>以苏联为首的社会主义国家的行为难道叫做社会主义吗？不是，价值规律一直在起作用。</p>\n<p>当时实际上是没有资本家的资本社会</p>\n<p>这种异质的东西一定会突破计划经济，这是不可避免的。所以新的社会权利一定会在原本的计划经济中成熟起来，然后意识形态要表达它，上层建筑（法的体系和国家制度）都要表达它。power决定了right，就是经济基础决定上层建筑（思想上的意识形态与政治上的国家制度和权力机器）</p>\n<h2 id=\"劳动抽象化\"><a href=\"#劳动抽象化\" class=\"headerlink\" title=\"劳动抽象化\"></a>劳动抽象化</h2><p>范畴本身，是怎么来的比如价值这个经济范畴怎么来的？</p>\n<p>价值这个范畴我们觉得很容易理解，只要商品交换存在那么人类的产品呢它就有两个维度：一个叫使用价值，比如说这块手表使用价值用来看时间，这块手表价值200块，是他的价值。劳动产品成为商品，那么就意味着有一个价值范畴</p>\n<p>200块的手表和值200块的皮鞋可以等价交换，本来生产手表的劳动跟生产皮鞋的劳动是完全不同的劳动，是完全不同的使用价值。他们之前是无法通约的。作为商品交换，必须通约，满足等价交换的原则。</p>\n<p>这时需要把劳动抽象化，即一定时间内人类时间与体力的支出。<strong>劳动也有二重性，使用价值是具体劳动创造的，价值是抽象劳动创造的，虽然在现实中这是一种劳动。</strong></p>\n<h2 id=\"生产目的改变\"><a href=\"#生产目的改变\" class=\"headerlink\" title=\"生产目的改变\"></a>生产目的改变</h2><p>商品交换在资本主义之前就有了，</p>\n<p><strong>W - G - W</strong>，这时货币只有媒介的作用，只是流通手段。但对于投资来说，则是<strong>G - W - G’<strong>。前者生产目的是获得我不能生产的产品，后者的生产目的是货币增殖，</strong>G’ &gt; G</strong>，差值就是剩余价值。这意味着原来仅仅是流通手段的<strong>货币，变成了财富的主体</strong>。</p>\n<p>中国古代也有商品流通，但商人积攒货币后，是置办田产，有了田地才是真正有了财富，这是中国古代。但是欧洲不一样，因为<strong>欧洲贵族对土地的占有制是世袭的</strong>。所谓封建，就是封土建国，所以欧洲和中国古代封建不一样。中国阶层是可以流动的，一个是科举，一个是财富。所以中国古代内部不能发展出资本主义，中国古代的人们不可能把生产的目的变为剩余价值，我们追求的是使用价值。</p>\n<p>欧洲商人的货币无法转换为土地，资产阶级的法语意为城关市民。商人就是在领地之中从事贸易，如果受到贵族武装侵袭，就需要武装保护。</p>\n<p>欧洲资产阶级成长的三个阶段，第一个是将自己武装起来与贵族武装进行战斗，但是经常失败；到了第二阶段：建立资本所需要的政治制度，即各种革命；第三阶段是与无产阶级斗争</p>\n<p>商人的目的是<strong>赢得动产的自由，即动产能够战胜不动产的历史权威，让货币战胜土地。</strong> 前提是贵族要垮台，而当时欧洲贵族喜好东方瓷器绸缎，于是商人扩大海外贸易，让贵族的钱到商人中。没钱了，也就没钱支付仆人、土地上的半农奴。这批人奔向城市，但行会手工业完全是闭源的，这批人<strong>自由了，但自由的一无所有</strong>。而此时，商人等着他们呢——工厂手工业。商人一开始不在生产领域，而是在流通领域，但时间长了，商人肯定更了解市场的需要，商人想要手工业服从于市场，但是行会手工业不服从市场，而是一定区域的老主顾，这种手工业没有扩大生产的需要。</p>\n<p>等到大量劳动力进入到城市中，商人又在等着他们，一种新的商品出现了——劳动力。商人投入资金，雇佣劳动力，生产商品，进入市场，获得资金，继续雇佣劳动力扩大生产。<strong>生产目的改变了——追求剩余价值。</strong></p>\n<p>但是资本的生命本性就是增殖，按其本性，要求他一定要突破欧洲有限市场，走向世界的市场。商人与劳动力结合，与贵族对抗，贵族要么卖爵位，要么卖地，要么转变为资本家（新贵族）</p>\n<p>由此土地世袭占有权改变。土地被纳入到资本中，产生了圈地运动，羊吃人。</p>\n<p>要现代化必须先工业化，工业化的前提是什么？剥夺农民的土地所有权。工人生产不能吃不能穿的东西，但是工人自己要吃要穿，谁来提供？农民。如何理解计划经济，<strong>一个后发的现代化国家，如何快速工业化，实质是剥夺农民的土地所有权，通过差价交换农业与工业产品。</strong> 比欧洲温和，但是就是穷。不剥削农民，不可能短时间实现工业化。</p>\n<p>资本开创了世界史。</p>\n<p>欧洲的王室是支持商人的，因为王室最大的敌人是贵族。</p>\n<p>东印度公司是英国最著名的</p>\n<p>国富论的原则：让政治从市场中退出</p>\n<p>政治经济学经历的阶段：重商主义到重农主义，再到一门科学，标志就是劳动价值理论，这让经济学称为一门科学，获得了研究对象。</p>\n<h2 id=\"劳动价值论\"><a href=\"#劳动价值论\" class=\"headerlink\" title=\"劳动价值论\"></a><strong>劳动价值论</strong></h2><p>劳动：一般劳动：凡是能使货币增殖的活动都是劳动，所以理发师的劳动也是劳动，创造的是商品价值。</p>\n<p>价值：商品的交换价值（不是使用价值）</p>\n<p>这样完成了一件事：把具体劳动的感性特征抽象掉，只说社会必要劳动时间的量，这个量的体现就是货币。货币因此也成为财富主体，而不是一般等价物。</p>\n<p>不同的劳动能够被等量齐观</p>\n<p>货币增殖：劳动的量增加，这个劳动量增加是在生产领域增加，不可能在流通领域。</p>\n<p>具体劳动受抽象劳动支配，如果具体劳动不能给资本带来增殖，那他就不算劳动。所以研究哲学不算是劳动。</p>\n<p>经济学取代了记账学，一个家庭内一定要计算一月内的收入与支出情况，即直接计算使用价值，并设法保住这个使用价值。</p>\n<p>但今天不能丢掉记账，经济学，是通过市场，让通过劳动创造的剩余劳动卖成剩余价值，货币增殖，获得在市场上的购买力。万一市场断了呢？</p>\n<p>发达资本主义国家也要考虑这些使用价值。一旦危机要保持必要的粮食储备。</p>\n<p>如果整个社会的电网都崩溃了，蜡烛就重要了。人还是要站在大地上的。年轻的钱不能花完，必须储蓄。假如货币没有脱离金本位，钱始终是那些钱，购买力始终是可靠的。</p>\n<p>资本主义发展到现在完全脱离大地，稍微有点钱的老人是最惨的，整天担惊受怕自己的财富缩水。</p>\n<p><strong>资本的本质：抽象劳动统治具体劳动，交换价值的增殖支配使用价值的生产。</strong></p>\n<p>这是近代以来的唯心主义</p>\n<p>但财富作为使用价值的数量来计算这件事是不能被遗忘的</p>\n<p>金融危机会在几个月内将十年经济发展毁于一旦，90年代金融危机，韩国老百姓将黄金上交国家，短时间内恢复韩币的金本位制，稳住韩币</p>\n<p>因此<strong>金银不是天然的货币，但货币天然是金银</strong>。</p>\n<p>金银只是矿产，<strong>货币是一般等价物，是流通的，但如果要把财富用货币来表示，应该在自然界寻找一种储备有限，质地均匀，便于分割携带的东西。——只能是金银</strong></p>\n<p>G - W - G’</p>\n<h2 id=\"资本与技术是孪生兄弟\"><a href=\"#资本与技术是孪生兄弟\" class=\"headerlink\" title=\"资本与技术是孪生兄弟\"></a>资本与技术是孪生兄弟</h2><p>G是生产资料的价值和劳动力（工资），开始劳动过程，即劳动时间，产生新产品，如果原材料的价值完全转移到了新产品上，产生的多出来的价值完全等于工资，那么资本家变成了义务劳动。</p>\n<p>马克思用<strong>剥削这个词没有任何道德贬义</strong>。以往的农奴劳动是等级强制，现在的剥削是正义的。</p>\n<p><strong>资本家是资本的人格化，经营企业的行为是服从资本的逻辑的，与其道德品质无关。</strong></p>\n<p>资本家没有奴役任何人，只是<strong>按照资本的法则，必须要将劳动分为必要劳动和剩余劳动。</strong></p>\n<p>市场是一个竞争的舞台，产品要么便宜，要么质量好。这迫使资本家降低成本，第一种方法是延长工时，但无法无限延长，因为要吃饭睡觉，12小时最多了，第二种是减少必要劳动的时间，即提高生产效率，第一种是劳动者更熟练，第二种是新技术。</p>\n<p>围绕相对剩余价值，展开了技术比拼。</p>\n<p>中国是第一制造业大国，因为量大，不是质量。这是中低端制造业，高端是技术。<strong>高端能够获得品牌的地位，有品牌就有市场。</strong></p>\n<p>相对剩余价值的开发，只能依赖新技术的研发，这能够带来两个好处，第一个是提高产品质量与效率，第二个是创造新的使用价值（iPad这种新产品就是新的使用价值）</p>\n<p>美国特别强调产权，是因为其实体制造业很少了，但三亿人口的老百姓并不都在硅谷，实体制造业衰落造成大量的失业人员。所以特朗普号召制造业回归本土。</p>\n<p><strong>资本主义的生产一定带来技术的进步</strong>，在此之前人们没有技术，只有技艺。<strong>技术将自然抽象化看作资料material的世界，技艺则是追求天人合一</strong>。把劳动抽象化必然也会把自然界抽象化。资本与技术是孪生兄弟，中国的土壤既无法产生资本主义，也无法产生对自然界的技术的态度。</p>\n<p>马克思的<strong>生产力决定生产关系</strong>：不是说生产工具的进步带来新的生产关系。从行会手工业到工厂手工业，生产工具没变，生产关系变了，行会中是师徒，工厂中是资本主义生产关系，要求相对剩余价值。这种资本主义生产关系产生后，机器在逻辑上被发明了，经验上还没诞生。</p>\n<p>如果没有资本主义的生产关系，瓦特发明的蒸汽机只是一个宫廷里的玩具</p>\n<p>所以鲁迅说，中国的四大发明不是生产力</p>\n<p>所以资本与技术是孪生兄弟</p>\n<p><strong>没有技术，资本无法竞争，没有资本，技术无法被要求</strong></p>\n<p>资本在根本上改变了人们的生活方式，这个改变的指向就是效率——时间就是金钱，效率就是生命</p>\n<p>技术运用到农业生产，改变靠天吃饭；运用到医疗，延长生命；运用到电声转换，将古典音乐收入到口袋中。这是积极的方面，不能被否认也无法被忽视。</p>\n<p>核能是不能运用的，因为人是会犯错误的动物。<strong>新能源的运用是要靠旧能源</strong>，资本主义不断要求效率，效率就不断要求高效的能源</p>\n<h2 id=\"资本主义内在界限：\"><a href=\"#资本主义内在界限：\" class=\"headerlink\" title=\"资本主义内在界限：\"></a><strong>资本主义内在界限</strong>：</h2><p>资本主义生产方式没有外在界限，它要求突破一切民族、疆域、文化</p>\n<p>但它有内在界限，即<strong>资本主义的每一次发展，都会同时产生限制自己的力量</strong></p>\n<ol>\n<li><p><strong>必要劳动是活劳动的交换价值的界限</strong>（必要劳动是等于工资的那部分劳动，所以剩余劳动是必须的。劳动力是商品，也就有交换价值）：技术运用后，必要劳动比例减少，但劳动者的工资不会变多。如果必要劳动的比例进一步减少，就会发生裁员。产品需要卖给大比例的人口即劳动者，但劳动者购买力没有提高。资本家的矛盾心理：员工在企业内部工资一直不变，但当员工一出企业，又希望他们有旺盛的购买力。这是资本主义无法克服的悖论西方国家通过二次分配——社会福利解决，这与资本主义无关，让劳动者敢于花钱，能保证最基本的保障。</p>\n</li>\n<li><p><strong>剩余价值是剩余劳动和生产力发展的界限</strong>：剩余劳动是一直都有的，它是过去积累起来的劳动物化为使用价值。到了资本主义时，剩余劳动不能停留在实物形态，它必须要在市场中转换为剩余价值，实现货币的增殖。否则就破产。所以出现倒牛奶。因此<strong>过剩的绝不是剩余劳动</strong>，<strong>过剩的是这部分剩余劳动无法在市场竞争中实现剩余价值。</strong> 唯一的做法就是毁掉，重启市场需求。要么自然灾害，要么发动战争。资本主义一方面极大促进了生产，积累剩余劳动，但又在随时准备破坏这些积累起来的劳动。 相对过剩发生，产业链资金链都受影响，容易连锁反应发生经济危机。日本侵略也是在这个背景下，发展新市场，瓜分殖民地。而美国当时则是选择另一种方法，突破资本主义的第三个界限（见下）</p>\n</li>\n<li><p><strong>货币是生产的界限</strong>： 生产目标是货币增殖，资本主义投入开始就是货币，整个过程都以货币作为媒介。产业链从上游一直到下游末端直接面对消费者，如果钱回不去，资金链就断了，只能印钞票。这样货币天然是金银的原则就被破坏了，因为你没法印金子。美国罗斯福国家干预经济，超发货币，低息贷款，启动资本主义生产第一个阶段。让货币与黄金脱钩。救济企业，应对就业危机，工人就业有了钱，又回去消费，将剩余劳动转化为剩余价值，解决过剩危机。内部危机只有两个手段：超发货币与国家投资。最终走入资本主义最终形态，金融资本主义。金融4个方面，银行，证券，保险，基金。</p>\n<p>马克思谈金融：生息资本：金融是资本市场，资本市场是资本成为商品进行买卖。资本作为商品，即资本产生利润的能力被买卖了，产生的利润是资本作为商品的使用价值，产生利润的能力是资本作为商品的价值。这个产生利润能力的价值如何确认？资本之所以表现为商品，是因为利润被分割为利息和本来意义上的利润，是由供求，从而由竞争来调节的。供求平衡，价格与价值相等，工资就是一种价格，因为工资是波动的。资本作为商品被买卖时，便有价格，价格就是利息；而使用价值就是生产利润的能力，那这个能力有没有价值中心线，也就是说有没有价值？资本生利能力的价值是多少？这里的竞争不是对价值规律的偏离，而是除了由竞争强加的分割规律之外，不存在别的分割规律，并不存在自然利息率，利率没有自然界限。所以这个商品，只有价格，没有价值。金融危机的可怕之处也在于此，它没有价值中心线。所以资本只是表现为商品而不是商品。为什么不具有自然属性，一是使用价值无法确定，只能用最近的过去作为不远的将来的近似，二是供求关系也就是货币供应量不确定。</p>\n</li>\n</ol>\n<p>生产是以货币作为价值和财富，货币贬值后经济就垮了。但中国人厉害的一点在于，如果生产和消费的一系列过程垮掉，那么可以直接让生产和消费在地摊上见面。资本不行了，就走合作化的道路。</p>\n<ol start=\"4\">\n<li><strong>使用价值的生产受交换价值的限制</strong>。如果某种生产价值带不来剩余价值，那么这种使用价值将不被生产。但他可以改头换面，带来新的剩余价值。</li>\n</ol>\n<p>这是资本主义自己发展的同时，也在积累否定自己的力量。</p>\n<p>其带来的文明的果实不会消失，但不能用产生的方式来保存这种果实。</p>\n<p>马上得天下，但是治天下要下马</p>\n<p><strong>资本主义的消亡不是从外部被否定的，而是从内部。</strong></p>\n<p>中国以自己特色的方式取得了巨大的经济成就，但过去几十年获得的方式不是保存的方式。三十年为一世，而道更。1919的反帝反封建，到49年新中国成立，再到79年的改革开放，如今赢得总量第二，一个靠资本，一个靠技术，缺的是这两个，多的是廉价劳动力与自然资源。</p>\n<p>资本主义还有一段路要走，我们要用自己的路走。</p>\n","categories":["IDEA"],"tags":["人文情怀","资本论","王德峰"]},{"title":"一些对于博客的归纳","url":"/post/1a07e293.html","content":"<p>本人很喜欢写东西，无论是道听途说，还是捕风捉影，抑或是经典小作文，我都想要用文字记录下来，上大学以来在OneNote上记录的也不少了。</p>\n<span id=\"more\"></span>\n\n<p>一个博客，应该是能够体现我这些想法的，而不仅仅只用来存放技术类的知识（个人想法）。</p>\n<p>然而博客维护起来相对还是比较麻烦的，一是要面对其他人而不是自己，遣词造句上需要再三斟酌；二来毕竟要放在一个公开的互联网上，需要充分尊重不同人群的差异并给予平等的对待。</p>\n<p>身为技术人员，所希望的，自然是</p>\n<p><strong>互联网连接五大洲，二进制写尽天下事</strong></p>\n","categories":["IDEA"],"tags":["博客","总结"]}]