[{"title":"Navicat无法连接MySQL","url":"/post/32e06ea.html","content":"<h1 id=\"Navicat无法连接到MySQL数据库\"><a href=\"#Navicat无法连接到MySQL数据库\" class=\"headerlink\" title=\"Navicat无法连接到MySQL数据库\"></a>Navicat无法连接到MySQL数据库</h1><p>解决问题只需要一分钟，而发现问题则需要三小时。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"省流版：\"><a href=\"#省流版：\" class=\"headerlink\" title=\"省流版：\"></a>省流版：</h2><p>服务器没有开MySQL的端口。</p>\n<p>之所以还要写一篇文章，是因为开端口只需要一分钟，而根据各种现象与线索推断出没有开端口则需要三个小时。</p>\n<h2 id=\"问题背景\"><a href=\"#问题背景\" class=\"headerlink\" title=\"问题背景\"></a>问题背景</h2><p>在服务器上安装了Linux虚拟机，然后在虚拟机上安装MySQL。</p>\n<p>之前一直都是用xshell操纵MySQL，今天想使用Navicat连接。</p>\n<h2 id=\"my数据库\"><a href=\"#my数据库\" class=\"headerlink\" title=\"my数据库\"></a>my数据库</h2><p>MySQL的数据库如下：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc5659dfe-f48f-4459-b7be-2d779ed5c70c%2FUntitled.png?table=block&id=a9a7fa21-6960-4bed-b8cd-2a85a11fe85e&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>共两个数据库，一个myDB1，一个university数据库（其余为MySQL自带的数据库）</p>\n<p>此时我MySQL里面的用户如图：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5b287113-20e3-499e-81d5-59722b6b7c20%2FUntitled.png?table=block&id=ff3d3505-8259-45e3-b47e-1e294c563cfb&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>可以看到里面有三个用户，root，peng和user_for_db1。其中user_for_db1是之前建立的，根据名字可知，为user_for_db1赋予了myDB1数据库的所有权限，同时为peng用户赋予所有数据库的所有访问权限。</p>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>在Navicat中，建立了两个连接，如图：</p>\n<p>连接1：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7a37ed44-bebf-4d38-b693-46977d58f8c4%2FUntitled.png?table=block&id=8a6b4130-bd23-4c55-ba1b-ed989a18c8d6&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F15714710-cf21-4afb-bb78-627d7e56b638%2FUntitled.png?table=block&id=4dc00da1-10bb-4d7e-a015-4f0da4a7fa68&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>可以看到连接成功，并且由于设置了访问权限，所以只有myDB1一个数据库。这个连接是很久之前建立的，当时忘记怎么连接的了（果然还是要养成记录的好习惯）。</p>\n<p>但是当用另一个用户连接的时候，却提醒<strong>连接出错</strong>，如图：</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb09dfa26-c0a4-46d9-b9bc-5d72d067e117%2FUntitled.png?table=block&id=90a62de4-8525-4412-b366-45cf76e70770&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F433afe7e-5c47-4f58-8631-7a0c3af38bee%2FUntitled.png?table=block&id=453d6e96-5568-4986-8a68-3523f2b26b7d&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=2000\"></p>\n<p>另外也不是SSH连接的错误，因为都不行，这里只是没放截图。</p>\n<h2 id=\"请教大佬\"><a href=\"#请教大佬\" class=\"headerlink\" title=\"请教大佬\"></a>请教大佬</h2><p>在向大佬请教过程中，并没有直接问为什么连不上，因为很多背景会导致共同的问题，上来直接问往往讲不清背景。我先是注意到在XShell中，连接的端口是22，协议是SSH，而Navicat中的端口是3306，因此就先问了一下这两个端口的不同。</p>\n<p>大佬回答如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">22这个端口，是用SSH连接服务器的默认端口；</span><br><span class=\"line\">3306这个端口，是MySQL的默认端口。</span><br></pre></td></tr></table></figure>\n\n<p>当时还并没有十分清楚，大佬又来了一句：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">3306可以改的</span><br><span class=\"line\">开启MySQL时候换个端口就行</span><br></pre></td></tr></table></figure>\n\n<p>听了这句话之后，我也排除了端口冲突的问题，因为这两个连接并没有同时打开。</p>\n<p>之后向大佬讲了一下背景，也就是上文的内容，大佬听完后，也是不太清楚。。。。</p>\n<h2 id=\"峰回路转\"><a href=\"#峰回路转\" class=\"headerlink\" title=\"峰回路转\"></a>峰回路转</h2><p>其实一开始就感觉这个问题有点奇怪，所以并没有很失望，不过看着大佬跟我说的那句：3306可以改的，我陷入了沉思。</p>\n<p>MySQL怎么知道你把端口改了呢？</p>\n<p>突然又想到最初设置服务器的时候，在安全组里面设置过一些端口</p>\n<p>于是问了一下大佬要不要在服务器上添加允许这个新端口</p>\n<p>果不其然，需要在服务器上设置。</p>\n<p>然后，就想着在服务器上添加一个新端口，尝试用新端口连接。</p>\n<p>然后震惊地发现，我没有给MySQL开端口！！</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcadc8899-4cd3-4076-80c4-e3e7f16f14e0%2FUntitled.png?table=block&id=190f073f-a445-4388-9894-a0bd82f16227&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>发现这点后，我并没有立刻开放端口，而是开始思索，我之前怎么登录的呢？</p>\n<p>看着被允许的几个端口，尤其是<strong>22</strong>那个端口，事情逐渐明朗了起来</p>\n<p>我开了22的端口，而xshell也是用22连接的，也就是说，我用xshell连接，相当于是<strong>远程桌面</strong>。</p>\n<p>我是先通过22端口，连接到远程桌面，也就相当于登录到服务器这个计算机，然后在进入到mysql，这时的MySQL就相当于是远程计算机的本地应用了，所以不需要3306这个端口。</p>\n<p>但是我一开始怎么连接成功的呢？</p>\n<p>就是这个</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7a37ed44-bebf-4d38-b693-46977d58f8c4%2FUntitled.png?table=block&id=8a6b4130-bd23-4c55-ba1b-ed989a18c8d6&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<p>说实话想了好久也没想清楚，目前的推断是，在上图的安全组中（图7），有三个内网IP，有可能服务器认为我这个连接属于内网连接，所以可以通过（只是推测）。</p>\n<h2 id=\"收尾\"><a href=\"#收尾\" class=\"headerlink\" title=\"收尾\"></a>收尾</h2><p>开放端口后，确实连接成功了，但是发现没有任何数据库信息，于是通过网上查阅资料，知道是需要如下操作，简单记录一下：</p>\n<p>右键——编辑连接——数据库——选择对应的数据库（可能需要勾选使用自定义数据库列表）</p>\n<p><img src=\"https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F76c93ef3-c8f6-4b72-aec7-e0b7c1f56533%2FUntitled.png?table=block&id=52f49902-8e18-4ce1-95d2-f79755247bcc&spaceId=cd37e22d-bc20-4364-9838-fb09d9455024&width=1230\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>通过这次的问题，我明白了端口的重要性，端口和IP地址一样都是用来标识计算机的，通过这些标识赋予不同计算机的访问权限。</li>\n<li>熟悉了一些关于用户与数据库授权的知识，只有授权后才能在Navicat中显示。</li>\n<li>进一步感受到了如何正确的问问题：<ul>\n<li>自己必须先尝试一些方案，不要遇到问题就直接问，先自己尝试解决。</li>\n<li>同时要将对方代入到你的场景中，描述清楚背景是成功的一半。</li>\n<li>在问的过程中，也要不断给出自己的思路，自己多加思考，因为没人有义务无偿且天然地向你解答。</li>\n<li>即使到最后，这个解决方案，包括添加新端口与两个端口的差别，都是我自己引导着大佬去解答的。大佬并没有直接给出方案（可能还是由于描述不清，到最后他才知道我之前是用xShell登录的），自己才是最清楚历史原因的人，一定要多思考。</li>\n</ul>\n</li>\n<li>添加一个端口只需要一分钟，但知道为什么添加，却需要三个小时。</li>\n</ul>\n","categories":["Geek"],"tags":["mysql","数据库","navicat","Developer","技术"]},{"title":"reference in c++ and c#","url":"/post/8a2f0ada.html","content":"<p>浅谈一下C#与C++中引用的区别</p>\n<span id=\"more\"></span>\n\n<p>C# 中有两种类型：引用类型和值类型。  引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。 对于值类型，每个变量都具有其自己的数据副本，对一个变量执行的操作不会影响另一个变量（in、ref 和 out 参数变量除外——</p>\n<p><code>in</code> 关键字会导致按引用传递参数，但确保未修改参数。 它让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。 它类似于 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref\">ref</a> 或 <a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/out-parameter-modifier\">out</a> 关键字，不同之处在于 <code>in</code> 参数无法通过调用的方法进行修改。 <code>out</code> 参数必须由调用的方法进行修改，这些修改在调用上下文中是可观察的，而 <code>ref</code> 参数是可以修改的， 同时<code>ref</code> 要求在传递之前初始化变量。）</p>\n<h2 id=\"按值传递引用类型\"><a href=\"#按值传递引用类型\" class=\"headerlink\" title=\"按值传递引用类型\"></a>按值传递引用类型</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types\">引用类型</a>的变量不直接包含其数据；它包含对其数据的引用。 如果按值传递引用类型参数，则<strong>可能更改属于所引用对象的数据</strong>，例如类成员的值。 但是，<strong>不能更改引用本身的值</strong>；例如，不能使用相同引用为新对象分配内存，并将其保留在方法外部。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">PassingRefByVal</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Change</span>(<span class=\"params\"><span class=\"built_in\">int</span>[] pArray</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pArray[<span class=\"number\">0</span>] = <span class=\"number\">888</span>;  <span class=\"comment\">// This change affects the original element.</span></span><br><span class=\"line\">        pArray = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">5</span>] &#123;<span class=\"number\">-3</span>, <span class=\"number\">-1</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>, <span class=\"number\">-4</span>&#125;;   <span class=\"comment\">// This change is local.</span></span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        Change(arr);</span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr [<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">    Inside Main, before calling the method, the first element is: 1</span></span><br><span class=\"line\"><span class=\"comment\">    Inside the method, the first element is: -3</span></span><br><span class=\"line\"><span class=\"comment\">    Inside Main, after calling the method, the first element is: 888</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>在C++中，结果如下：</p>\n<p>如图：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">changeArray</span><span class=\"params\">(std::vector&lt;<span class=\"type\">int</span>&gt; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">999</span>;</span><br><span class=\"line\">    a = vector&lt;<span class=\"type\">int</span>&gt;&#123; <span class=\"number\">-1</span>,<span class=\"number\">23</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a&#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">changeArray</span>(a);</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出为</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">-1</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>可以看出C#自动传递引用类型，只不过按照值传递；而C++则是调用复制构造函数，直接产生一个新的数组，对函数外没有影响。</p>\n<h2 id=\"按引用传递引用类型\"><a href=\"#按引用传递引用类型\" class=\"headerlink\" title=\"按引用传递引用类型\"></a>按引用传递引用类型</h2><p>除了 <code>ref</code> 关键字添加到方法标头和调用，以下示例与上述示例相同。 方法中所作的任何更改都会影响调用程序中的原始变量。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">PassingRefByRef</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Change</span>(<span class=\"params\"><span class=\"keyword\">ref</span> <span class=\"built_in\">int</span>[] pArray</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Both of the following changes will affect the original variables:</span></span><br><span class=\"line\">        pArray[<span class=\"number\">0</span>] = <span class=\"number\">888</span>;</span><br><span class=\"line\">        pArray = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">5</span>] &#123;<span class=\"number\">-3</span>, <span class=\"number\">-1</span>, <span class=\"number\">-2</span>, <span class=\"number\">-3</span>, <span class=\"number\">-4</span>&#125;;</span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside the method, the first element is: &#123;0&#125;&quot;</span>, pArray[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Main</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span>[] arr = &#123;<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside Main, before calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        Change(<span class=\"keyword\">ref</span> arr);</span><br><span class=\"line\">        System.Console.WriteLine(<span class=\"string\">&quot;Inside Main, after calling the method, the first element is: &#123;0&#125;&quot;</span>, arr[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Output:</span></span><br><span class=\"line\"><span class=\"comment\">    Inside Main, before calling the method, the first element is: 1</span></span><br><span class=\"line\"><span class=\"comment\">    Inside the method, the first element is: -3</span></span><br><span class=\"line\"><span class=\"comment\">    Inside Main, after calling the method, the first element is: -3</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>C++如下：（在上面C++的代码中加了一个&amp;）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">changeArray</span><span class=\"params\">(std::vector&lt;<span class=\"type\">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; a.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cout&lt;&lt;a[i]&lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;<span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">    a[<span class=\"number\">0</span>] = <span class=\"number\">999</span>;</span><br><span class=\"line\">    a = vector&lt;<span class=\"type\">int</span>&gt;&#123; <span class=\"number\">-1</span>,<span class=\"number\">23</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; a&#123; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"built_in\">changeArray</span>(a);</span><br><span class=\"line\">    std::cout &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1 2 3</span><br><span class=\"line\">-1</span><br><span class=\"line\">-1</span><br></pre></td></tr></table></figure>\n\n\n\n<p>C++ 应该是没有值类型和引用类型的说法的（或者说不存在与 C# 的引用类型和值类型相对应的概念）。但是 C++ 类型的行为默认是 C# 中值类型的行为。</p>\n<p>比如函数传递参数时，C++ 和 C# 的值类型都会把参数完整复制一份。C++ 往往用传递 const 引用的方式来省去复制的开销。而 C# 可以用 ref 关键词来传递值类型的引用。</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>上述只是简单描述了其区别，但对原理尚未搞清楚，希望等到对引用了解深入以及进一步学习后再来看C++与C#的区别。</p>\n<h2 id=\"参考链接：\"><a href=\"#参考链接：\" class=\"headerlink\" title=\"参考链接：\"></a>参考链接：</h2><p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters\">https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/passing-reference-type-parameters</a></p>\n<p><a href=\"https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref\">https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref</a></p>\n<p><a href=\"https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/\">https://uint128.com/2021/05/08/C-%E5%92%8CC-%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</a></p>\n","categories":["Geek"],"tags":["Developer","技术","C++","C#","Programming"]},{"title":"onedrive - not just cloud drive","url":"/post/71ae5435.html","content":"<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p>很多时候，一些问题与想法，必须要有多个设备的背景。</p>\n<hr>\n<span id=\"more\"></span>\n\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>​\t\t通过两台电脑的日常使用思考，展现OneDrive这一同步利器，以及OneDrive的理念与意义。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><p>​\t\t三月份由于一些原因，入手了一个主机，原来的笔记本一下子变成了键盘托，想起之前觉得30块钱的键盘托有些贵，如今用大几千的笔记本当键盘托确实有些好笑。</p>\n<p>​\t\tAngway，同步的问题刚开始显得不是那么重要，因为使用场景固定。无非是一些大文件的拷贝，这时用一个硬盘，就能轻松解决，而且300MB的顺序读写速度也让每次借硬盘、插线显得不是那么费劲。随后便在主机上舒舒服服地用了一段时间。</p>\n<p>​\t\t后来，由于地区解封的原因，需要隔离，而隔离7天，或许就只能用我的笔记本了。</p>\n<p>​\t\t但是我几个月来的工作文件基本都在主机上，如何同步，成了一个难题。</p>\n<p>​\t\t我不想直接把文件拷到U盘然后传到笔记本上，感觉这样有些原始……</p>\n<p>​\t\t也不想传到网盘里，因为要么某些太慢，要么感觉每次打开客户端太麻烦……</p>\n<p>​\t\t我想要做的，是等我换回主机工作的时候，如何避免再重复一遍文件同步的工作，也想避免以后每次在两台设备或者更多台更换时，我都要记得这段时间内在当前电脑上的修改，然后用网盘或者U盘的方式传文件。因为使用场景比较灵活，也不可能部署一个NAS系统存文件(太贵加没有地方放)，对于一些软件来讲，没有必要把软件本体都同步，软件在电脑上变动还是相对较小的，主要是文件。</p>\n<p>​\t\t我的理想目标是，能够像Git一样，有一个版本控制的功能，让我能够在多个客户端修改，之后每次修改完，能够通过一些指令(或者完全自动)比如git push传到某个云服务器上，然后更换设备时，只需要像git pull一样再从云端拉取下来，这样两台设备就可以无缝切换。</p>\n<h4 id=\"OneDrive-来了\"><a href=\"#OneDrive-来了\" class=\"headerlink\" title=\"OneDrive 来了\"></a>OneDrive 来了</h4><p>​\t\t之前也一直有用过OneDrive，毕竟是微软自家的，用着Windows想不注意都难。之前个人有个5G的免费空间，但是用的体验不太好，要么很容易满，然后提醒你升级到365；要么是本地写点文件时候，他就一直在同步，但我又不清楚到底哪些能够同步，哪些默认同步，导致一些莫名其妙的同步，占用那本就少得可怜的空间，整的人很不好。甚至于有次我同步了桌面后，桌面上所有东西都没了，然后通过“取消链接到此电脑”以及退出OneDrive，桌面上的东西才又回来……</p>\n<p>​\t\t想到了OneDrive，是因为它确实很不像一个云盘。国内的很多网盘，需要先在桌面找到客户端，然后双击，登录，可能还要收个验证码，此时又要拿出手机收短信或者扫码，然后看着网盘里的文件，思考位置在哪里(如果比较熟练也可以跳过这个步骤)，然后下载，然后到本地去查看，有时候可能下到C盘，还要找地方移动文件……</p>\n<p>​\t\t之前有搞过阿里云盘的本地挂载，虽然最后也不了了之，但是感觉OneDrive运用了这种思路。以下我个人认为的OneDrive的一些特点：</p>\n<ol>\n<li>它不需要一个很复杂花哨的客户端，也不需要每次登录的验证，借助微软账户就能开机自动登录，也就是说只要开了机，就能登录，因为用的是一个账户。</li>\n<li>OneDrive的文件既存在云上，也有本地，但是这种本地不像百度网盘这种，需要现打开客户端下载文件，而是自动同步。这有些类似于手机的自动同步功能，包括相册同步以及iCloud的同步。但感觉还有些不同：一个是手机相册很少有修改的场景，大多数是往里加加加照片；另一个是手机同步往往要打开客户端，有后台才能同步，但是手机这种工具以及使用场景来说，往往几周才打开一些冷门软件，所以同步也不及时。</li>\n<li>OneDrive几乎没有界面UI上的学习成本，它借助于微软Windows操作系统，直接内嵌在原本的文件系统内，就像是把云端的文件目录挂载到了本地，并且能够实时更新。只要见过微软的文件系统长什么样，用OneDrive完全不陌生。所以在UI上，就像是在浏览电脑本地上一个磁盘一样。对于具体文件，一般存到云中，等到下载下来，就还是存在本地磁盘。</li>\n<li>对于每个文件，都有三种情况，下载、始终保存、释放。文件目录会在各个设备上实时自动更新，一般情况下，文件既然是从电脑A上传的，那么肯定在电脑A上，同时电脑B的文件目录也会自动更新，这时带着电脑B出去，只需要双击这个文件，就能自动从云端下载，然后打开，就彷佛它本来就在电脑B中一样。</li>\n</ol>\n<h4 id=\"具体使用\"><a href=\"#具体使用\" class=\"headerlink\" title=\"具体使用\"></a>具体使用</h4><p>​\t\tOneDrive会在第一次登陆的时候让用户选择一个本地的路径，这就是自动同步的OneDrive文件夹，默认路径为“C:\\用户[用户名]”。除了这个，“桌面”“文档”与“图片”文件夹也是可以自动同步的，只不过用户可以手动选择。</p>\n<p>​\t\t一般地，将需要同步的文件或文件夹放入上述四个文件夹内，即可实现本地与OneDrive云端的文件同步。如果我们需要同步电脑中其它位置的文件或文件夹，可以将他们直接复制粘贴到上面四个文件夹内，但比较麻烦。因此，我们可以借助mklink 命令实现。（具体操作网络上有很多教程，此处不再赘述）</p>\n<p><code>mklink /d &quot;Link&quot; &quot;Target&quot;</code></p>\n<p>注意需要管理员权限。</p>\n<h4 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h4><p>​\t\t有了这些准备，我将本地的一些必要的文件夹都上传到了OneDrive中，几万个文件花了几个小时才传完。然后笔记本就能无缝衔接主机之前的工作，主机也能无缝衔接笔记本的工作。</p>\n<p>​\t\t不过还有另外一个很意外的惊喜：隔离期间用笔记本搭建了这个博客，回家后又开始使用主机，于是萌生了把博客文件夹也上传到OneDrive的想法。用笔记本把所有博客需要的文件都上传到OneDrive后，因为主机之前也装过nodejs和hexo，git这些软件，所以相当于文件和环境都有了。然后这时候再生成一个密钥，和GitHub认证一下，相当于主机本地密钥和GitHub也配对了，竟然可以直接在主机上写博客发布文章了！</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>​\t\t不得不说，当有了多个设备后，同步的需求几乎是立刻就会产生。今日大谈OneDrive，绝无踩一捧一之意。实事求是来讲，多电脑同步的场景下，这种映射成为本地文件夹+自动同步确实很舒服。OneDrive也确实很适合个人在电脑上使用。</p>\n<p>​\t\t不过OneDrive确实也有很多问题，比如网络方面，以及它绝无法取代百度网盘，因为OneDrive并没有在国内构建起以社交网络为基础的共享生态，而百度网盘借助于微信小程序，成功渗透进了微信的社交网络中。即使OneDrive有共享功能，但是相比之下，可能大多数人还是更喜欢扫二维码吧，毕竟老板同事都在用百度网盘传文件，你又能做何选择呢？</p>\n","categories":["Geek"],"tags":["技术","OneDrive"]},{"title":"blogOasis的诞生","url":"/post/bc97fc50.html","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>说来惭愧，这是第4次搞博客了，前几次均以流产为终点。</p>\n<p>所幸这次应该是走运了，配置成功</p>\n<h2 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h2><p>其中教程参考颇多，重点有以下几个，留作纪念：</p>\n<p><a href=\"https://www.cnblogs.com/zhouyu2017/p/6485265.html\">安装Node JS – Windows</a></p>\n<p><a href=\"https://www.cnblogs.com/mingyue5826/p/11141324.html\">安装Git以及配置SSH</a></p>\n<p>(注：对于上面的SSH的两个密钥，我是这么考虑的：本地生成能够一一对应的共有密钥和私有密钥，私有存在本地，公有放在Github上。等提交更改时，用本地的私有与Github的共有密钥去进行匹配，这样既方便的同时也更安全——不用每次输入密码，防止忘记密码，并且单看长度也比自己的密码安全多了)</p>\n<p>之后安装Hexo，在本地初始化文件夹存放博客，此处略过</p>\n<h2 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h2><p>其中由于之前有次安装博客但是夭折，遇到了一个历史遗留问题：</p>\n<p>存储库的访问被拒绝</p>\n<p><img src=\"C:\\Users\\voice\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220530230105921.png\" alt=\"image-20220530230105921\"></p>\n<p>因为我之前用另一个邮箱尝试建立过博客，这次用的新邮箱</p>\n<p>关于这个问题，网络上有很多说法，并且也都成功解决了，链接如下：</p>\n<p><a href=\"https://stackoverflow.com/questions/47465644/github-remote-permission-denied\">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p>\n<p><a href=\"https://blog.csdn.net/klxh2009/article/details/76019742\">https://blog.csdn.net/klxh2009/article/details/76019742</a></p>\n<p>我甚至重装了Git</p>\n<p>但是并不适合于我</p>\n<p>最后幸好有一位大佬相助，指出可能是https和ssh之间不能直接通用</p>\n<p>于是在config.yml的配置文件中，把最后deploy的repo部分由https改成了ssh的链接，最终成功。</p>\n<p>泪目！</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>此博客来之不易，希望以后能多写博客，好好珍惜。</p>\n","categories":["Geek"],"tags":["博客"]},{"title":"二分法核心及算法细节","url":"/post/c96d2cc6.html","content":"<h2 id=\"核心：\"><a href=\"#核心：\" class=\"headerlink\" title=\"核心：\"></a>核心：</h2><ul>\n<li><p>二分并不是仅仅用于找数字的，二分的二，其本质是两种不同的状态，通过<strong>每次排除一半</strong>来逼近两种状态的分界线。</p>\n</li>\n<li><p><strong>二分</strong>的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用<strong>二分</strong>。</p>\n</li>\n</ul>\n<span id=\"more\"></span>\n\n<h2 id=\"二分细节\"><a href=\"#二分细节\" class=\"headerlink\" title=\"二分细节\"></a>二分细节</h2><h3 id=\"注意事项：\"><a href=\"#注意事项：\" class=\"headerlink\" title=\"注意事项：\"></a>注意事项：</h3><ol>\n<li><p>所有情况均为<code>if else</code>语句，更加清晰</p>\n</li>\n<li><p>注意防止mid溢出</p>\n</li>\n</ol>\n<h3 id=\"普通二分查找\"><a href=\"#普通二分查找\" class=\"headerlink\" title=\"普通二分查找\"></a>普通二分查找</h3><p>在nums中搜索target，找到返回下标，否则返回-1.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> l = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; <span class=\"comment\">// @1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt;= r) <span class=\"comment\">// @2</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[m] == target) <span class=\"keyword\">return</span> m; <span class=\"comment\">// 找到元素，返回下标</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &lt; target) l = m + <span class=\"number\">1</span>; <span class=\"comment\">// @3</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) r = m - <span class=\"number\">1</span>; <span class=\"comment\">// @4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先要明确，二分到最后肯定是不断逼近一个数字的，类比数学上二分找函数零点的思想。</p>\n<p>上述的四处@，是四个注意的点，下面分别说一下：</p>\n<ul>\n<li><p>@1： r是<code>nums.size()</code>还是<code>nums.size()-1</code>?，这个选择其实是自由的，因为我们二分的目标在于，用尽量少的次数去找到目标值，其本质还是基于遍历的思想（不知道这么说是否准确，我的理解是，二分每次可以舍弃一半，但是这一半的舍弃我们确定不会对结果产生影响，所以舍弃，但是不能舍弃掉未知的元素。举个例子，这个nums数组有n个元素，那就必须n个元素都考虑在内，不能从第2个元素开始遍历）。既然要遍历，那么我们这里的<code>r</code>和<code>l</code>，也就是在确定遍历的范围。我们知道元素的下标是<code>0</code>到<code>nums.size()-1</code>，因此这里选择<code>nums.size()</code>还是<code>nums.size()-1</code>无所谓，<strong>只要保证搜索区间范围包含所有元素即可</strong>。对于选择<code>nums.size()</code>，那我们的搜索区间就是<code>[l,r)</code>，选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code></p>\n</li>\n<li><p>@2： <code>l &lt;= r</code>还是<code>l &lt; r</code>，这里的范围是由上面的搜索区间决定的。</p>\n<ul>\n<li><p>如果选择<code>nums.size()</code>，搜索区间是<code>[l,r)</code>，那么这里就应该是<code>l &lt; r</code>，可以用反证法，如果是<code>l &lt;= r</code>，那么如果一直向<code>r</code>逼近的话，<code>r</code>保持不变，<code>l</code>最终等于<code>r</code>，就会越界，所以是<code>l &lt; r</code>。</p>\n</li>\n<li><p>选择<code>nums.size()-1</code>，我们的搜索区间是<code>[l,r]</code>，这里应该是<code>l &lt;= r</code>，这时不怕越界，如果是<code>l &lt; r</code>的话，<code>l</code>最大也就是<code>r - 1</code>，那么会导致最后一个元素漏掉。</p>\n</li>\n<li><p>对于最后返回-1，<code>l &lt;= r</code>，终止条件是<code>l 等于 r + 1</code>，区间为空，可直接返回；但如果选择<code>l &lt; r</code>，终止条件是<code>l 等于 r</code>，但可能会漏掉一个元素（之所以可能，是因为如果<code>l</code>等于<code>r</code>等于<code>nums.size()</code>，那么无所谓，但如果是在内部，那么这个地方就没有顾及到）</p>\n</li>\n<li><p>如果数组是<code>&#123;1, 2, 3, 4, 5, 6, 7&#125;</code>，目标是3，那么就会找不到（已运行验证（注意这里说的是 <code>r=nums.size()</code>并且<code>l &lt; r</code>的循环条件）)，所以为了防止漏掉，要检查这个地方，即</p>\n</li>\n<li><p>&#96;&#96;&#96;cpp<br>if(l &lt; nums.size() &amp;&amp; nums[l] &#x3D;&#x3D; target) return l;<br>else return -1;</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">- @3： 3与4是一个问题，放在一块说。有时候是`l = m`，有时候是`l = m + 1`，这里还是由于搜索空间决定的，这里左右边界的变化，决定了下一次的搜索空间。对于这个题，我们要保证所有的都遍历过，而现在`nums[m]`已经遍历过，那么不再需要遍历，下一次的空间就应该是`[l, m - 1]`或者`[m + 1, r]`。这是由一开始的搜索空间决定的，如果一开始是`[l, r)`，那么经过m后，要保持相同格式，就应该是`[l, m)`与</span><br><span class=\"line\">  </span><br><span class=\"line\">  `[m +1, r)`。</span><br><span class=\"line\"></span><br><span class=\"line\">### 边界二分查找</span><br><span class=\"line\"></span><br><span class=\"line\">上面的二分可以查到目标值，但是如果有多个目标值，我们想要第一个或者最后一个的边界值又该怎么办呢？</span><br><span class=\"line\"></span><br><span class=\"line\">要在下一次的**搜索空间**上下功夫：</span><br><span class=\"line\"></span><br><span class=\"line\">#### 左边界二分</span><br><span class=\"line\"></span><br><span class=\"line\">核心代码：</span><br><span class=\"line\"></span><br><span class=\"line\">```cpp</span><br><span class=\"line\">while(l &lt; r) &#123; // 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是 &lt;</span><br><span class=\"line\">    int m = (r - l) / 2 + l;</span><br><span class=\"line\">    if(nums[m] == target) &#123;</span><br><span class=\"line\">        r = m; // @1</span><br><span class=\"line\">    &#125; else if(nums[m] &gt; target) &#123;</span><br><span class=\"line\">        r = m; // @2，m已经验证过，但这里保持m，是为了保持[l, r)的区间格式</span><br><span class=\"line\">    &#125; else if(nums[m] &lt; target) &#123;</span><br><span class=\"line\">        l = m + 1; // @3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if(l &lt; nums.size() &amp;&amp; nums[l] == target) return l; // 原因上面已谈及</span><br><span class=\"line\">else return -1;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>@1： 当我们找到一个符合条件的，由于需要找最左边的，不能直接返回，而是缩小上界。那如果只出现一次，将其放在<code>r</code>中，但最后返回<code>l</code>，有影响吗？经验证，没有影响，如果只出现一次，在第一次遇见放到<code>r</code>中，那么<code>l</code>会不断逼近直到与<code>r</code>相等（这也就是循环条件），所以最后返回<code>l</code>也是可以的。</p>\n</li>\n</ul>\n<h4 id=\"右边界二分\"><a href=\"#右边界二分\" class=\"headerlink\" title=\"右边界二分\"></a>右边界二分</h4><p>核心代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(l &lt; r) &#123; <span class=\"comment\">// 此处同上，由一开始的区间决定，不再解释，不过边界的一般习惯是&lt;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> m = (r - l) / <span class=\"number\">2</span> + l;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[m] == target) &#123;</span><br><span class=\"line\">        l = m + <span class=\"number\">1</span>; <span class=\"comment\">// @1</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &gt; target) &#123;</span><br><span class=\"line\">        r = m; <span class=\"comment\">// 同上</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[m] &lt; target) &#123;</span><br><span class=\"line\">        l = m + <span class=\"number\">1</span>; <span class=\"comment\">// 同上</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(l &gt; <span class=\"number\">0</span> &amp;&amp; nums[l - <span class=\"number\">1</span>] == target) <span class=\"keyword\">return</span> l - <span class=\"number\">1</span>; <span class=\"comment\">// @2</span></span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在找右侧边界时，即最后一个，那么如果当前的m大了，为保持左闭右开，<code>r = m</code>，如果m小了，<code>l = m + 1</code>。</p>\n<p>在@1中，可以看到是增大了下届(如果这里不加1，可能会出现死循环，因为m是向下取整，在只有两个数时，无法区分，比如3和4，中点是3，如果3不符合条件则会一直循环)，这里的+1对于返回值@2产生了影响，容易看到如果只有一个数字符合，这时候<code>l</code>又加1，那么应该返回<code>l - 1</code>。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文简要介绍了关于二分法在代码实现上的相关细节， 二分法思想比较简单，但是细节很多， 需要多注意。</p>\n","categories":["Geek"],"tags":["Developer","技术","Programming","算法","二分"]},{"title":"动态规划之爬楼梯","url":"/post/29a0832b.html","content":"<p>爬楼梯的三种题型</p>\n<span id=\"more\"></span>\n\n<!-- more -->\n\n<!-- more -->\n\n<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">question1：</span><br><span class=\"line\">假设你正在爬楼梯。需要n阶才能到达楼顶。</span><br><span class=\"line\">每次可以爬1或2个台阶。有多少种不同的方法可以爬到楼顶？</span><br></pre></td></tr></table></figure>\n\n<p>当我们站在第n层台阶时，只能是由n-1阶或者n-2阶跳上去的。因此我们需要保存到达n-1和n-2级台阶的方法数。不妨设置大小为n+1的数组dp（dynamic programming），其中dp[i]代表到达第i级台阶的方法数。由上可知，有dp[i]&#x3D;dp[i-1]+dp[i-2]，不难看出此数组即位斐波那契数列。<br>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solution1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; n;<span class=\"comment\">// 直接判断</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> dp[<span class=\"number\">51</span>] = &#123;&#125;; <span class=\"comment\">// 假设最多50级台阶</span></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::cout &lt;&lt; dp[n] &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于对于每一个台阶，只需要保存前一级台阶和前两级台阶，因此只需要两个变量的空间即可。</p>\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solution2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>)&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; n;<span class=\"comment\">// 直接判断</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> pre = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> prePre = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        result = pre + prePre;</span><br><span class=\"line\">        prePre = pre;</span><br><span class=\"line\">        pre = result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"提高\"><a href=\"#提高\" class=\"headerlink\" title=\"提高\"></a>提高</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">question2：</span><br><span class=\"line\">爬楼梯。</span><br><span class=\"line\">每次可以爬1或2个台阶，并且不能连续跳两次二级台阶，有多少种不同的方法可以爬到楼顶？</span><br></pre></td></tr></table></figure>\n\n<p>由于对两阶的连续性作出了限制，因此我们除了保存<strong>跳跃之前在哪一级台阶</strong>之外，还需要保存前一次是否跳了两阶。此时不妨设一个二维数组，对于<code>dp[i][j]</code>而言，其中i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**。最终到第n级台阶的总数就是<code>dp[n][0]+dp[n][1]</code>。对于第i级台阶来说，满足以下关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[i][0]=dp[i-1][0]+dp[i-1][1];</span><br><span class=\"line\">dp[i][1]=dp[i-2][1];</span><br></pre></td></tr></table></figure>\n\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solution3</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> dp[<span class=\"number\">51</span>][<span class=\"number\">2</span>] = &#123;&#125;; <span class=\"comment\">//i代表处于第i级台阶，j代表连续跳2阶的次数，由于不能连续跳两级，所以j只能是0或者1，dp[i][j]就代表连续j次跳了两级台阶后到达第i级台阶的方法数，j只能是0或1</span></span><br><span class=\"line\">    <span class=\"comment\">//所以最后返回dp[n][0]+dp[n][1]</span></span><br><span class=\"line\">    <span class=\"comment\">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]</span></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]; <span class=\"comment\">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有2种情况，分别是0次两级，1次两级</span></span><br><span class=\"line\">        dp[i][<span class=\"number\">1</span>] = dp[i - <span class=\"number\">2</span>][<span class=\"number\">0</span>];<span class=\"comment\">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是之前跳了一级然后到的前两级</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; dp[n][<span class=\"number\">0</span>] + dp[n][<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"拓展一\"><a href=\"#拓展一\" class=\"headerlink\" title=\"拓展一\"></a>拓展一</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">question3：</span><br><span class=\"line\">爬楼梯。</span><br><span class=\"line\">每次可以爬1或2个台阶，并且不能连续三次跳两级台阶，有多少种不同的方法可以爬到楼顶？</span><br></pre></td></tr></table></figure>\n\n<p>与第二种情况类似，**<code>dp[i][j]</code>就代表连续j次跳了两级台阶后到达第i级台阶的方法数**，j只能是0，1，或者2。从<code>dp[i][j]</code>开始，可以有两种情况，一种是跳了一级到i+1级，且跳两级台阶的次数为0，即<code>dp[i+1][0]</code>,另一种跳了两级，到i+2级台阶，跳两级台阶的次数为j+1，即<code>dp[i+2][j+1]</code> 。</p>\n<p>代码：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sln</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; n;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"type\">long</span> dp[<span class=\"number\">51</span>][<span class=\"number\">3</span>] = &#123;&#125;; <span class=\"comment\">//二维数组dp的第二维 0 1 2表示的是: dp[i][j] 在第i级台阶，之前是有连续j次走了二级台阶的方法数</span></span><br><span class=\"line\">    <span class=\"comment\">//所以到达第n阶的总方法数就是dp[n][0]+dp[n][1]+dp[n][2]</span></span><br><span class=\"line\">    <span class=\"comment\">//从dp[i][j]开始，可以有两种情况，一种到dp[i+1][0],因为没有连续两级台阶，一种到dp[i+2][j+1]。</span></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">0</span>][<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>][<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    dp[<span class=\"number\">2</span>][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">2</span>][<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    dp[<span class=\"number\">2</span>][<span class=\"number\">2</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">        dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>]; <span class=\"comment\">// 到了第i级台阶，并且之前一次不是两级台阶，则只能是由前一级台阶来的，并且如何到的前一级台阶? 可以有3种情况，分别是0次两级，1次两级，2次两级</span></span><br><span class=\"line\">        dp[i][<span class=\"number\">1</span>] = dp[i - <span class=\"number\">2</span>][<span class=\"number\">0</span>];<span class=\"comment\">// 到了第i级台阶，并且之前一次是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 为保证最近仅一次跳了两级，唯一情况是跳了一级然后到的前两级</span></span><br><span class=\"line\">        dp[i][<span class=\"number\">2</span>] = dp[i - <span class=\"number\">2</span>][<span class=\"number\">1</span>];<span class=\"comment\">// 到了第i级台阶，并且之前两次都是两级台阶，是由前两级台阶来的，并且如何到的前两级台阶? 唯一情况是跳了两级然后到的前两级</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; dp[n][<span class=\"number\">0</span>] + dp[n][<span class=\"number\">1</span>] + dp[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后两种情况也同样可以 用变量代替数组，但是对于理解来说数组更友好，因此没有给出变量版本。</p>\n<h2 id=\"拓展二：最小花费\"><a href=\"#拓展二：最小花费\" class=\"headerlink\" title=\"拓展二：最小花费\"></a>拓展二：最小花费</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">爬楼梯。</span><br><span class=\"line\">从楼梯第i个台阶向上爬需要支付cost[i]的费用。</span><br><span class=\"line\">一旦你支付此费用，即可选择向上爬一个或者两个台阶。</span><br><span class=\"line\">返回爬到楼顶需要的最小花费。</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">sln</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> size = cost.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(size + <span class=\"number\">1</span>)</span></span>; </span><br><span class=\"line\">    <span class=\"comment\">// dp[i] 是到第i层后的最小花费，其中包括第i层的花费</span></span><br><span class=\"line\">    dp[<span class=\"number\">0</span>] = cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">    dp[<span class=\"number\">1</span>] = <span class=\"built_in\">min</span>(cost[<span class=\"number\">1</span>], cost[<span class=\"number\">0</span>] + cost[<span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i &lt;= size; i++) &#123;</span><br><span class=\"line\">        dp[i] = (i == size ? <span class=\"number\">0</span> : cost[i]) + <span class=\"built_in\">min</span>(dp[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dp[size];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的解决方法中，将<code>cost[i]</code>放在了<code>min</code>的外面，是因为基于这样的思路：到达第<code>i</code>级台阶后将立刻花费，所以放在外面，只需关注是前一级花费小还是前两级花费小即可。</p>\n<p>到达楼顶时，由于超出<code>cost</code>的范围，因此该层花费为0。</p>\n","categories":["Geek"],"tags":["Developer","技术","Programming","算法","动态规划"]},{"title":"the-second-sex","url":"/post/bf968ce7.html","content":"<h1 id=\"第二性摘录\"><a href=\"#第二性摘录\" class=\"headerlink\" title=\"第二性摘录\"></a>第二性摘录</h1><ol>\n<li>“女性是第二性，排除在男性以外的“他者”。权力归于男性，女性仅仅是附庸。附庸的庇护来自权力，歧视也来自于权力。事实就是如此，谁家生了女儿也还是叹惋一阵儿。连在性交中，女性都是处于被动和守势，像个容器，收纳男性的欲望。”</li>\n<li>“夫妻是这样一个共同体，它的成员失去了独立性却不能够摆脱孤独；他们是一种静态的结合，是“同一个人”，而不是在维持一种动态的、充满活力的关系。”</li>\n<li>“但情况依然是，女人打扮得越漂亮，她就越受到尊重；她越是需要工作，绝佳的外貌对她就越是有利；姣好容貌是一种武器，一面旗帜，一种防御，一封推荐信。”</li>\n<li>“人们常说，女人打扮是为了引起别的女人的嫉妒，而这种嫉妒实际上是成功的明显标志；但这并不是唯一的目的。通过被人嫉妒、羡慕或赞赏，她想得到的是对她的美、她的典雅、她的情趣——对她自己的绝对肯定；她为了实现自己而展示自己。”</li>\n<li>“服饰对许多女人之所以如此重要，是因为它们可以使女人凭借幻觉，同时重塑外部世界和她们的内在自我。”</li>\n<li>“肖伯纳说，让人们受到束缚比让他们摆脱这种束缚更容易，只要这种束缚会带来利益。”</li>\n<li>“打扮不仅仅是修饰，它还表明了女人的社会处境。”</li>\n<li>“想想也真可悲，”米什莱写道，“女人，这个相对的人，只能作为夫妻中的一员来生活，她往往比男人孤独。他广交朋友，不断有新的接触。她若无家庭则什么也不是。而家庭是一种摧残人的负担；它的全部重量都压在她的肩上。”</li>\n<li>“ 一种没有雄心也没有激情的金光闪闪的平庸，漫无目的，无限地周而复始的日子，缓缓地滑向死亡，不寻思原因的生活。原封不动地保存和重复世界，看来既不可取，也不可能。”</li>\n<li>“女人不是天生的，而是造就的。”</li>\n<li>“人们将女人关闭在厨房里或者闺房内，却惊奇于她的视野有限；人们折断了她的翅膀，却哀叹她不会飞翔。但愿人们给她开放未来，她就再也不会被迫待在目前。”</li>\n<li>“一个人不是生下来就是女人，她是变成女人的。”</li>\n<li>“男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</li>\n<li>“如果女人只是一个消极的实体，男人所支配的不过虚无而已。他自以为他正在攫取使他丰富的东西，实际上那只是幻念。”</li>\n<li>“真正的价值并不源于外在的事物，而是源于人心。”</li>\n<li>“司汤达：妇女解放不只泛泛地打起自由的旗号，还要凭着个人幸福的名义。爱情决不会丧失什么东西，相反，当女人与男人平等之时，她越是能完全理解他，爱情便越是真诚。”</li>\n<li>“几乎没有什么工作能比永远重复的家务劳动更像西绪弗斯所受的折磨了：干净的东西变脏，脏的东西又被搞干净，周而复始，日复一日。家庭主妇在原地踏步中消耗自己：她没有任何进展，永远只是在维持现状。她永远不会感到在夺取积极的善，宁可说是在与消极的恶做无休止的斗争。”</li>\n<li>“然而事实上，当两个人一方面彼此憎恶，另一方面又必须相依为命时，这种关系并不是人类一切关系中最真诚、最动人的，宁可说是最可怜的。”</li>\n<li>“爱是一种外向的活动，一种指向另一个人、指向与自己相分离并明显有别于自己的存在、指向可以见到的终点——未来的冲动。”</li>\n<li>“婚姻的悲剧性并不在于它无法保障向女人许诺过的幸福（保障幸福这种事本来就不存在），而在于它摧残了她；它使她注定要过着周而复始的千篇一律的生活。”</li>\n</ol>\n","categories":["Reader"],"tags":["女性","波伏娃","阅读"]},{"title":"中国智慧与当代社会","url":"/post/2454a085.html","content":"<h3 id=\"人民有信仰，国家有力量，民族有希望\"><a href=\"#人民有信仰，国家有力量，民族有希望\" class=\"headerlink\" title=\"人民有信仰，国家有力量，民族有希望\"></a>人民有信仰，国家有力量，民族有希望</h3><p>层层递进的关系</p>\n<h4 id=\"民族的信仰在哪里？\"><a href=\"#民族的信仰在哪里？\" class=\"headerlink\" title=\"民族的信仰在哪里？\"></a>民族的信仰在哪里？</h4><p>信仰：</p>\n<ol>\n<li>对生命价值的确认 </li>\n<li>对人生意义的领会</li>\n</ol>\n<p>87年的深圳标语：时间就是金钱，效率就是生命，回答的正是这个问题。不可否认的是在当时，这两句话起到了积极的作用，但不能长久支持中华民族。</p>\n<p>疫情让我们飞速发展的社会停下来，我们应该要思考改革开放几十年后所缺少的东西：</p>\n<ol>\n<li>敬重天道</li>\n<li>敬畏人性</li>\n</ol>\n<p>中华民族有文化生命，诗经言：周虽旧邦，其命维新</p>\n<p>科学给我们知识，但不等于智慧。在科学中不意味着在思想中。</p>\n<p><strong>应无所住，而生其心。</strong></p>\n<p>住：住相。相：世界上所有的事物与人都区分出高低贵贱。Eg.钻石与普通石头</p>\n<p>高低贵贱并不是自然物本身的属性，人为区分。</p>\n<p>相是客观的，有人类社会就有相。</p>\n<p>不执著于相，显现本心。</p>\n<p>教科书中是知识与对知识的论证。</p>\n<p>​        当代人无法生出智慧，因为我们所生存的当代文明，已经高度复杂化，充满了知识与机巧，这种人离开智慧最为遥远。在朴素文明中生活的人，才有可能俯仰天地，领会天人之际。我们的智慧只能是对古代智慧的解读。</p>\n<p>​        西汉初年为道家思想，无为而治。但无法长久，因为道家的学说无法为任何一个民族，为他的社会秩序，奠定一个精神基础。才有的罢黜百家，独尊儒术。中国的道统是儒家。</p>\n<p>今天的中国人，从根本上来看，其对生命价值的确认，还是源于儒家。</p>\n<p>儒家让我们站在大地上，这个大地就是<strong>亲情和亲情传递给我们的牵挂和责任</strong>。</p>\n<p>无论如何学西方，根本上还是儒家。</p>\n<p><strong>儒道互补</strong>：儒家讲原则、理想、社会的伦理精神</p>\n<p>道家讲<strong>权变</strong></p>\n<p>原则性与灵活性的高度统一</p>\n<p>灵活性过头，导致以权变经，便会产生奸猾的人生态度。</p>\n<p>菠萝，三昧均是音译，中国文化中没有对应的思想，也就没有对应的汉字。</p>\n<p>唐朝佛学中国化，才有了众多的词语。</p>\n<p>儒家讲性理（人性），道家讲玄理，佛家讲空里。</p>\n<p>玄理：房间的四周墙壁的有，都是为了中间的无。有和无之间的关系。</p>\n<p>玄之又玄，众妙之门。</p>\n<p>​        人的生命对自身就是问题。人心的安顿，（对无限的一面，需要安顿）有限的一面是对周遭事物的经验与知识，因为其对象便是有限的。</p>\n<p>筹划未来落空了，也就是有了烦恼。</p>\n<p>​        大多数人在绝大多数时间同时具备着温饱，安全与健康，但我们仍然是烦恼不断。此之为<strong>无限心</strong>。</p>\n<p>不仁者，不可以久处约，不可以长处乐。</p>\n<p>（约：节约，贫贱的生活处境，不仁者：心没安顿好）</p>\n<p>不仁者，贫贱难耐凄凉，富贵不能乐业。</p>\n<p>无论你买的多豪华的东西，都是暂时的为你使用。<strong>无限的心又如何安顿在有限的事物中</strong></p>\n<p>安顿心，只能两种方法：<strong>宗教与哲学</strong></p>\n<p><strong>儒：无所为而为</strong>。做事并不是为了达成某个目标的途径与手段，事情自己就是自己的价值与意义，而不是其他任何事情。因此没有失败的人生——任何事情都不是为了其他事情的手段与途径。</p>\n<p><strong>道：无为而无不为</strong>。人+为&#x3D;伪(造作) 减少做事时人为的因素。</p>\n<p>生非贵之所能存，身非爱之所能厚；</p>\n<p>生亦非贱之所能夭，身亦非轻之所能薄。</p>\n<p>饮食：已饥方食，未饱先止。</p>\n<p>伟大的哲学典籍，只需要懂几句话便可以终身受用（上善若水）</p>\n<p><strong>佛：无心而为</strong>。做事是为了消业，希望没有结果才好。</p>\n","categories":["IDEA"],"tags":["哲学","人文情怀"]},{"title":"一些对于博客的归纳","url":"/post/1a07e293.html","content":"<p>本人很喜欢写东西，无论是道听途说，还是捕风捉影，抑或是经典小作文，我都想要用文字记录下来，上大学以来在OneNote上记录的也不少了。</p>\n<span id=\"more\"></span>\n\n<p>一个博客，应该是能够体现我这些想法的，而不仅仅只用来存放技术类的知识（个人想法）。</p>\n<p>然而博客维护起来相对还是比较麻烦的，一是要面对其他人而不是自己，遣词造句上需要再三斟酌；二来毕竟要放在一个公开的互联网上，dddd。</p>\n<p>于是即使有三位数的博文，却出现了这样的一个尴尬局面：</p>\n<p><strong>想写的东西不能写，</strong></p>\n<p><strong>能写的东西不想写。</strong></p>\n<p>希望能尽量多的发布一些想写又能写的东西吧。</p>\n","categories":["IDEA"],"tags":["博客","总结"]},{"title":"资本论系列视频笔记","url":"/post/84e29d5d.html","content":"<p>资本论不是经济学，其副标题是政治经济学批判</p>\n<p><strong>物理事实 + 范畴 &#x3D; 社会事实</strong></p>\n<p>社会事实不是直接给予我们的，事实是被范畴所建构的，只能看到物理世界物理事件</p>\n<p>比如警匪事件就是政治概念，二者都属于暴力事件，但是匪是私人非法暴力，警是公共合法暴力。</p>\n<h2 id=\"资本雇佣劳动\"><a href=\"#资本雇佣劳动\" class=\"headerlink\" title=\"资本雇佣劳动\"></a>资本雇佣劳动</h2><p>经济事实：<strong>资本雇佣劳动</strong></p>\n<p>其中隐藏的三个经济范畴：资本——工资——商品</p>\n<p>劳动是作为商品——因为被购买，购买也就是雇佣的意思</p>\n<p>前资本主义的师徒关系只是半人身依附关系，没有市场行为，也就没有工资的范畴。</p>\n<p>这句话意思：资本的范畴拿出一部分（称为工资），工资用来雇佣（工资里隐藏着雇佣的范畴）作为商品范畴的劳动</p>\n<p>在其中发生了等价交换，隐含价值这个范畴</p>\n<p>资本主义生产关系被认为是人类迄今为止找到的最合理的生产关系，他没有政治强制，等级压迫。而是独立的个人在市场上实现等价交换</p>\n<p>如果把资本雇佣劳动中的三个范畴都去掉，即去掉资本，去掉工资，去掉商品这三个范畴，经济事实是没了，但是事情还在发生。因为如果没有资本，也就是没有过去积累起来的劳动。</p>\n<p>若我没钱，只有活劳动这种能力，为了保证自己的物质需求，那我必须去找那些拥有过去积累起来的劳动的人。（包括生产资料土地设施机器）</p>\n<p>人类积累起来的劳动有两种，一种是直接消费品，一种是生产消费品，后者可以用来生产新的消费品，也就是创造新的价值。</p>\n<p>当今人类生产的目的是价值的增殖。谁有生产资料，谁就可以拥有一种力量，使得没有生产资料的人的生命一部分时间由这些人所支配。</p>\n<p>把范畴去掉后，该经济事实变为事情本身，即<strong>生产资料行使对活劳动的支配权。</strong></p>\n<p>马克思的哲学革命就是在去除原本事实中的那些范畴，即现象学还原。</p>\n<p>范畴之间有逻辑关系，因此是理性的。理性的基础是价值，等价交换。以统一的尺度交换，这个尺度是货币。</p>\n<p><strong>价值增殖的竞争是积累起了的劳动对活劳动的支配权的竞争。</strong></p>\n<h2 id=\"社会权力\"><a href=\"#社会权力\" class=\"headerlink\" title=\"社会权力\"></a>社会权力</h2><p>社会权力：<strong>social power</strong>。</p>\n<p>对资本作理性的研究叫做经济学，但是如果发现资本实际上是一种权力，是支配别人的力量，就发现资本是当代社会权力。</p>\n<p>赚钱的目标：脱贫、安全、权力（代表支配别人和被别人支配），即使财务自由了，但离着权力还远，就会还以为自己很穷。</p>\n<p>还原后，一个合乎理性的事实变成了非理性的人与人的关系，power</p>\n<p>今天的国家机器如此强大是为了什么？20世纪基本完成国家独立，民族解放，为什么还要拥有如此多威力空前的杀人武器？按照国际理性法则做生意、外交，一切都已经正常了，为什么还要建立？</p>\n<p>根源不是我们比以往更饥饿了，根源在于社会权力。经济学家把资本的竞争描述为一个理性的活动。马克思告诉我们这是斗争，是非理性的，是一部分人统治另一部分人的活动。</p>\n<p>王国维：世界上的学问只有两种，一种可爱而不可信，一种可信而不可爱。经济学理论是可爱的，马克思学说是可信而不可爱。</p>\n<p>我们不喜欢斗争，我们要人道主义精神。</p>\n<p>比尔盖茨说：<strong>人类在科学技术方面所取得的所有成就都不足以让人们 自豪，人类在经济建设方面所取得的所有成就都不足以让人们自豪，人们只有在减轻或者消除人类不平等境遇方面所取得的所有成就才足以让人们自豪。</strong> 但今天我们一直在倒退，今天的市场经济是穷人为富人打工的经济，你口袋里的钱越多，整个市场为你服务的动力就越大，你口袋的钱越少，市场为你服务的动力就越小直至降低为零。当我们在歌颂当今市场经济的繁荣的时候，我们不要忘记地球上有十亿人口其每天的消费水平不足一美元。（当然现在中国人民已经不在其中了，因为我们实现全面小康了）</p>\n<p>比尔盖茨没说社会权力，而是说的不平等，这不是政治的不平等，我们都有投票权，你也可以主动离开老板。</p>\n<p>比尔盖茨想让市场为穷人服务，将企业的资本分为有形的与无形的。无形的就是社会声誉，他举例联合国向全球医疗企业招标，能不能以成本价向非洲投放疫苗，奖励是给予新药市场份额。这里说明他不懂马克思。</p>\n<p><strong>资本增殖的本身必然创造了一部分的相对贫困，造成社会分裂，之后再去消弭贫困，否则剩余价值无从谈起。</strong> 如果比尔盖茨一开始就是慈善家，他不可能成为世界首富。比尔盖茨觉得他没有创造相对贫困，他不应该为此负责，资本的本性如此。</p>\n<p>现代贫困不是等级压迫的结果，<strong>价值范畴的等价交换掩盖了贫困的不断被制造</strong>。</p>\n<p>法国的黄马甲运动，表面是燃油，但其实是通货膨胀导致相对贫困。</p>\n<p>英国脱欧是民众投票的，英国是靠的金融，那么为什么脱欧呢？最终脱欧说明在加入欧盟以及全球化过程中，获利的全都是英国的大资产阶级获利。一个金融，一个贸易。</p>\n<p>由此根据马克思的学说，逆全球化才是主导趋势。</p>\n<p>资本竞争，上升Social power上升到国际层面，国与国之间会穷兵黩武，国内则是社会分裂，或政党之间的斗争</p>\n<p>马克思说资本主义的每一次成功发展，必然伴随着社会权力的扩大，权力就是冲突、对抗，是非理性的。</p>\n<p>资本capital分为财富wealth和权力power，财富不以土地和牲畜的多少计算，这是使用价值多，资本增殖了才叫财富。研究资本的运动，也就是研究社会权力的变动。财富增加，权力必然同步扩大，导致社会矛盾。</p>\n<p>政治权力是国家机器，军队警察监狱，这是用于维护社会权力的。</p>\n<p>一个弱小的人如果有很多钱，首先他不会担心别人抢，因为有政治权力即国家机器保护社会权力；其次一大堆人会不断游说他让他投资，即求着他雇佣，求着他支配自己的一部分生命时间。这个过程，钱没说话，所以社会权力不是观念，不是idea，但我们说的话一直在承认它的力量。</p>\n<p>但是观念必然会来，观念把这个真实的感性的力量表达为right权利，法的范畴就上去了</p>\n<p>power——权力</p>\n<p>right——权利</p>\n<p>非理性的权力变成了理性的权利</p>\n<p>无论政策如果变，我手里有social power，最后谁听谁的？</p>\n<p>社会权力不能直接等同于政治权力。</p>\n<p>所以改革是不可避免的，国营企业拥有资本同时是政治权力，需要把政治拿掉，还原为社会权力才行。当时有投资饥饿症，也就是投资后利润达不到，但是不能倒闭，所以继续投资。</p>\n<p>所以我们改革，承认社会权力，承认体制外的经济活动，不承认的时候叫投机倒把，现在变成了搞活经济。这是意识形态的改变，观念的改变。</p>\n<p><strong>Power + ideology(意识形态) ——&gt; Right</strong></p>\n<p>政治权力承认了社会权力，将其表达为私有财产的权利，上升到了法的概念（2006年物权法）。</p>\n<p><strong>扩大开放：承认国外的social power</strong></p>\n<p><strong>深化改革：清洗掉国内在social power上的政治维度</strong></p>\n<p>不是Right让你拥有了支配别人的力量，而是social power</p>\n<p>所以改革开放并不是观念的改变，不是思想解放的结果，这是历史唯心主义。而是在计划经济晚期，产生了异质的要素，这是不能容纳在计划经济内的。产生的原因则是因为有货币。只要有货币，有商品交换，价值规律就一直在起作用。因此社会主义计划经济体制本身包含着与自身相异的要素。</p>\n<p>以苏联为首的社会主义国家的行为难道叫做社会主义吗？不是，价值规律一直在起作用。</p>\n<p>当时实际上是没有资本家的资本社会</p>\n<p>这种异质的东西一定会突破计划经济，这是不可避免的。所以新的社会权利一定会在原本的计划经济中成熟起来，然后意识形态要表达它，上层建筑（法的体系和国家制度）都要表达它。power决定了right，就是经济基础决定上层建筑（思想上的意识形态与政治上的国家制度和权力机器）</p>\n<h2 id=\"劳动抽象化\"><a href=\"#劳动抽象化\" class=\"headerlink\" title=\"劳动抽象化\"></a>劳动抽象化</h2><p>范畴本身，是怎么来的比如价值这个经济范畴怎么来的？</p>\n<p>价值这个范畴我们觉得很容易理解，只要商品交换存在那么人类的产品呢它就有两个维度：一个叫使用价值，比如说这块手表使用价值用来看时间，这块手表价值200块，是他的价值。劳动产品成为商品，那么就意味着有一个价值范畴</p>\n<p>200块的手表和值200块的皮鞋可以等价交换，本来生产手表的劳动跟生产皮鞋的劳动是完全不同的劳动，是完全不同的使用价值。他们之前是无法通约的。作为商品交换，必须通约，满足等价交换的原则。</p>\n<p>这时需要把劳动抽象化，即一定时间内人类时间与体力的支出。<strong>劳动也有二重性，使用价值是具体劳动创造的，价值是抽象劳动创造的，虽然在现实中这是一种劳动。</strong></p>\n<h2 id=\"生产目的改变\"><a href=\"#生产目的改变\" class=\"headerlink\" title=\"生产目的改变\"></a>生产目的改变</h2><p>商品交换在资本主义之前就有了，</p>\n<p><strong>W - G - W</strong>，这时货币只有媒介的作用，只是流通手段。但对于投资来说，则是<strong>G - W - G’<strong>。前者生产目的是获得我不能生产的产品，后者的生产目的是货币增殖，</strong>G’ &gt; G</strong>，差值就是剩余价值。这意味着原来仅仅是流通手段的<strong>货币，变成了财富的主体</strong>。</p>\n<p>中国古代也有商品流通，但商人积攒货币后，是置办田产，有了田地才是真正有了财富，这是中国古代。但是欧洲不一样，因为<strong>欧洲贵族对土地的占有制是世袭的</strong>。所谓封建，就是封土建国，所以欧洲和中国古代封建不一样。中国阶层是可以流动的，一个是科举，一个是财富。所以中国古代内部不能发展出资本主义，中国古代的人们不可能把生产的目的变为剩余价值，我们追求的是使用价值。</p>\n<p>欧洲商人的货币无法转换为土地，资产阶级的法语意为城关市民。商人就是在领地之中从事贸易，如果受到贵族武装侵袭，就需要武装保护。</p>\n<p>欧洲资产阶级成长的三个阶段，第一个是将自己武装起来与贵族武装进行战斗，但是经常失败；到了第二阶段：建立资本所需要的政治制度，即各种革命；第三阶段是与无产阶级斗争</p>\n<p>商人的目的是<strong>赢得动产的自由，即动产能够战胜不动产的历史权威，让货币战胜土地。</strong> 前提是贵族要垮台，而当时欧洲贵族喜好东方瓷器绸缎，于是商人扩大海外贸易，让贵族的钱到商人中。没钱了，也就没钱支付仆人、土地上的半农奴。这批人奔向城市，但行会手工业完全是闭源的，这批人<strong>自由了，但自由的一无所有</strong>。而此时，商人等着他们呢——工厂手工业。商人一开始不在生产领域，而是在流通领域，但时间长了，商人肯定更了解市场的需要，商人想要手工业服从于市场，但是行会手工业不服从市场，而是一定区域的老主顾，这种手工业没有扩大生产的需要。</p>\n<p>等到大量劳动力进入到城市中，商人又在等着他们，一种新的商品出现了——劳动力。商人投入资金，雇佣劳动力，生产商品，进入市场，获得资金，继续雇佣劳动力扩大生产。<strong>生产目的改变了——追求剩余价值。</strong></p>\n<p>但是资本的生命本性就是增殖，按其本性，要求他一定要突破欧洲有限市场，走向世界的市场。商人与劳动力结合，与贵族对抗，贵族要么卖爵位，要么卖地，要么转变为资本家（新贵族）</p>\n<p>由此土地世袭占有权改变。土地被纳入到资本中，产生了圈地运动，羊吃人。</p>\n<p>要现代化必须先工业化，工业化的前提是什么？剥夺农民的土地所有权。工人生产不能吃不能穿的东西，但是工人自己要吃要穿，谁来提供？农民。如何理解计划经济，<strong>一个后发的现代化国家，如何快速工业化，实质是剥夺农民的土地所有权，通过差价交换农业与工业产品。</strong> 比欧洲温和，但是就是穷。不剥削农民，不可能短时间实现工业化。</p>\n<p>资本开创了世界史。</p>\n<p>欧洲的王室是支持商人的，因为王室最大的敌人是贵族。</p>\n<p>东印度公司是英国最著名的</p>\n<p>国富论的原则：让政治从市场中退出</p>\n<p>政治经济学经历的阶段：重商主义到重农主义，再到一门科学，标志就是劳动价值理论，这让经济学称为一门科学，获得了研究对象。</p>\n<h2 id=\"劳动价值论\"><a href=\"#劳动价值论\" class=\"headerlink\" title=\"劳动价值论\"></a><strong>劳动价值论</strong></h2><p>劳动：一般劳动：凡是能使货币增殖的活动都是劳动，所以理发师的劳动也是劳动，创造的是商品价值。</p>\n<p>价值：商品的交换价值（不是使用价值）</p>\n<p>这样完成了一件事：把具体劳动的感性特征抽象掉，只说社会必要劳动时间的量，这个量的体现就是货币。货币因此也成为财富主体，而不是一般等价物。</p>\n<p>不同的劳动能够被等量齐观</p>\n<p>货币增殖：劳动的量增加，这个劳动量增加是在生产领域增加，不可能在流通领域。</p>\n<p>具体劳动受抽象劳动支配，如果具体劳动不能给资本带来增殖，那他就不算劳动。所以研究哲学不算是劳动。</p>\n<p>经济学取代了记账学，一个家庭内一定要计算一月内的收入与支出情况，即直接计算使用价值，并设法保住这个使用价值。</p>\n<p>但今天不能丢掉记账，经济学，是通过市场，让通过劳动创造的剩余劳动卖成剩余价值，货币增殖，获得在市场上的购买力。万一市场断了呢？</p>\n<p>发达资本主义国家也要考虑这些使用价值。一旦危机要保持必要的粮食储备。</p>\n<p>如果整个社会的电网都崩溃了，蜡烛就重要了。人还是要站在大地上的。年轻的钱不能花完，必须储蓄。假如货币没有脱离金本位，钱始终是那些钱，购买力始终是可靠的。</p>\n<p>资本主义发展到现在完全脱离大地，稍微有点钱的老人是最惨的，整天担惊受怕自己的财富缩水。</p>\n<p><strong>资本的本质：抽象劳动统治具体劳动，交换价值的增殖支配使用价值的生产。</strong></p>\n<p>这是近代以来的唯心主义</p>\n<p>但财富作为使用价值的数量来计算这件事是不能被遗忘的</p>\n<p>金融危机会在几个月内将十年经济发展毁于一旦，90年代金融危机，韩国老百姓将黄金上交国家，短时间内恢复韩币的金本位制，稳住韩币</p>\n<p>因此<strong>金银不是天然的货币，但货币天然是金银</strong>。</p>\n<p>金银只是矿产，<strong>货币是一般等价物，是流通的，但如果要把财富用货币来表示，应该在自然界寻找一种储备有限，质地均匀，便于分割携带的东西。——只能是金银</strong></p>\n<p>G - W - G’</p>\n<h2 id=\"资本与技术是孪生兄弟\"><a href=\"#资本与技术是孪生兄弟\" class=\"headerlink\" title=\"资本与技术是孪生兄弟\"></a>资本与技术是孪生兄弟</h2><p>G是生产资料的价值和劳动力（工资），开始劳动过程，即劳动时间，产生新产品，如果原材料的价值完全转移到了新产品上，产生的多出来的价值完全等于工资，那么资本家变成了义务劳动。</p>\n<p>马克思用<strong>剥削这个词没有任何道德贬义</strong>。以往的农奴劳动是等级强制，现在的剥削是正义的。</p>\n<p><strong>资本家是资本的人格化，经营企业的行为是服从资本的逻辑的，与其道德品质无关。</strong></p>\n<p>资本家没有奴役任何人，只是<strong>按照资本的法则，必须要将劳动分为必要劳动和剩余劳动。</strong></p>\n<p>市场是一个竞争的舞台，产品要么便宜，要么质量好。这迫使资本家降低成本，第一种方法是延长工时，但无法无限延长，因为要吃饭睡觉，12小时最多了，第二种是减少必要劳动的时间，即提高生产效率，第一种是劳动者更熟练，第二种是新技术。</p>\n<p>围绕相对剩余价值，展开了技术比拼。</p>\n<p>中国是第一制造业大国，因为量大，不是质量。这是中低端制造业，高端是技术。<strong>高端能够获得品牌的地位，有品牌就有市场。</strong></p>\n<p>相对剩余价值的开发，只能依赖新技术的研发，这能够带来两个好处，第一个是提高产品质量与效率，第二个是创造新的使用价值（iPad这种新产品就是新的使用价值）</p>\n<p>美国特别强调产权，是因为其实体制造业很少了，但三亿人口的老百姓并不都在硅谷，实体制造业衰落造成大量的失业人员。所以特朗普号召制造业回归本土。</p>\n<p><strong>资本主义的生产一定带来技术的进步</strong>，在此之前人们没有技术，只有技艺。<strong>技术将自然抽象化看作资料material的世界，技艺则是追求天人合一</strong>。把劳动抽象化必然也会把自然界抽象化。资本与技术是孪生兄弟，中国的土壤既无法产生资本主义，也无法产生对自然界的技术的态度。</p>\n<p>马克思的<strong>生产力决定生产关系</strong>：不是说生产工具的进步带来新的生产关系。从行会手工业到工厂手工业，生产工具没变，生产关系变了，行会中是师徒，工厂中是资本主义生产关系，要求相对剩余价值。这种资本主义生产关系产生后，机器在逻辑上被发明了，经验上还没诞生。</p>\n<p>如果没有资本主义的生产关系，瓦特发明的蒸汽机只是一个宫廷里的玩具</p>\n<p>所以鲁迅说，中国的四大发明不是生产力</p>\n<p>所以资本与技术是孪生兄弟</p>\n<p><strong>没有技术，资本无法竞争，没有资本，技术无法被要求</strong></p>\n<p>资本在根本上改变了人们的生活方式，这个改变的指向就是效率——时间就是金钱，效率就是生命</p>\n<p>技术运用到农业生产，改变靠天吃饭；运用到医疗，延长生命；运用到电声转换，将古典音乐收入到口袋中。这是积极的方面，不能被否认也无法被忽视。</p>\n<p>核能是不能运用的，因为人是会犯错误的动物。<strong>新能源的运用是要靠旧能源</strong>，资本主义不断要求效率，效率就不断要求高效的能源</p>\n<h2 id=\"资本主义内在界限：\"><a href=\"#资本主义内在界限：\" class=\"headerlink\" title=\"资本主义内在界限：\"></a><strong>资本主义内在界限</strong>：</h2><p>资本主义生产方式没有外在界限，它要求突破一切民族、疆域、文化</p>\n<p>但它有内在界限，即<strong>资本主义的每一次发展，都会同时产生限制自己的力量</strong></p>\n<ol>\n<li><p><strong>必要劳动是活劳动的交换价值的界限</strong>（必要劳动是等于工资的那部分劳动，所以剩余劳动是必须的。劳动力是商品，也就有交换价值）：技术运用后，必要劳动比例减少，但劳动者的工资不会变多。如果必要劳动的比例进一步减少，就会发生裁员。产品需要卖给大比例的人口即劳动者，但劳动者购买力没有提高。资本家的矛盾心理：员工在企业内部工资一直不变，但当员工一出企业，又希望他们有旺盛的购买力。这是资本主义无法克服的悖论西方国家通过二次分配——社会福利解决，这与资本主义无关，让劳动者敢于花钱，能保证最基本的保障。</p>\n</li>\n<li><p><strong>剩余价值是剩余劳动和生产力发展的界限</strong>：剩余劳动是一直都有的，它是过去积累起来的劳动物化为使用价值。到了资本主义时，剩余劳动不能停留在实物形态，它必须要在市场中转换为剩余价值，实现货币的增殖。否则就破产。所以出现倒牛奶。因此<strong>过剩的绝不是剩余劳动</strong>，<strong>过剩的是这部分剩余劳动无法在市场竞争中实现剩余价值。</strong> 唯一的做法就是毁掉，重启市场需求。要么自然灾害，要么发动战争。资本主义一方面极大促进了生产，积累剩余劳动，但又在随时准备破坏这些积累起来的劳动。 相对过剩发生，产业链资金链都受影响，容易连锁反应发生经济危机。日本侵略也是在这个背景下，发展新市场，瓜分殖民地。而美国当时则是选择另一种方法，突破资本主义的第三个界限（见下）</p>\n</li>\n<li><p><strong>货币是生产的界限</strong>： 生产目标是货币增殖，资本主义投入开始就是货币，整个过程都以货币作为媒介。产业链从上游一直到下游末端直接面对消费者，如果钱回不去，资金链就断了，只能印钞票。这样货币天然是金银的原则就被破坏了，因为你没法印金子。美国罗斯福国家干预经济，超发货币，低息贷款，启动资本主义生产第一个阶段。让货币与黄金脱钩。救济企业，应对就业危机，工人就业有了钱，又回去消费，将剩余劳动转化为剩余价值，解决过剩危机。内部危机只有两个手段：超发货币与国家投资。最终走入资本主义最终形态，金融资本主义。金融4个方面，银行，证券，保险，基金。</p>\n<p>马克思谈金融：生息资本：金融是资本市场，资本市场是资本成为商品进行买卖。资本作为商品，即资本产生利润的能力被买卖了，产生的利润是资本作为商品的使用价值，产生利润的能力是资本作为商品的价值。这个产生利润能力的价值如何确认？资本之所以表现为商品，是因为利润被分割为利息和本来意义上的利润，是由供求，从而由竞争来调节的。供求平衡，价格与价值相等，工资就是一种价格，因为工资是波动的。资本作为商品被买卖时，便有价格，价格就是利息；而使用价值就是生产利润的能力，那这个能力有没有价值中心线，也就是说有没有价值？资本生利能力的价值是多少？这里的竞争不是对价值规律的偏离，而是除了由竞争强加的分割规律之外，不存在别的分割规律，并不存在自然利息率，利率没有自然界限。所以这个商品，只有价格，没有价值。金融危机的可怕之处也在于此，它没有价值中心线。所以资本只是表现为商品而不是商品。为什么不具有自然属性，一是使用价值无法确定，只能用最近的过去作为不远的将来的近似，二是供求关系也就是货币供应量不确定。</p>\n</li>\n</ol>\n<p>生产是以货币作为价值和财富，货币贬值后经济就垮了。但中国人厉害的一点在于，如果生产和消费的一系列过程垮掉，那么可以直接让生产和消费在地摊上见面。资本不行了，就走合作化的道路。</p>\n<ol start=\"4\">\n<li><strong>使用价值的生产受交换价值的限制</strong>。如果某种生产价值带不来剩余价值，那么这种使用价值将不被生产。但他可以改头换面，带来新的剩余价值。</li>\n</ol>\n<p>这是资本主义自己发展的同时，也在积累否定自己的力量。</p>\n<p>其带来的文明的果实不会消失，但不能用产生的方式来保存这种果实。</p>\n<p>马上得天下，但是治天下要下马</p>\n<p><strong>资本主义的消亡不是从外部被否定的，而是从内部。</strong></p>\n<p>中国以自己特色的方式取得了巨大的经济成就，但过去几十年获得的方式不是保存的方式。三十年为一世，而道更。1919的反帝反封建，到49年新中国成立，再到79年的改革开放，如今赢得总量第二，一个靠资本，一个靠技术，缺的是这两个，多的是廉价劳动力与自然资源。</p>\n<p>资本主义还有一段路要走，我们要用自己的路走。</p>\n","categories":["IDEA"],"tags":["人文情怀","资本论","王德峰"]},{"title":"NieR-Automata通关感言","url":"/post/b988b94d.html","content":"<p>尼尔一场大梦，人生几度秋凉</p>\n<span id=\"more\"></span>\n\n<p>没想到最后还是哭了</p>\n<h2 id=\"一段人生，一次经历\"><a href=\"#一段人生，一次经历\" class=\"headerlink\" title=\"一段人生，一次经历\"></a>一段人生，一次经历</h2><p>尼尔里面有什么</p>\n<p>有机械，有主角</p>\n<p>有战斗，有音乐</p>\n<p>有喜悦，有痛苦</p>\n<p>有虚拟，有现实</p>\n<p>有游戏，有人生</p>\n<h2 id=\"从头到尾的虚拟\"><a href=\"#从头到尾的虚拟\" class=\"headerlink\" title=\"从头到尾的虚拟\"></a>从头到尾的虚拟</h2><p>一切的一切都是假的</p>\n<p>甚至包括你的名字</p>\n<p>只是为了服务于某个更高阶层</p>\n<p>服务于更为宏大的目标</p>\n<p>服务于从头到尾都是虚假的人类荣耀永存</p>\n<p>战斗员戴着眼罩</p>\n<p>通讯官戴着口罩</p>\n<p>行凶者不知真相，知真相者口不能言</p>\n<p>没有谁能够毫无理由就去战斗，我们需要能够为之奉献的神</p>\n<p>——尼尔-机械纪元</p>\n<h2 id=\"机械的感情\"><a href=\"#机械的感情\" class=\"headerlink\" title=\"机械的感情\"></a>机械的感情</h2><p>为了毫不留情地将所有的机械消灭，只能不断灌输机械没有感情，寄叶部队也相信着它。</p>\n<p>然而无休止唱歌的歌姬</p>\n<p>亚当与夏娃</p>\n<p>帕斯卡的村庄</p>\n<p>因恐惧自杀的孩童</p>\n<p>抵抗军的军营</p>\n<p>森林里的王</p>\n<p>迪瓦拉和波波拉</p>\n<p>甚至包括2B，9S，A2他们自身</p>\n<p>以及辅助机</p>\n<p>都在演绎着人类的情感</p>\n<p>开心难过痛苦绝望</p>\n<p>分离的不舍，重聚的欢欣</p>\n<p>全作无一个人类</p>\n<p>却处处是人类</p>\n<p>自以为能够拯救世界，可到头来终究是一场空</p>\n<p>数据被删除后，往事皆随风，又是一次轮回的开始</p>\n<h2 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h2><p>不知道最后的E结局是不是封神之作</p>\n<p>但确确实实感动到了我</p>\n<p>最终打所有制作人员的操作别出心裁，或许是想让玩家泄愤</p>\n<p>然而打是打不过的</p>\n<p>每一次死亡，都会被问道：</p>\n<p><strong>“你承认自己已经战败了吗”</strong></p>\n<p><strong>“这一切都是白费力气吗”</strong></p>\n<p><strong>“你认为区区游戏实在很愚蠢吗”</strong></p>\n<p><strong>“你承认这个世界没有意义吗”</strong></p>\n<p><strong>“要在此放弃吗”</strong></p>\n<p><strong>“要接受救援吗”</strong></p>\n<p>看来我一共死了六次，第六次来了救援</p>\n <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fca9875f1-5bbf-4e12-a69c-d818bb59d52b%2FUntitled.jpeg?table=block&id=50f9441c-1615-4dab-bc63-ef4611b6b888\" style=\"zoom: 50%;\" />\n\n<p>然后弹药突然变多</p>\n<p>但是每死一个，都会提示xx的数据丢失了</p>\n<p>总之火力猛了果然还是过了</p>\n<p> <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdbfcebc7-62a1-4de7-956e-9e7caf1e66d2%2FUntitled.jpeg?table=block&id=a029abb2-314a-4863-868b-6e4e1b192a9c\"></p>\n<p>这时候辅助机发问：</p>\n<p>你有什么话要说</p>\n<p>看到这个格式，我才明白</p>\n<p>之前的每一条留言</p>\n<p>都是一位玩家贡献出来的</p>\n<p>你打不打算拯救弱者？</p>\n<p>只要选择这个选项，你就能拯救世界上的某人</p>\n<p>代价是失去所有的保存资料</p>\n<p>即便如此。你仍愿意拯救某个素不相识的人吗？</p>\n<p>（看到这里我才知道原来之前的每个帮助我的人都放弃了自己几十个小时的游戏存档）</p>\n<p>拯救的对象随机选择</p>\n<p>所以</p>\n<p>向你求救的对象</p>\n<p>可能是你讨厌的人</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>你拼命才解锁的选择章节功能（我甚至还没有体验过）</p>\n<p>也会无法使用</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>即使你拯救他人，或许也不会被感谢</p>\n<p>你的行为可能会被视为伪善</p>\n<p>即使如此，你仍愿意拯救他人吗？</p>\n<p>真的，真的要继续吗</p>\n<p>以所有数据当作代价</p>\n<p>我会把你的意思告诉这个世界</p>\n<p> <img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F4c9c919c-2512-4f19-9610-57cc29be1868%2F20220810151300_1.jpg?table=block&id=c903fa57-9803-4f21-bddb-3a3cd8a460da\"></p>\n<h2 id=\"活着的意义\"><a href=\"#活着的意义\" class=\"headerlink\" title=\"活着的意义\"></a>活着的意义</h2><p>开始的一段话结尾：</p>\n<p>他们被设计成能毁灭一切的存在</p>\n<p>在生与死的螺旋中</p>\n<p>他们一直被囚禁着</p>\n<p>但是</p>\n<p>在那些轮回中的挣扎</p>\n<p>便是活着的意义</p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3ce249f3-6a1e-4eff-887c-3c932ec8844d%2F20220810151425_1.jpg?table=block&id=d3c9e4df-31c0-4d4d-8ea5-109299a7ff8c\"></p>\n<p><code>A2&amp;2B&amp;9s</code></p>\n<p><code>All(A2) is gonna to be(2B) nice(9S)</code></p>\n<h2 id=\"几张美图\"><a href=\"#几张美图\" class=\"headerlink\" title=\"几张美图\"></a>几张美图</h2><p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fabb6b423-46e6-4a0d-9dde-2d5a5b4e6724%2F20220417174024_1.jpg?table=block&id=d6fbe8a5-0a26-486b-b4d9-9a171295baa6\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F72c4a688-9df6-4663-8697-e30faba01022%2F20220421154328_1.jpg?table=block&id=59d64fe3-4c2d-429c-bb20-8b0420aead4d\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F8a5f17c8-eb72-4d4e-a9cf-7e91abf9d325%2F20220421165918_1.jpg?table=block&id=ae4ab0a5-54fa-443b-93e5-fb4340f188c7\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F5351dd02-d256-4934-af5c-1b4497090693%2F20220423134020_1.jpg?table=block&id=96903f94-2b51-474d-92d7-d4676d95b8ce\"></p>\n<p><img src=\"https://pengpeng73.notion.site/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F28c12106-2187-4c17-be9b-38c9393593ce%2F20220423134122_1.jpg?table=block&id=b222c905-0004-4685-b5d9-1c09a40cd4c6\"></p>\n","categories":["Game"],"tags":["Game","NieR"]},{"title":"观后感-女佣浮生录","url":"/post/f0069d9c.html","content":"<p><strong>Each kind of situation has its own solution.</strong> </p>\n<p><strong>You would never lose hope as long as you insist.</strong></p>\n<span id=\"more\"></span>\n\n<p>Inspired by <a href=\"https://en.wikipedia.org/wiki/Stephanie_Land\">Stephanie Land</a>‘s memoir <em>Maid: Hard Work, Low Pay, and a Mother’s Will to Survive.</em>  It just shocked me.</p>\n<p>What A Helpless Situation!</p>\n<p>A single mother —-</p>\n<p>She has a alcoholic husband, a mother with mental problems, a three year old daughter and a abusive boyfriend.</p>\n<p>Her life is just like a mess.</p>\n<p>What makes me sad the most is that she could have gone to college and she had won a scholarship.</p>\n<p>But just because of a man and an unexpected baby, she gave up that opportunity.</p>\n<p>  In my initial and traditional perspective, a girl is a child or a princess spoiled by her parents, at least before she enters the society and start working. But in the play, the woman could be considered to be shamed and failed. People would be shamed by her behavior and tell their children not to be like her.</p>\n<p>​\tAnd this woman and this TV series totally changed my pervious thoughts. You can always make  it through as long as there is hope in your mind and there are some kind people who are willing to help you.</p>\n<p>​\tShe accepted help from lots of people. That’s coincidence, but also for her character, she is diligent, sticks to her principles even live in other’s home, she keep in mind that she is accepting other’s help or charity. Her love for daughter impressed many persons. </p>\n<p>​\tAt the beginning I think she could been had a better life, go to the college, hang out with her friends, meet a romantic love, find a decent job. She could do so many things that belongs to youth. Just due to the man and a baby, her life is ruined. But when she said: “Daughter is my life. “ I suddenly understood that she is happy and passionate for life just because of her daughter which is her whole world. I also understood mother’s power which should be respected by everyone.</p>\n<p>​\tWhen she got the scholarship again, she felt hope for the future. But her ex-boyfriend returned her car to another man and that means she can’t go to work, she can’t make money, so she also can’t go to college. Suddenly she lost all her hope and fell into despair. I was  very worried for her at that time. And eventually, she resumed her spirit and made it through again due to her cute daughter, she took her daughter away, away that house full of alcohol and violence. She took her daughter run out of the cage which is in her mind. She showed me how powerful she is again, not only as a woman, but also as a mother.</p>\n<p>​\tIn the end, when she drove to Montana with her daughter, drove to her future full of hope,   that plot hit my heart.</p>\n<p>​\tShe said: “I’m going to drive the fuck out of the town, I’m going to drive nine hours, 566 miles to Missoula, Montana, where I’m going to spend the next four years, learning to be a writer. Hopefully, there will be a lot of happy days during that time. And I know there will be hard ones. Most people would bet against a single mom putting herself through college. But they don’t know what it took to get here. Three hundred and thirty-eight toilets cleaned, seven types of government assistance, nine separate moves, one night on the ferry-station floor, and the entire third year of my daughter’s life. But, when we got to Missoula, I’m going to take Maddy(her daughter) up Sentinel Mountain, which looks over the town, and show her new home. I’ve been telling her all about the giant ‘M’ that’s at the tippy-top of the mountain. That the trail up there is long and zig-zaggy. The hike will be hard. But we’ll make it to the top. And when we do, I’m going to tell her that the <em>‘M’ stands for ‘Maddy’.</em> That this is whole new world for her “</p>\n<p>end</p>\n","categories":["观影"],"tags":["电视剧","观后感","女性","美剧"]},{"title":"观后感-明日、我会成为谁的女友","url":"/post/663a0935.html","content":"<p>现在，在这个东京，仅是一个人想要生存下去，就需要很大的开销了，无论是优越的环境，还是强大的意志，要是缺少其中一样，就会连普通的生活都无法维持下去，这就是现实。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h2><p>在这个充满束缚的世界里，为了尽可能活着，活下去，我要用自己的脚一步一步走下去。所以，今天，我也会是某人的女友。</p>\n<p>彼时的东京，恰如此时的xx，都是一个这样的地方：<strong>金钱流通无息稍停，欲望增长尽日奔驰</strong>。</p>\n<p>之前看过一本关于东京女性纪实的书，大体上有这样的概念，即很多在东京的女性，尤其以年轻女性为主，都在try theirs’s best to make ends meet. 在这种情况下，不能完全说风俗店或者出租女友的服务完全不合理，它终究是有个原因，是一整个社会共同造成的。在这样的情况下，女性究竟是何种命运，是什么造就了这种情况，它将如何发展下去，似乎要再次回到更加广阔的历史生物与哲学背景中。</p>\n<p>但我自然没有如此之水平，再加上我是男性的身份，就决定了我既是法官，又是当事人，也就难以客观，值得怀疑。</p>\n<p>但值得瞩目的事情在于讨论区的女性朋友们大多将重点放在了感情线与杀猪盘上，并未想要去考虑在背后与整个日本经济社会政治方面的联想，我也无法有效联想，因为知识太浅，但个人确实比较喜欢这种讲两性的剧并作出联想。</p>\n<h2 id=\"情节\"><a href=\"#情节\" class=\"headerlink\" title=\"情节\"></a>情节</h2><p>对于整体的分析比较困难，还是拿几个情节来讲吧。</p>\n<h3 id=\"雪\"><a href=\"#雪\" class=\"headerlink\" title=\"雪\"></a>雪</h3><p>第一个在于不同人对于小雪伤疤的态度，几乎所有人都带有略带怜悯的眼光去同情她，但实际上可能这种人最希望追求的是normal，不是别人特殊的眼光，特殊的照顾，而是正常看待的眼光。这种情况下，一直坚持整容变美的彩反而作出了雪最想要的反应：正常看待，觉得有问题就解决，解决时候还要注意很多东西。而另两个，一个爱情一个友情，都没有作出这种选择，而是投以怜悯的目光，或许也是身未受故感不同吧。之前觉得彩执着于整容有些过头，然而却也是自己的选择，这种情况下，你很难去以一件事情就去对一个人作出自己对他的盖棺定论，事情不断变化，人也在不断发展，我们的认识也要不断变化，这才是实事求是。</p>\n<p>在剧中最理性的好像是雪，没有不良嗜好，行为也都有界限。所有的一切都是为了生活本身，而且对于未来也有一个比较清晰的规划。不得不说其原生家庭也不容易，<strong>并不是生了孩子就能变成母亲</strong>。</p>\n<h3 id=\"萌\"><a href=\"#萌\" class=\"headerlink\" title=\"萌\"></a>萌</h3><p>第二个是沉沦的萌，她的沉沦与前面对爱情的冷漠表面矛盾对立，然则好像一体两面一样，是完全统一的。就好像弹簧一般，前期由于自己外貌与身材，加上身边人的评价，她也只能无奈接受这种设定，暂时把对于一些东西的渴望隐藏起来，但它们并没有消失。当一旦遇到某一个愿意正常待他时，她的反应只会更加剧烈，其热烈程度反而会让自己深度沉迷，最终导致受伤。正如其心中所想：“大家都在看着我，这用金钱编织的关系，这充满谎言的世界，但是，在这个世界中，我像主人公一样。”幸好最后即时发现止损。</p>\n<p>一开始萌与枫之间就只是顾客与服务者的关系，因为有这样的一个恶性循环：萌想要多见枫，但她好像只能通过投入大量金钱与其他女性竞争来达到与枫的短暂见面机会，这样的金钱又迫使着萌去发展其他业务，使自己更加空虚后，又会继续到枫身上寻找依赖与慰藉。然而如果两个人真的情投意合好似天公作美的一对，那么第一步只能通过金钱的途径就会无效，枫自然会不断找时间与萌见面，恶性循环也就无从谈起。</p>\n<p>一开始好像都很清醒，都知道只是逢场作戏，然而人心不足蛇吞象，欲望会不断增长的。见一面后就想着见两面，散步一小时后就想着吃饭两小时，最后所有的时间都换算成了高昂的价钱。</p>\n<h2 id=\"劳动、产业、起源\"><a href=\"#劳动、产业、起源\" class=\"headerlink\" title=\"劳动、产业、起源\"></a>劳动、产业、起源</h2><p>剧中的五个人的共同点在于都选择了以自己的身体作为生产资料去进行售卖身体的活劳动，一定程度上是女性占比多一些。牛郎也有，但我潜在意识中还是会觉得女性多一些，因为产业发达程度与受众数量也就是用户多少有关。在这种情况下，当女性是为了一些目标去从事这种活动时，或者只是为了make ends meet，并不会去觉得有什么不妥。因为她们也是劳动者，比起某些利用权力去为虎作伥的人来说好太多了。但这种劳动的可怕之处，在于它的易沉迷性。不管思想上多么受折磨，这样如此的高薪仍然是少有的领域，即使是互联网也难以抗衡（对于普遍人来说）（当然这里的高薪我们必须要提到关于色情行业的产业升级，无论什么行业产业链的下游都是困难的，高薪是说那些在新时代中改变营业方式吸取客人的店）在这样的高薪后面，即使有相对难缠的客人，但拿到手里的货币的重量仍然不容小觑。所以我想说的论点在于：投入产出比很高。正如那句话所说，拼命的努力是为了让成功到来时能够心安理得。与之意思相近的一点是权力要与胸怀匹配，否则会给自己和下属都带来灾难。</p>\n<p>同样的，这种行业也会带来这样的不平衡。而且这样的劳动基本完全脱离成果。来钱过快过容易必然导致跨过思想层面的门槛变得极度容易，后续也会轻而易举地进入正反馈中：赚钱-&gt;大手花钱+因劳动脱离成果产生空虚-&gt;继续花钱-&gt;钱不够-&gt;继续赚钱。</p>\n<p>劳动脱离成果后，因为没有成果的反馈，消费便十分容易地脱离掉需要，只能通过大手的花钱来证明自己的价值，不断强化自己有价值的观点，等到习惯了大手花钱后，也就只能与快速赚钱的行业相绑定了。</p>\n<p>此时又不得不搬出那句话了：“男人的极大幸运在于，他，不论在成年还是在小时候，必须踏上一条极为艰苦的道路，不过这又是一条最可靠的道路；女人的不幸则在于被几乎不可抗拒的诱惑包围着；每一种事物都在诱使她走容易走的道路；她不是被要求奋发向上，走自己的路，而是听说只要滑下去，就可以到达极乐的天堂。当她发觉自己被海市蜃楼愚弄时，已经为时太晚，她的力量在失败的冒险中已被耗尽。”</p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>然而不得不提的一点在于，这并不是相当一部分女性的初心，这种情况下，很多问题都可以通过稳健到位的社会保障机制，及时高效合理的司法，有职业道德的教育工作者这三样东西去解决。日本高昂的大学贷款逼着年轻女性拼命地用尽一切方法维持生计，这并不是这部分女性的错。</p>\n<p>这是谁的错呢？</p>\n<p>或者更重要的一点，如何解决呢？</p>\n<p>I don’t know both.</p>\n","categories":["观影"],"tags":["电视剧","日剧","观后感","女性"]},{"title":"观后感-阿尔卑斯山求生记","url":"/post/13a30ca8.html","content":"<h2 id=\"生命史诗与自然之魂！\"><a href=\"#生命史诗与自然之魂！\" class=\"headerlink\" title=\"生命史诗与自然之魂！\"></a>生命史诗与自然之魂！</h2><hr>\n<h3 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h3><p><strong>天地有大美而不言</strong></p>\n<p><strong>四时有明法而不议</strong></p>\n<p><strong>万物有成理而不说</strong></p>\n<p>人类会犯错，自然不会犯错 </p>\n<p>被震撼的一次观影</p>\n<hr>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>头狼为了自己的威信，向熊发起挑战</p>\n<p>虽然最后伤病而死，但他难道输了吗？</p>\n<p>若是，那么对于生命的赢又是什么？</p>\n<p>动物也并非没有愿意用生命去捍卫的东西</p>\n<p>雌性头狼离开狼群陪伴伴侣，谁说殉情只是古老的传说？</p>\n<p>原有的狼群迅速选择新首领，谁又能说他们错了？</p>\n<p>没有首领必然意味着群体的灭亡</p>\n<p>自然不会错，只是我们难以理解</p>\n<p>雌性头狼最终离开已经死去的头狼，是不敢殉情吗？</p>\n<p>——她还怀着孩子</p>\n<p>有时候生，并非意味着幸福</p>\n<p>六甲之躯，跨越群山</p>\n<p>共计公里万余三</p>\n<p>只身孤影，克服万难</p>\n<p>没有丰富的面部表情，不意味着没有感情</p>\n<p>没有语言，不意味着没有想法</p>\n<p>在如此情况下，六只狼崽全部存活</p>\n<p>母性伟大之光辉震烁千古！</p>\n<p>我又想起了那些把孩子生在厕所里的母亲</p>\n<p>有时候精神的高尚</p>\n<p><strong>不会随着直立行走而更加高大</strong></p>\n<p><strong>亦不会随着身姿的匍匐而变得卑微</strong></p>\n<p>刚生下狼崽，碰见猞猁</p>\n<p>有些讨厌，人家刚生下孩子，你对人家幼崽虎视眈眈</p>\n<p>就不能找点别的吃的吗</p>\n<p>后来</p>\n<p>原来她也是母亲</p>\n<p>愚昧如我</p>\n<p>自然没有对错，亦无好坏</p>\n<p>走投无路的狼妈妈，将眼光看向了羊群 </p>\n<p>若是生活没有如此艰难，谁愿意铤而走险？？</p>\n<p>可生活就是这样，自前世而固然</p>\n<p>高山环境恶劣 </p>\n<p>导致残酷的竞争</p>\n<p>可是却也恰恰因为恶劣的环境</p>\n<p>合作显得尤为重要</p>\n<p>视频结尾有一段话结束</p>\n<h3 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h3><p>在最艰难的条件下，能够生存下来的不是最强者，而是互相帮助的个体</p>\n<p>环境越恶劣，团结协作的重要性就越发凸显</p>\n<p>这就是我们从阿尔卑斯山的生物上学到的品质</p>\n<p>在这里生活，他们都知道这一点：</p>\n<p>雌性羱羊守望相助，一起照顾后代</p>\n<p>鸟类聚集一起寻找食物</p>\n<p>鹿紧紧挤在一起取暖</p>\n<p>树木为老祖宗提供养分</p>\n<p>狼为了守护族群不惜牺牲一切</p>\n<p>瑞士松依靠星鸦把种子洒满山野</p>\n<p>狼需要克服无数挑战才能与其他狼和平共处</p>\n<p>人类需要依靠驯养的犬来守卫家畜</p>\n<p>所有生物都知道自己不是最强大的</p>\n<p>大山本身都比他们强大的多</p>\n<p>所以他们才会这样相互依存</p>\n<p>或许这就是自然吧：</p>\n<p>它的魅力让我抓心挠肝，</p>\n<p>它的美丽让我惊心动魄，</p>\n<p>它的威严让我顶礼膜拜，</p>\n<p>它的慈祥让我泪水常噙。</p>\n<p>自然不会错</p>\n","categories":["观影"],"tags":["观后感","纪录片"]},{"title":"java 学习笔记","url":"/post/eef4f581.html","content":"<p>持续更新。。。</p>\n<span id=\"more\"></span>\n\n<ul>\n<li><p>Java中只有两种类型：基本类型和引用类型。引用类型引用对象（reference to object），而基本类型直接包含值（directly contain value）。所有类的&#x3D;都是引用，所以会互相影响。</p>\n</li>\n<li><p>Java中字符串是不可变的，都是通过引用去操作对象实例</p>\n</li>\n<li><p>数组为定长，不能增减</p>\n</li>\n<li><p>Java是面向对象的语言，Java的类把方法与数据连接在一起，构成了自包含式的处理单元。为了将基本类型也能当作对象去处理，Java为每个基本类型都提供了包装类，从而当作对象处理。</p>\n</li>\n<li><p>equal的默认方法是使用“&#x3D;&#x3D;”运算符去比较两个对象的引用地址，而不是去比较内容。如果想要对于自定义的类也去使用equal，那么需要重写该方法，从而比较内容。</p>\n</li>\n<li><p>向上转型，即子类对象赋值给引用父类的变量。背后思想在于“平行四边形也是一种四边形”，所以很自然地可以将平行四边形看作是一种四边形。这是从具体类到抽象类的转换，所以总是安全的。这也是多态机制的基本思想，也是工厂模式的基础。而在向下转型时，是将具体类赋值给一个引用抽象类的变量，会出问题，我们必须通过显式类型转换，告诉编译器，这个抽象类也是一个具体类，才不会出错（感觉就像是把父类没有的成员变量与方法声明了一下）</p>\n</li>\n<li><p>Java 的关键字都是小写，比如instanceof，能够检测一个对象到底是不是一个类的实例。</p>\n</li>\n<li><p>一切都是对象，为了得到某个对象，我们需要一个 key，通常这是reference。</p>\n</li>\n<li><p>增强型for循环，只能读，不能改，因为每次得到的元素都是一份copy</p>\n</li>\n<li><p>可预测型字符串，推荐用string builder</p>\n</li>\n<li><p>signature &#x3D; function name + params</p>\n</li>\n<li><p>Java一直都是pass by value</p>\n</li>\n<li><p>模糊参数，用int…，本质是一个array</p>\n</li>\n<li><p>在多态中，继承抽象类的所有子类需要重写父类的抽象方法。但是同样会有冗余代码。比如某个子类可能不需要这个抽象方法，但是又不得不重写。如果将不需要的分出一个抽象类，又会出现多继承。于是有了接口的概念。哪个类需要这个方法，哪个类就去实现这个接口。同时注意在接口中定义的任何字段默认都是static和final的。</p>\n</li>\n<li><p>向上转型为抽象接口也可，不仅是抽象类</p>\n</li>\n<li><p>Java不允许多重继承，但是使用接口就可以实现多重继承</p>\n</li>\n<li><p>被声明为final的对象引用只能指向唯一一个对象，不能指向其他的对象。但由于一个对象本身的值是可变的，因此真正不可变，可以用<code>static final</code>，通过static，在内存中开辟恒定内存，保持不变。</p>\n</li>\n<li><p>Java中的全局常量，通常都是<code>public static final</code></p>\n</li>\n<li><p>定义为final的方法是不能被重写的。</p>\n</li>\n<li><p>内部类的实例必须要绑定在外部类的<strong>实例</strong>（注意不是外部类）上，内部类可以用外部类的东西，外部类<strong>不能</strong>用内部类的东西。</p>\n</li>\n<li><p>由于Java是面向对象的语言，所以在Java中异常也是以类的实例的形式出现的。</p>\n</li>\n<li><p>try结构发生异常后，直接执行catch的语句与之后的，try中异常语句后的不再执行。</p>\n</li>\n<li><p>在抛出异常的方法中处理异常，可以直接使用try-catch结构，而在方法的声明处写出throws结构，并给出要抛出的异常，是要把异常抛给方法调用者。然后在方法的调用处，因为可能会有异常，还是要有一个try-catch</p>\n</li>\n<li><p>throws是在方法声明处，可声明多个，可以一层一层向上抛出，但是始终要有处理的；</p>\n</li>\n<li><p>throw是在方法体内，执行到throw立刻停止，如果方法体内抛异常，则需要在声明里写出throws，之后再调用者处理。</p>\n</li>\n<li><p>所以写了throw就必须要写throws，但是写了throws可以不写throw。</p>\n</li>\n<li><p>一个try可以跟多个catch，对应不同的异常。</p>\n</li>\n<li><p>使用List集合时候通常声明为List类型，然后通过不同的实现类来实例化该集合。</p>\n</li>\n<li><p>Java反射可以在程序中访问已经装载到JVM中的Java对象的描述</p>\n</li>\n<li><p>Methods called from constructors should generally be declared final. 如果子类有重载A，并且A在父类构造函数中被调用，那么会调用子类的重写版函数，但是子类在此时尚未被实例化。所以在构造函数中调用的，需要被定义成final（推荐），是为了子类不会重写，将来调用的时候出现多态。</p>\n</li>\n<li><p>If a subclass defines a static method with the same signature as a static method in the superclass, then the method in the subclass <em>hides</em> the one in the superclass.</p>\n<p>The distinction between hiding a static method and overriding an instance method has important implications:</p>\n<ul>\n<li>The version of the overridden instance method that gets invoked is the one in the subclass.</li>\n<li>The version of the hidden static method that gets invoked depends on whether it is invoked from the superclass or the subclass.</li>\n</ul>\n</li>\n<li><p>Methods called from constructors should generally be declared final.（引入如果调用一个普通函数，然后这个函数在子类中被重写了，那么子类在实例化时，由于多态，在父类中就会调用子类重写的函数，但是此时子类还没有被实例化出来，容易出问题）</p>\n</li>\n<li><p>抽象类和接口：</p>\n<ul>\n<li>抽象类：<ul>\n<li>want to share code among several closely related classes</li>\n<li>expect that classes extending the abstract class have many common methods or fields, or require access modifiers other than public</li>\n<li>want to declare non-static or non-final fields</li>\n</ul>\n</li>\n<li>接口<ul>\n<li>unrelated classes would implement your interface</li>\n<li>want to specify the behavior of a particular data type, but not concerned about who implements its behavior</li>\n<li>multiple inheritance</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["Geek"],"tags":["Developer","技术","Java"]},{"title":"override v.s. overload v.s. overwrite","url":"/post/9e1da285.html","content":"<p>简单讲讲C++与Java中的overload，overwrite，override的概念</p>\n<span id=\"more\"></span>\n\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><p><code>stackoverflow:</code></p>\n<p>In C++ terminology, you have <em>overriding</em> (relating to virtual methods in a class hierarchy) and <em>overloading</em> (related to a function having the same name but taking different parameters). You also have <em>hiding</em> of names (via explicit declaration of the same name in a nested declarative region or scope).</p>\n<p>The C++ standard does not use the term “overwrite” except in its canonical English form (that is, to replace one value with a new value, as in the assignment <code>x = 10</code> which overwrites the previous value of <code>x</code>).</p>\n<p>也就是说，C++中在函数层面，并没有overwrite的概念。</p>\n<p>overloading，函数重载，更多适应于在面向过程编程时，<code>函数名相同</code>但是<code>参数列表不同</code>的函数。（注：重载的返回值可以不同，因为返回值并不是区分重载函数的条件。之所以不是，是因为并不是每次调用函数都会接收返回值，返回值只是一种状态）。</p>\n<p>override，函数重写，也称为覆盖，适用于在面向对象编程，并且使用到了继承的类结构体系时，子类重写父类方法，此时<code>函数名相同</code>并且<code>参数列表相同</code>。</p>\n<p>overwrite，类似hiding隐藏的概念，针对变量，可以重新赋值，就是隐藏了之前的值；针对文件，也是类似。</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><p>与C++基本相同。也有重写与重载的区别。</p>\n<p>重载：由于Java完全面向对象，因此没有面向过程的编程。所以重载，就只是在<code>一个类的内部</code>，<code>函数名一样</code>但是<code>参数列表不同</code>。</p>\n<p>重写：子类重写父类的<code>同名同参数</code>方法，java5以后还支持重写返回值（返回值可以不同）。如果返回值也一样，这种特殊的重写称为重构。</p>\n<p>当需要在子类中调用父类的被重写方法时，要使用 super 关键字。</p>\n<h2 id=\"Ref\"><a href=\"#Ref\" class=\"headerlink\" title=\"Ref\"></a>Ref</h2><p><a href=\"https://stackoverflow.com/questions/4738315/c-overriding-overwriting\">https://stackoverflow.com/questions/4738315/c-overriding-overwriting</a></p>\n<p><a href=\"https://www.runoob.com/java/java-override-overload.html\">https://www.runoob.com/java/java-override-overload.html</a></p>\n","categories":["Geek"],"tags":["Developer","技术","C++","Java"]}]