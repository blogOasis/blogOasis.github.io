<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="phInTJ"><meta name="keywords" content=""><meta name="description" content="计算机网络笔记"><meta property="og:type" content="article"><meta property="og:title" content="Computer Network Notes"><meta property="og:url" content="https://blogoasis.github.io/post/c78e5236.html"><meta property="og:site_name" content="拾荒志"><meta property="og:description" content="计算机网络笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/computer_network_cover.jpg"><meta property="article:published_time" content="2022-10-24T13:57:55.000Z"><meta property="article:modified_time" content="2022-12-28T05:00:14.735Z"><meta property="article:author" content="phInTJ"><meta property="article:tag" content="技术"><meta property="article:tag" content="计算机网络"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/computer_network_cover.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Computer Network Notes - 拾荒志</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"blogoasis.github.io",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:100,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!0,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.2.0"></head><body><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>拾荒志</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/background/bg1.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Computer Network Notes"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> phInTJ </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-10-24 21:57" pubdate>2022年10月24日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 16k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 137 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Computer Network Notes</h1><p class="note note-info">本文最后更新于：2022年12月28日 下午</p><div class="markdown-body"><h1 id="计算机网络概览"><a href="#计算机网络概览" class="headerlink" title="计算机网络概览"></a>计算机网络概览</h1><p>定义：通过单一技术互联的自治计算机集合</p><h2 id="关键推动因素"><a href="#关键推动因素" class="headerlink" title="关键推动因素"></a>关键推动因素</h2><ul><li>信号的数字化——取样、量化、编码——二进制流</li><li>规模效应</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>按传输技术分类：</p><ul><li>广播</li><li>点到点</li></ul><p>按范围分：</p><ul><li>Internet：全球互联网</li><li>WAN（国家、大洲）</li><li>MAN</li><li>LAN（Ethernet，WiFi）</li><li>PAN（bluetooth）</li></ul><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p>Internet是全球互联网，internet是网络的网络</p><p>internet是一般性概念，单指网络；Internet是一种具体的实现，即全球IP因特网</p><h3 id="常用设备区别："><a href="#常用设备区别：" class="headerlink" title="常用设备区别："></a>常用设备区别：</h3><ul><li><p>AP是无线接入点，主要的作用的是发出无线信号，连接无线终端，整合的网络管理还会通过AC（<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%97%A0%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2258986661%7D">无线控制器</a>）来完成。AC是整个无线网络的大脑，集中管理和控制整个无线网络。</p></li><li><p>家用路由器，即使在<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=mesh%E7%BB%84%E7%BD%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2258986661%7D">mesh组网</a>的技术下，最多不会超过20个设备组网，太多的设备组网对路由器的压力很大。家用路由器的性能，也无法进行大规模网络下的复杂计算。大部分的AP，性能都要比家用路由器高。</p></li><li><p>Modem：信号转换（数字信号与模拟信号）</p></li><li><p>router：连接子网，交换报文</p></li></ul><h2 id="网络核心：交换"><a href="#网络核心：交换" class="headerlink" title="网络核心：交换"></a>网络核心：交换</h2><p>交换核心——相互连接的路由器</p><p>数据如何在网络之间不断交换？</p><ul><li><strong>电路交换</strong> ：建立专用路径，资源保留<ul><li>优点：数据速率稳定，数据按序到达，网络层透明</li><li>缺点：建立连接时延，利用率较低</li></ul></li><li><strong>分组交换</strong> ：整体信息分为数据包，每个数据包单独转发，转发由交换机&#x2F;路由器自己决定。资源共享<ul><li>优点：利用率高，资源共享，资源按需使用，可以容纳更多用户。因为前三个特点，加上路由器的缓存，分组交换可以处理突发数据。</li><li>缺点：资源竞争冲突，拥塞，路由复杂，数据到达顺序不保证</li></ul></li></ul><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><ul><li>处理时延 —— 处理位错误，通常小于ms</li><li>排队时延 —— 等待时间，取决于拥塞程度</li><li>传输时延 —— 传到介质上的时间</li><li>传播时延 —— 在介质上传播的时间</li></ul><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>protocol：do what at when</p><p>为什么分层：</p><ul><li>明确结构</li><li>模块化</li></ul><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>定位：如何标识一个host</li><li>路由：从src到dest选择路线</li><li>错误控制：检错与纠错</li><li>流量控制：接收双方速度相平衡</li><li>多路复用：资源共享</li></ul><h2 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h2><p>应用层——表示层——会话层——传输层——网络层——数据链路层——物理层</p><p>协议&amp;服务&amp;接口区别</p><p>上四层是端到端通信，下三层是点到点通信</p><h2 id="TCP-x2F-IP模型"><a href="#TCP-x2F-IP模型" class="headerlink" title="TCP&#x2F;IP模型"></a>TCP&#x2F;IP模型</h2><p>应用层——传输层——网络层——链路层</p><p>路由器：连接两个或多个网络，三层设备</p><p>交换机：连接一个网络内的主机</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>功能：提供一个bit流</p><h2 id="信道容量定理"><a href="#信道容量定理" class="headerlink" title="信道容量定理"></a>信道容量定理</h2><p>奈奎斯特取样准则：为了重建信号，每秒需要2H个样本（H为带宽），否则会有重叠</p><p>奈奎斯特准则： 对于一个带宽为W（Hz）的无噪声低通信道，最高的码元传输速率Bmax:</p><p>Bmax &#x3D; 2W(band)</p><p>如果编码方式的码元状态数为M，得出极限信息传输速率（信道容量）Cmax：</p><p>Cmax &#x3D; 2Wlog2M (b&#x2F;s)</p><p>因为信道总是有噪声的，因此奈奎斯特准则给出的是理论上的上限。</p><p>香农定理：带宽为W的通道，一秒内允许传输的最大bit数量</p><p>Cmax &#x3D; Wlog2(1+S&#x2F;N) (b&#x2F;s) 。S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率</p><p>SNR &#x3D; S &#x2F; R，信噪比，单位是分贝，SNR（dB）&#x3D; 10log10 (S&#x2F;N)</p><p>因此相同信道，如果是不同的模拟方法，会得到不同的数据速率，不同的信噪比</p><h2 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h2><p>数字信号（二进制） —— &gt; 相应的模拟信号（波形图）</p><ul><li>调幅（ASK）</li><li>调频（FSK）</li><li>调相（PSK）</li></ul><p>通过调整载波的<strong>幅度，频率，相位</strong>来匹配相应的二进制信息</p><p>BPSK：将二进制0或1映射到给定相位的正弦波（通常高频波）</p><p>BPSK使用了基准的正弦波和相位反转的波浪，使一方为0，另一方为1，从而可以同时传送接受2值(1比特)的信息。以二进制调相为例，取码元为“1”时，调制后载波与未调载波同相；取码元为“0”时，调制后载波与未调载波反相；“1”和“0”时调制后载波相位差180°。</p><p>QPSK：四相相移调制是利用载波的四种不同相位差来表征输入的数字信息，是四进制移相键控。QPSK是在M&#x3D;4时的调相技术，它规定了四种载波相位，分别为45°，135°，225°，315°，调制器输入的数据是二进制数字序列，为了能和四进制的载波相位配合起来，则需要把二进制数据变换为四进制数据，这就是说需要把二进制数字序列中每两个比特分成一组，共有四种组合，即00，01，10，11，其中每一组称为双比特码元。</p><p>8PSK：三个bit标志一个码元，但解码也难了</p><p>QAM：实际在用的调制（AM + PM）</p><p>改变<strong>相位</strong>和<strong>幅度</strong>，QAM-16:一个码元4bit，QAM-64:一个码元6bit</p><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>引导式介质：信号单方向传播，通常固体介质：光纤，双绞线，同轴电缆</p><p>非引导式介质：空气、真空</p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><strong>带宽</strong>（英语：<strong>Bandwidth</strong>）指信号所占据的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A2%91%E5%B8%A6">频带</a>宽度；在被用来描述<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E9%81%93">信道</a>时，带宽是指能够有效通过该信道的信号的最大频带宽度。</p><p>对于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%93%AC%E4%BF%A1%E8%99%9F">模拟信号</a>而言，带宽又称为频宽，以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B5%AB%E5%85%B9">赫兹</a>（Hz）为单位。（比如1.3微米波段，1.3微米说的是波段的中心，波段的范围还需要在中心加减一个德尔塔，得到能够通过信道的最大波长和最小波长，也就对应了最小频率和最大频率，这个范围就是带宽）</p><p>对于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字信号</a>而言，带宽是指单位时间内链路能够通过的数据量。数字信号的传输是通过模拟信号的调制完成的，为了与模拟带宽进行区分，数字信道的带宽一般直接用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E7%89%B9%E7%8E%87">波特率</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E7%AC%A6%E5%8F%B7%E7%8E%87&action=edit&redlink=1">符号率</a>来描述。</p><h3 id="窄带-amp-宽带"><a href="#窄带-amp-宽带" class="headerlink" title="窄带 &amp; 宽带"></a>窄带 &amp; 宽带</h3><h3 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h3><p>中频以下，无线电波遵循地球曲率</p><p>高频波段，无线电波被反射</p><h2 id="多路访问"><a href="#多路访问" class="headerlink" title="多路访问"></a>多路访问</h2><p>接入网络：接入边缘路由器（有线 或 无线）</p><p>多用户：多路访问：单一媒体上合并多个信号流，使得多个用户可以使用共享媒体</p><ul><li>空分复用——SDM</li><li>频分复用——FDM</li><li>波分复用——WDM（与频分基本一样，毕竟反比）</li><li>时分复用——TDM，缺点：同步较困难</li><li>时频复用——结合FDM与TDM，更困难</li><li>码分复用——CDM<ul><li>每一bit时间分为m个间隔，每个间隔叫做chip</li><li>每个站点分到一个唯一的m-bits的code，叫做chip sequence，是m维向量</li><li>上面的向量，每个分量为1，且相互正交</li><li>传输之前，每个station把自己要传输的内容与自己的chip seq相乘，然后相加，即得到在介质中传输的内容。传输完收到后，每个接收者再把接收内容和发送者的chip seq相乘，即得到原来发送内容。</li><li>为了区分传输0和不传输，可以让不传输为0，传输0为传输-1</li></ul></li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>两台相邻机器实现可靠通信（相邻是通过信道连接起来）</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>向网络层提供服务接口</li><li>处理传输错误</li><li>调节数据流</li></ul><p>提供的服务：</p><ul><li>无确认的无连接服务（差错很少或者实时场景，比如LAN下差错相对较少）</li><li>有确认的无连接（帧要确认是否收到，比如无线系统）</li><li>有确认的有连接</li></ul><h2 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h2><p>由于接收到的可能出错，因此需要校验，方便校验， 使用帧的概念。每一个帧都有令牌检验</p><h3 id="成帧方式"><a href="#成帧方式" class="headerlink" title="成帧方式"></a>成帧方式</h3><ul><li>字节计数（但如果计数位出错的话就会全军覆没）</li><li>字节填充的标志字节（缺点：必须以该字节的大小（比如8比特）作为传输基本单元）</li><li>比特填充的标志比特（任意大小单元组成二进制流）——usb协议中使用</li></ul><p>后两者副作用：帧大小取决于帧的数据内容</p><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>确保可靠，我们要有<strong>反馈</strong>信息。接收方返回控制帧，进行肯定或否定的确认。但可能会有<strong>帧丢失</strong>的情况，这样如何反应？需要引入<strong>计时器</strong>，但是计时器会造成这种问题：接收方接收到两个一样的帧，多次传给了网络层，所以又需要为<strong>帧分配序号</strong>，从而使接收方区分原始帧和重传帧。</p><h3 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h3><ul><li>码字，码率，海明距离</li><li>n &#x3D; m + r（m位信息，r位冗余，构成n位码字）</li></ul><p>两个合法<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BB%A3%E7%A0%81/86048">代码</a>对应位上<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81/80092">编码</a>不同的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BD%8D%E6%95%B0/6281904">位数</a>称为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%A0%81%E8%B7%9D/5907009">码距</a>，又称海明距离。</p><p>一个有效编码集中,任意两个码字的海明距离的最小值称为该编码集的海明距离。</p><p>为了检测d位错误，需要一个距离为d+1的编码方案，因为在这样的编码方案中，d位错误不可能将一个有效码字变成另一个有效码字。</p><p>为了纠正d位错误，需要距离为2d+1的编码方案，这样，合法码字足够远，即使发生了d位变化，也还是离原来的码字更近。<strong>在不太可能有更多错误的假设下，可以唯一确认原来的码字，从而纠错</strong>。</p><h3 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h3><p>纠错码被用于无线系统，而光纤铜线等更加可靠，因此使用差错检测和重传更高效。</p><ul><li><p>奇偶校验</p><ul><li>奇校验和偶校验（事先约定好的1的个数）</li></ul></li><li><p>校验和</p></li><li><p>CRC</p><ul><li>使用生成多项式</li><li>首先对原本数据表示成多项式格式M(x)（长度为k，最高位是x的k-1次方）</li><li>有一个选定的生成多项式G(x)，计算r(x) &#x3D; reminder(M(x) * x^r &#x2F; G(x))，r是Gx的最高指数</li><li>计算的T(x) &#x3D; M(x) * x^r - r(x) &#x3D; M(x) * x^r + r(x)</li><li>接收方收到数据后，只需要查看是否能被Gx整除即可</li><li>特性：所有单个错误都能被检测出来，两个错误可以被检测出来。如果Gx有x的r次方和r-1次方，那么所有奇数错误都能检测出来</li></ul></li><li><p>海明码</p><ul><li>我们已经知道原始数据，也知道海明码的位置（1，2，4，8），需要填充这些海明码</li><li>每一位数据都会对海明码作出贡献</li><li>对哪一位作出贡献，取决于该数据的位数是2的幂次如何组合的</li><li>检错的时候，和编码时候的表差不多，还是对应的位去检测偶校验，如果出错，那么最后得到的位运算结果，从下到上，转为10进制，就是出错位置。</li><li>无法纠正二位错误，但还是能告诉有错误</li></ul></li></ul><p>如果出错后去纠正，冗余负载太高，不如重传（Ack）</p><h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><p>自动重传请求</p><p>错误一般分为两类：出错 + 丢失</p><p>常用ARQ协议见下面</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>基于反馈的流量控制</p><ul><li><p>物理层进程和某些数据链路层进程运行在一个称为NIC（网络接口卡）的硬件上，也就是网卡</p></li><li><p>网络层永远得不到任何帧头的信息，这是因为要保持网络层和数据链路层的完全分离。只要网络层对数据链路层和帧格式一无所知，那么当数据链路层协议改变时，网络层软件不用作出任何改变。（比如换了个网卡）</p></li><li><p>一个帧由4个字段组成：kind, seq, ack, info，前三个是控制信息，合称帧头</p></li></ul><h2 id="基本协议"><a href="#基本协议" class="headerlink" title="基本协议"></a>基本协议</h2><ul><li>乌托邦式的协议</li><li>无错，单工停等式协议——只是接受，接受到就可以发下一个</li><li>有错，单工停等式协议——计时器+序号（区分新帧老帧）</li><li>如果在一个协议中，发送方在前移到下一个数据之前必须等待一个肯定确认，这样的协议叫自动重复请求（ARQ），常用的ARQ有SAW（停等）、GBN（回退N）、SRP（选择重传）</li><li>滑动窗口协议（最大区别-双向的）同一个链路传输两个方向，<strong>并且使用捎带确认</strong>，增大利用率</li></ul><h3 id="SAW（停等）"><a href="#SAW（停等）" class="headerlink" title="SAW（停等）"></a>SAW（停等）</h3><ul><li>发送一个帧后，等ACk（当前帧的ACK）</li><li>设置计时器，超时后自动重传</li><li>设置序号区分帧</li><li>如果ACK不标号，那么sender就不知道是在请求重传帧还是请求新帧，因此ACK返回下一帧正在期待的序号</li><li>为了减少不必要的浪费，标识ACK时使用捎带确认</li><li>因为要一直等ACK，所以是半双工</li></ul><p>效率低，因为大量时间在等待ACK（基本上等RTT）</p><h3 id="滑动窗口思想"><a href="#滑动窗口思想" class="headerlink" title="滑动窗口思想"></a>滑动窗口思想</h3><p>一次发多个待ACK的帧，每个帧有number，也可以用作流量控制</p><p>当出错的时候，就使用GBN或者SRP去处理</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>对于发送端：滑动窗口前的，是已经发送的包；滑动窗口内的，是准备好发送的，但是还没有Acked的</p><ul><li>发送端发出去后，窗口左边缩小</li><li>发送端收到Ack后，窗口右边扩张</li></ul><p>对于接受端：滑动窗口前的，是已经收到的包；滑动窗口内的，是准备好接收的，但是还没有收到或者没有ack的</p><ul><li>接收端收到包后，窗口左边缩小，表明已经收到了</li><li>接收端发出Acked后，窗口右边扩张，表明确认了，可以收后面的了</li></ul><h3 id="回退N协议（GBN）"><a href="#回退N协议（GBN）" class="headerlink" title="回退N协议（GBN）"></a>回退N协议（GBN）</h3><p>Ack for multiple frames</p><p>是滑动窗口思想的一种实现</p><h4 id="简要操作"><a href="#简要操作" class="headerlink" title="简要操作"></a>简要操作</h4><ul><li>发送窗口：<ul><li>收缩：包发出去了</li><li>扩展：收到了包对应的ACK</li></ul></li><li>接收窗口：<ul><li>收缩：包收到了</li><li>扩展：发出了ACK</li></ul></li></ul><p>考虑到传输时延，使用管道化。</p><p>为了处理管道化的错误，两种协议，回退N和选择重传</p><p>回退N对应于窗口大小为1的情形，选择重传的窗口大小大于1</p><p>计时器过期时间 T &gt; W * L &#x2F; R（先把窗口的传出去）</p><p>发现错误后也有基于ACK的和NAK的两种方法</p><p>可能丢帧，也可能丢ACK（计时器触发）</p><p>在GBN下，不是每个帧都要独立ACK</p><h4 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h4><p>A - to - B，A有一个计时器</p><h5 id="帧损坏"><a href="#帧损坏" class="headerlink" title="帧损坏"></a>帧损坏</h5><ul><li>帧内部出错：B检测到frame i出错，B必须立刻传NAK i，当A收到NAK，必须重传帧i和后面的（已经传了但是没有被Ack的那些）</li><li>帧i丢失：但是B收到帧i+1，此时B也认为出错，必须发送NAK i</li><li>帧i丢失，但是B没收到其他帧，B可能会发ACK i-1，可能发NAK i。但A的定时器最终失效肯定会保证。</li></ul><h5 id="ACK-丢失"><a href="#ACK-丢失" class="headerlink" title="ACK 丢失"></a>ACK 丢失</h5><ul><li>B收到帧i，发ACK i+1，但是丢失了，但是B可能发了个ACK i+2或者以后的，<strong>不出错</strong></li><li>B没发后面的ACK，A的定时器失效，重发</li></ul><h5 id="NAK-丢失"><a href="#NAK-丢失" class="headerlink" title="NAK 丢失"></a>NAK 丢失</h5><ul><li>A 将在关联的（稍后的）帧上超时，并重新传输帧 i 和所有后续帧。</li></ul><h5 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h5><p>不是每个帧都会被独立ACKed</p><h4 id="窗口大小讨论"><a href="#窗口大小讨论" class="headerlink" title="窗口大小讨论"></a>窗口大小讨论</h4><p>窗口大小是k个bit的序列，帧的数字可以支持2的k次方减1个GBN</p><p>否则容易引起混淆</p><p>比如有一种用重复ACK表示出错的，当k&#x3D;3，W&#x3D;8时，发送端先发送P0，然后收到ACK1，之后发了P1-P8，加上P0，8个全发了，此时又收到一个ACK1，那么既可能是都没错，正常请求下一波，也可能是之前那个出错了，重新开始请求ACK1，需要第一个ACK1去重发。</p><h3 id="选择重传协议（SRP）"><a href="#选择重传协议（SRP）" class="headerlink" title="选择重传协议（SRP）"></a>选择重传协议（SRP）</h3><p>通常和否定策略结合，即发送否定确认。</p><p>每个帧都需要单独确认（因为没有顺序了，Ack也是没有顺序，只能每个都ack一次）</p><p>需要接受端的缓存配合</p><p>效率：min（1，W*t&#x2F;S）,t是传输时延，S是一个的总时间</p><p><strong>GBN和SRP效率都是这个</strong></p><h2 id="数据链路总结"><a href="#数据链路总结" class="headerlink" title="数据链路总结"></a>数据链路总结</h2><p>提供无错的比特流</p><ul><li>成帧（三种方法确定开始和结尾）</li><li>差错控制<ul><li>编码（检错纠错）</li><li>海明码（纠错）</li><li>奇偶（检测）</li><li>CRC（检测）</li></ul></li><li>ARQ差错恢复：重发<ul><li>发送者处理丢失的帧（计时器），接收者处理出错的帧（重复ACK或者NAK）</li><li>SAW思想</li><li>滑动窗口（管道化提高SAW的效率）<ul><li>SAW</li><li>GBN（SAW + P#，ACK&#x2F;NAK的差错控制）</li><li>SPR（修改GBN，通过缓存，只重发出错的帧，需要对每个帧都ACK一下）</li></ul></li></ul></li></ul><h1 id="MAC"><a href="#MAC" class="headerlink" title="MAC"></a>MAC</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>分配channel：单一（固定）&amp; 随机（动态）</p><p>core: Who can transmit at when</p><h2 id="多人访问链接"><a href="#多人访问链接" class="headerlink" title="多人访问链接"></a>多人访问链接</h2><p>包含两部分：</p><p>点对点连接：终端和交换机（台式）<br>广播连接：以太网 ，无线连接</p><p>多人访问并非只有动态，也可能有p to p</p><h2 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h2><ul><li>ALOHA</li><li>CSMA</li><li>Taking turns</li><li>collision free</li><li>limited-contention</li><li>Ethernet</li><li>Wireless LAN</li></ul><p>要解决的核心：<strong>冲突检测、恢复</strong></p><p>冲突系统：多个用户使用相同的通道，导致冲突</p><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><ul><li>frame time：transmission delay</li><li>N : new frames</li><li>G : generated frames &#x2F; frame time(considering retransmission)</li></ul><h3 id="pure-ALOHA"><a href="#pure-ALOHA" class="headerlink" title="pure ALOHA"></a>pure ALOHA</h3><ul><li><p>检测：听</p></li><li><p>恢复：等随机时间再重发</p></li><li><p>Vulnerable time：2t（t 是 transmission delay）</p></li><li><p>max throughput : 0.184</p></li></ul><h3 id="Slotted-ALOHA"><a href="#Slotted-ALOHA" class="headerlink" title="Slotted ALOHA"></a>Slotted ALOHA</h3><ul><li>Time is cut into slots.</li><li>need sync</li><li>Vulnerable time : t</li><li>max throughput : 0.368</li></ul><p>ALOHO 的主要问题：吞吐量太低了</p><p>本着提高信道利用率，下面是CSMA</p><h3 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h3><p><strong>check before transmit</strong>（提高信道利用率）</p><ul><li>scenario : LAN (propagation delay is small)</li><li>p-Persistence CSMA &amp; Non-Persistence CSMA<ul><li>if persist, the node listen to the channel continuously, and transmit frame with probability of p.</li><li>if not persist, node doesn’t listen continuously, check channel after random time</li></ul></li><li>Collision may still happen because of propagation delay</li><li>p越小，其实吞吐量越大，倾向于conservative</li><li>主要是为了提高利用率，但冲突还是会发生，一旦发生，帧就要浪费</li></ul><p>为了减少不必要的浪费，<strong>添加冲突检测</strong>，检测到就直接停止</p><h3 id="CSMA-x2F-CD（Ethernet）"><a href="#CSMA-x2F-CD（Ethernet）" class="headerlink" title="CSMA&#x2F;CD（Ethernet）"></a>CSMA&#x2F;CD（Ethernet）</h3><p>如何检测？</p><ul><li>有线：听到的和发出的一样不</li><li>无线：难以检测<ul><li>硬件限制（只能取一）</li></ul></li></ul><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><ul><li>contention</li><li>idle</li><li>transmission</li></ul><h4 id="检测时间"><a href="#检测时间" class="headerlink" title="检测时间"></a>检测时间</h4><ul><li><p>最小：t（prop）</p></li><li><p>最大：2t（RTT）</p></li></ul><p>CSMA&#x2F;CD &#x3D; slotted ALOHA with slot of length 2t</p><p>静态的适合高负载，动态的适合低负载</p><h3 id="Collision-Free-Protocol"><a href="#Collision-Free-Protocol" class="headerlink" title="Collision-Free Protocol"></a>Collision-Free Protocol</h3><ul><li>polling(轮询)：如果master出问题的话系统崩溃</li><li>token ring：单个节点出问题的话系统崩溃</li><li>bit-map（适合人多）reserve</li><li>binary countdown（有优先级）reserve</li></ul><h3 id="Limited-Contention-Protocols"><a href="#Limited-Contention-Protocols" class="headerlink" title="Limited Contention Protocols"></a>Limited Contention Protocols</h3><p>结合起来</p><p>低负载竞争（延迟小），高负载无冲突（contention-free）（利用率高）</p><p>做法：分组：组内竞争一个时间slot</p><p>关键在于动态分配时间槽</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h3><p>LAN</p><p><strong>Encapsulation</strong>: IP datagram -&gt; Ethernet frame</p><ul><li>frame structure：Preamble，Mac Address(Dest &amp; Source)，Type（higher-layer）Data，CRC</li><li>many different Ethernet standards（a family）</li><li>不可靠、无连接</li></ul><h3 id="经典以太网"><a href="#经典以太网" class="headerlink" title="经典以太网"></a>经典以太网</h3><p>传统以太网采用广播的方式发送信息，同一时间只允许一台主机发送信息，否则各主机之间发生冲突，因此属于半双工方式。</p><h4 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h4><ul><li>目标地址第一位：0是普通地址，1是组地址，该组中的所有站都要接受（组播），全1是广播</li><li>type：网络层可能有多个协议，因此需要知道谁来处理</li><li>Data：不能太大，太大了收发器没有足够的内存来存储完整帧；不能太小，太小了<ul><li>冲突后会截断，截断的更短，要能区分有效帧和截断的无效数据</li><li>（更重要原因）—— 传完了，但是冲突了。冲突时接收方发出突发噪声，让发送方知道冲突了。但如果帧太短，发送方已经传完了，那么它就知道自己已经传成功了，结论错误。</li><li>所以传输时间为Lmin &#x2F; R，传播时间为d &#x2F; c，Lmin &#x2F; R &gt; 2d &#x2F; c，要求</li></ul></li></ul><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ul><li>NIC收到网络层的数据，构建帧</li><li>监听信道96 bit time，如果空闲就传，否则等待</li><li>无冲突，传输成功</li><li>有冲突，放弃并且传48bit的jam signal（突发信号），等待随机时间</li></ul><p>随机时间如何确定？</p><h4 id="二进制指数后退"><a href="#二进制指数后退" class="headerlink" title="二进制指数后退"></a>二进制指数后退</h4><p>两个站冲突后等待，如果等待时间一样，那么会一直冲突</p><p>如果冲突了m次，那么下次就从0到2的m次方-1，这些数中随机选择。期望增加</p><p>最大1023，还冲突发失败报告</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>帧越长，效率越高，但是那样变成只为一个人服务了</p><h3 id="集线器-hub-x2F-中继器"><a href="#集线器-hub-x2F-中继器" class="headerlink" title="集线器 hub &#x2F; 中继器"></a>集线器 hub &#x2F; 中继器</h3><ul><li><p>无脑传输，一个来，其余所有路线传出去</p></li><li><p>放大信号，延长传输距离</p></li><li><p>共同组成一个大的冲突域</p></li><li><p>hub没有CSMA&#x2F;CD，所以主机需要使用CSMA&#x2F;CD</p></li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>有缓存 ：store and forward</li><li>传输有目标，只传到目标地址的主机</li><li>在各自的冲突域内运行CSMA&#x2F;CD</li><li>全双工，无冲突</li><li>自学习，交换表</li></ul><h3 id="无线网络LAN"><a href="#无线网络LAN" class="headerlink" title="无线网络ＬＡＮ"></a>无线网络ＬＡＮ</h3><p>基站 : 无线和有线之间的桥梁</p><p>802.11n – Wi-Fi4，最高到600Mbps，2.4-5GHz</p><p>802.11ac – Wi-Fi5，5GHz，3.4Gbps</p><p>802.11ax – Wi-Fi6，2.4-5GHz，7Gbps</p><p>都是理论最高速度</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>衰减</li><li>干扰</li><li>多径效应(反射的存在)</li></ul><p>SNR很重要</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>隐藏终端问题 – 由于竞争者离得太远而导致站无法检测到潜在的竞争者</li><li>暴露终端问题 – 发送方由于离得近, 导致不敢发送(其实方向不一样可以发送)</li></ul><p>CSMA还是可以工作,但是无法检测冲突,只能避免冲突</p><h4 id="CSMA-x2F-CA"><a href="#CSMA-x2F-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h4><p>发送前要等一段时间(发送方和接收方都是)</p><p><strong>RTS - CTS</strong></p><p>类似于预定的思想</p><ul><li><p>如果有基站: 发送者发RTS,听到的人知道附近有人在发东西, 先别发, 接收方返回CTS, 其他人听到CTS, 也等着(CTS里面有帧长度信息所以知道等多长时间)</p></li><li><p>没有基站协调，每个host都是独一无二的， 有隐藏终端和暴露终端的问题. 与上面不同的一点, 如果一个站点听到了RTS, 但是没有听到CTS, 说明这个站点和接收方实际上很远, 可以发送</p></li></ul><p>真正希望知道的是接收方附近是否有无线电活动</p><hr><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>数据链路就是将帧从一端传到另一端，而网络层是处理端到端数据传输的最底层。因此需要知道整个网络的拓扑结构，选择路径、选择路由</p><h2 id="提供服务"><a href="#提供服务" class="headerlink" title="提供服务"></a>提供服务</h2><ul><li>向传输层提供服务需要独立于路由器（数量种类与拓扑）</li><li>传输层需要的网络地址需要一个统一的编址方案</li><li>无连接和连接的争论</li></ul><p>不面向连接，数据报——数据报网络（比如IP）</p><p>面向连接，虚电路——虚电路网络（比如MPLS，在ISP中使用的）</p><h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>是网络层软件的一部分，负责确定一个入境数据包应该发送到哪个输出线路上。</p><p>路由：对使用哪一条路径作出决策，找到从src到dest的一条路径</p><p>转发：数据包到达后路由器根据路由表采取的行为（查表）</p><p>路由算法：生成和更新路由表</p><ul><li>需要全局信息的——link- state算法（链路状态算法），如Dijkstra</li><li>只需要分散信息的——迭代过程就是与邻居不断交换信息，distance-vector（距离矢量）算法，如Bellman-Ford算法</li><li></li><li>静态算法——路由改变很慢</li><li>动态算法——路由改变很快</li></ul><h3 id="最优准则"><a href="#最优准则" class="headerlink" title="最优准则"></a>最优准则</h3><p>如果节点j落在从i到k的最短路上，那么从j到k的最短路遵循同样的路径</p><h3 id="最短路径路由（dijkstra算法）"><a href="#最短路径路由（dijkstra算法）" class="headerlink" title="最短路径路由（dijkstra算法）"></a>最短路径路由（dijkstra算法）</h3><p>要求：</p><ul><li>非负</li><li>cost可加</li></ul><p>这是static算法</p><p>dijkstra需要全局信息</p><p>迭代path的长度，k次迭代后，集合N里面包含了k个到原点最近的节点</p><p>每次从不在N里面的节点中选择一个cost最小的，然后加入到N中，用这个节点去更新其他所有节点（不在N里）</p><h3 id="距离矢量算法"><a href="#距离矢量算法" class="headerlink" title="距离矢量算法"></a>距离矢量算法</h3><ul><li>局部信息</li><li>动态更新</li><li>Bellman-Ford</li><li>要有一个更新顺序，每次都按照这个顺序，根据自己的所有邻居最新情况去更新，直到不再变化</li><li>有count-to- infinite问题</li></ul><h3 id="链路状态路由过程"><a href="#链路状态路由过程" class="headerlink" title="链路状态路由过程"></a>链路状态路由过程</h3><ul><li>找到邻居，直到邻居地址</li><li>测量到邻居的cost（可以用RTT近似）</li><li>建立一个packet，里面有刚才的信息</li><li>发出packet到其他路由器</li><li>计算最短路</li><li>该路由用于OSPF中</li></ul><h3 id="分层路由"><a href="#分层路由" class="headerlink" title="分层路由"></a>分层路由</h3><p>路由器被分为多个自治系统（AS）</p><p>一个AS内运行同一种路由算法（intra- AS），比如RIP和OSPF</p><p>网关路由器：负责将数据包转发到AS以外的地方，运行的是自治系统间（inter-AS）路由协议，比如BGP</p><p>泛洪：强制泛洪（发到所有出口，重复很多），选择泛洪（只发给目的地）</p><h3 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h3><ul><li>使用泛洪</li><li>或使用多目的地路由</li><li>或使用生成树路由<ul><li>发送最少packet</li><li>只能用于link-state，需要全局的信息</li></ul></li><li>反向路径转发：生成树的近似<ul><li>如果数据包到达的链路 在其返回发送方的最短路径上，那么泛洪</li><li>其他情况，路由器直接丢数据包，因为很有可能是重复的</li></ul></li></ul><h3 id="多播路由"><a href="#多播路由" class="headerlink" title="多播路由"></a>多播路由</h3><h3 id="移动主机"><a href="#移动主机" class="headerlink" title="移动主机"></a>移动主机</h3><p>使用隧道，家庭代理</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>处理网络中的流量吞吐大小</p><ul><li>开环方式：不反馈，直接避免</li><li>闭环方式：使用反馈</li></ul><p>增加资源：通常带宽</p><p>减少流量</p><h2 id="QoS"><a href="#QoS" class="headerlink" title="QoS"></a>QoS</h2><p>不同应用对不同的性能要求不一样</p><p>为了平滑抖动，需要使用buffer</p><p>一个buffer里面多个包，需要管理队列，也就是调度</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>多个网络来的包混在一起，谁先转发出去？</p><ul><li>FIFO</li><li>PQ</li><li>罗宾环 &#x2F; WFQ（权重平衡队列）</li></ul><h3 id="Traffic-Shaping"><a href="#Traffic-Shaping" class="headerlink" title="Traffic Shaping"></a>Traffic Shaping</h3><p>入口点控制，调节流量</p><p>主要是ISP管理，安装在接入网中，主要为了保护网络，即使计算机发很多包，但是对后面的网络影响不大</p><h4 id="leaky-bucket"><a href="#leaky-bucket" class="headerlink" title="leaky bucket"></a>leaky bucket</h4><p>像是漏水桶一样，有一个最大吞吐速率来平滑大的burst</p><h4 id="Token-Bucket"><a href="#Token-Bucket" class="headerlink" title="Token Bucket"></a>Token Bucket</h4><p>每一个包都必须有一个token才能出去。如果空闲，那么token会有一个最大值；当来包后，可以消耗这些token，如果消耗完token，必须要等待有token才能出去。同时如果队列已经满，那么新的packet将会被丢弃</p><h2 id="定位（IP）"><a href="#定位（IP）" class="headerlink" title="定位（IP）"></a>定位（IP）</h2><p>以太网协议（Ethernet）规定了电子信号如何组成数据包（packet），解决了子网内部的点对点通信。</p><p>以太网协议不能解决多个局域网如何互通，这由 IP 协议解决。</p><p>设计原则：</p><ul><li>没有硬编码地址</li><li>单一命名结构，不能有歧义</li><li>容易处理</li></ul><p>IP作用：标识一个interface，不是一个host</p><p>路由表：mapping</p><p>entry：目的IP地址 -&gt; 出站链路（转发到哪个路由器）</p><p>索引：根据目标IP地址的网络部分去索引</p><h3 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h3><p>每一个ip地址包括两部分：网络地址和主机地址（最新的还有子网id），五类地址对所支持的网络数和主机数有不同的组合。</p><p>共四个八位组，如192.168.123.253</p><p>因此只有每个八位组内部才存在一个增加进位的关系，不同的八位组之间其实是相互并列的，互不影响，完全不需要进位的</p><p>1、a 类地址 ：一个a 类ip地址仅使用第一个8位位组表示网络地址。剩下的3个8位位组表示主机地址。a类地址的第一个位总为0，因此a类地址的范围小于127，再去掉0.0.0.0的主机地址，a类地址只有126个。a类地址最大是0111 1111，也就是127</p><p>当查看一个ip的第一位（从左到右），如果是0，就是a类地址</p><p>2、b 类地址 ： b类网络地址范围 128.0.0.1~191.255.255.254。一个b类ip地址使用两个8位位组表示网络号，另外两个8位位组表示主机号。128.0对应1000 0000，191.255对应1011 1111，我们发现第一位都是1，第二位都是0，因此网络个数为2的14次方。</p><p>当查看一个ip第一位是1，第二位是0，（10开头）就是b类地址</p><p>3、 c 类地址 ：范围：192.0.0.1~223.255.255.254。这类地址可以认为与a类地址正好相反。a类地址使用第一个8位位组表示网络号，剩下的3个表示主机号，而c类地址使用三个8位位组表示网络地址，仅用一个8位位组表示主机号。192.0.0是1100 0000 0000，223.255.255是1101 1111 1111</p><p>当查看一个ip第一位是1，第二位是1，第三位是0，（110开头）就是c类地址</p><p>4、d 类地址 d 类地址用于在ip网络中的组播( multicasting ，又称为多目广播)。d类地址的前4位恒为1110 ，预置前3位为1意味着d类地址开始于128+64+32等于224。第4位为0意味着d类地址的最大值为128+64+32+8+4+2+1为239。（不可分配给主机使用）</p><p>有的会加上子网ID（一个大组织用的多），能隐藏内网结构信息，也有助于减少地址空间耗尽问题</p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>Masking：从IP地址中提取出物理网络地址的过程</p><p>IP地址与掩码与运算之后，结果为1的是网络号，结果为0的是主机号</p><p>所以掩码某一位为1，代表是网络地址或者子网地址，如果为0，代表是主机地址</p><h4 id="在三层结构下（有子网地址）"><a href="#在三层结构下（有子网地址）" class="headerlink" title="在三层结构下（有子网地址）"></a>在三层结构下（有子网地址）</h4><p>那么网络id要和网络掩码与运算，子网id要和子网掩码与运算（再减去网络id）</p><h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><p>网络中太多网络和目的地，毕竟从技术上讲，每个网络都需要下一跳的信息</p><p>使用默认路由来处理未知目的地，能够减少空间，但可能不是最优路径</p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>聚合路由以节省空间</p><p>将一个连续地址块折叠成一个逻辑网络</p><p>网络地址就是这个连续块的最小值</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="为什么有传输层"><a href="#为什么有传输层" class="headerlink" title="为什么有传输层"></a>为什么有传输层</h2><p>为了定位一个路由，只需要下面三层，但是我们用户接触的是应用层，还需要一层，连接网络层与应用层。提供的是一种逻辑的连接，在不同主机的<strong>不同进程</strong>之间，对应用层掩盖网络层的一些细节。</p><p>当你位置变动，实际上网络层的细节都变了，路由方式也变了，甚至路由协议也变了。所以我们需要传输层，提供逻辑上的可靠连接抽象</p><ul><li>进程与进程之间的</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>面向连接（TCP）<ul><li>建立连接</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>不面向 – UDP</li><li>注意：网络层给了两种，面向连接（建立虚电路）与不面向（IP），但主流还是IP</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>往往有4种方式，后两种常见</p><ul><li>网卡</li><li>应用层</li><li>操作系统内核</li><li>网络应用的库</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><ul><li>需要提供可靠、顺序的数据包<ul><li>数据链路层的有序，为什么网络层有无序？</li><li>原因：数据链路有序（GBN），但数据链路仅针对相邻主机的一个hop，是在以太网里运行的，但是出去了还是要靠IP，但是IP是不管的（每个packet独立转发），因此传输层需要再把顺序搞回来</li></ul></li><li>流量控制</li><li>拥塞控制</li><li>网络层运行在所有设备上，主要路由器上，由ISP拥有，但传输层主要是本机，由个人拥有</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li>端口（src与dest）——端口就是传输层的address</li><li>Seq #（以bytes的多少计数，不是按照segments计数，每一个byte都被编号了）</li><li>Ack #（同上）</li><li>接受窗口（流控）</li><li>Flag<ul><li>ACK（上面的ACK是否有效）</li><li>RST（reset）</li><li>SYN（是否为syn包）</li><li>FIN（是否为fin包）</li></ul></li></ul><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>IP + port</p><ul><li>UDP的端口号对应一个队列，但是TCP的端口号就是共享的</li></ul><h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>两次握手行不行？</p><p>一个请求，一个回应，同时事先约定我们都从0开始（因为总还是有同步需求）</p><p>不行，根源在于建立在IP上，每个包都是单独转发，路由可能需要复制包去泛洪，这样接收者会收到重复的0，会认为是一个新的连接。</p><p>建立连接，为了防止混淆，需要每次一个ISN（初始seq num），同时三次握手来保障。</p><p>必须要有个已读回执，也就是三次握手，不会收到重复的影响</p><ul><li>序列号要重复使用，其使用间隔必须大于2T，以便于上一轮的包与ACK都expire了</li><li>MSL —— 最长lifetime</li><li>每次连接都是新的初始序列号</li><li>建立后忽略重复建立请求</li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>sender发送SYN置1的包，此时seq为x</li><li>receiver返回SYN与ACK均置1的包，seq为y，同时ack为x+1</li><li>sender发送ACK的包，seq为x+1，ack为y+1</li><li>对应关系：</li><li>收到的seq是什么，发出的ack就是什么+1（表示expect下一个）</li><li>收到的ack是什么，就发出什么seq（是他所需要的）</li></ul><p><strong>重复建立连接请求</strong></p><p>如果重复请求建立同一个连接（网络原因），接收者照常回复，由发送者在第三次时候来判断，直接发RST（reset）</p><p><strong>重复ACK</strong></p><p>还是由发送者判断，发送RST</p><p><strong>同时请求建立连接</strong></p><p>各自发SYN与（SYN+ACK），结束，不再有第三次ACK</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>sender发送FIN</li><li>receiver发送ACK，此时关闭单方向的（half-close）</li><li>receiver发送FIN，表示我也结束了</li><li>sender发送ACK，表示我知道了</li><li>即每个方向用两次握手</li><li>关闭时不需要三次，因为如果丢了，还有个过期的机制，无影响</li></ul><p><strong>同时关闭</strong></p><p>各自发送FIN，收到后再发送ACK，即关闭</p><p><strong>第四步的发送</strong></p><p>为什么在第二步已经关闭了单向的连接（比如关闭一个浏览器网页），但是第四步还是可以发送ACK？</p><p>原因：第二步关闭的是应用层，第四步是传输层处理</p><h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>双端都需要一个状态机，才能知道目前的状态，在等的状态，等到后发什么，变成什么</p><h3 id="TCP性质"><a href="#TCP性质" class="headerlink" title="TCP性质"></a>TCP性质</h3><ul><li>流量与拥塞控制</li><li>TCP Reno，newReno：GBN</li><li>TCP SACK：SRP</li></ul><p>ACK的确认仍然是累加的</p><p>不使用NAK，但是使用重复的ACK</p><h3 id="流量-x2F-拥塞控制"><a href="#流量-x2F-拥塞控制" class="headerlink" title="流量&#x2F;拥塞控制"></a>流量&#x2F;拥塞控制</h3><p>两个变量：</p><ul><li>rwnd : 接收方目前想要接受的速度，可以小于物理buffer</li><li>cwnd：拥塞控制的变量，发送方控制</li><li>cwnd : 一个RTT内可以发出多少segment，是累加的，总数需要加起来</li><li>有效的窗口 &#x3D; min(rwnd, cwnd)</li></ul><p>拥塞控制的核心就在于调整cwnd</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><ul><li>指数增长</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>AIMD</li><li>线性增加</li><li>指数减少</li></ul><h4 id="检测-1"><a href="#检测-1" class="headerlink" title="检测"></a>检测</h4><p>这里进行了一次不对等条件的转换</p><p>很多包时，路由器丢掉最后的包，我们直接认为：丢包 &#x3D; 出现拥塞</p><p>然后变成了检测丢包的问题：</p><ul><li>重传时间超时（RTO）</li><li>重复ACK</li></ul><h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>RTO需要设置好，大于RTT（至少），也不能太长</p><p>动态调整RTO</p><p>先估计RTT：</p><p>发一个SampleRTT，然后收到ACK</p><p>然后对于SampleRTT进行平滑处理，这里方法是在时间上加窗口</p><p>current estimated &#x3D; old estimated * (1 - x) + x * sampleRTT</p><p>类似等比数列，越前面的影响越小</p><p>RTO &#x3D; estimated RTT + 安全边距</p><p>边距就是SampleRTT的方差，同时也被应用了一个以时间为权重的窗口</p><h4 id="重复ACK"><a href="#重复ACK" class="headerlink" title="重复ACK"></a>重复ACK</h4><p>快重传（cont）</p><h4 id="慢启动细节"><a href="#慢启动细节" class="headerlink" title="慢启动细节"></a>慢启动细节</h4><p>收到一个ACK，就增大一个cwnd</p><ul><li>如果每个包都有ACK，那么整体增速就是2的n次方</li><li>每隔一个包确认一次，底数就是1.5</li><li>达到阈值后就进入拥塞控制阶段</li></ul><h4 id="拥塞避免-1"><a href="#拥塞避免-1" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>每收到一个ACK，就增大<code>1/cwnd</code>，因此是线性增长</li></ul><h4 id="TCP-Tahoe"><a href="#TCP-Tahoe" class="headerlink" title="TCP Tahoe"></a>TCP Tahoe</h4><p>收到三个连续ACK或者超时</p><ul><li><code>ssthresh = cwnd / 2</code></li><li><code>cwnd = 1</code></li></ul><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>超时后与Tahoe一样，但是当收到三个连续ACK后</p><ul><li><code>cwnd = cwnd / 2</code></li><li>继续在拥塞避免阶段</li></ul><h4 id="快重传-amp-快恢复"><a href="#快重传-amp-快恢复" class="headerlink" title="快重传&amp;快恢复"></a>快重传&amp;快恢复</h4><p>如果有三个ACK，不至于超时那么严重，不会激进地把cwnd设置为1</p><p><code>ssthresh = min(rwnd, cwnd / 2)</code></p><p><strong>快重传</strong>：先把请求的发了，然后<code>cwnd = ssthresh + number of duplicated ACKs</code>（临时阶段）</p><p><strong>快恢复</strong>：然后从临时恢复过来</p><p>即收到新的ACK后，说明那个丢失的解决了，再设置<code>cwnd = ssthresh</code>，重新进入拥塞避免阶段</p><p>握手阶段建立的ssthresh</p><p>快重传：要不要加3，快恢复：要不要把cwnd变为一半</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>主要看公平性与吞吐量</p><h3 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h3><p>理想是平分带宽</p><p>如果大家都遵守TCP的AIMD，那么会不断震荡到平衡最佳位置</p><p>但有的应用程序如果不遵守AIMD，那么会一直抢带宽（也比较难）</p><p>但是一般情况下许多应用程序可以通过并行化的方式，开启多个TCP连接，比如浏览器，这样协议是允许的</p><p>为了防止这种流氓行为，有的应用使用UDP协议（一些多媒体协议）</p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>throughout &#x3D; W * MSS &#x2F; RTT，W基本决定于cwnd</p><p><code>W = min(rwnd, cwnd)</code></p><p>能发的个数 * 一个大小 &#x2F; 时间</p><h3 id="Long-Fat-Pipes"><a href="#Long-Fat-Pipes" class="headerlink" title="Long , Fat Pipes"></a>Long , Fat Pipes</h3><p>long : RTT is big</p><p>Fat: pipe is wide</p><p>Large bandwidth-delay product, TCP is not friendly.</p><h3 id="AQM"><a href="#AQM" class="headerlink" title="AQM"></a>AQM</h3><p>router如何和host联动，使得sender快速知道有一个拥塞。（除了time out）</p><p>router has buffer，which contains a queue(waiting queue)</p><p>管理队列：</p><ul><li>Drop tail（不公平）</li><li>Early Congestion Notification（Random Early Drop (RED)</li></ul><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221201111745742.png" srcset="/img/loading.gif" lazyload alt="image-20221201111745742" style="zoom:67%"><ul><li>对于黄色的部份，由于提前丢包，发生重复ACK或者time out，sender就知道即将出现拥塞了。</li><li>丢尾的方式，大家基本同时拥塞，丢了之后，再经过一轮时间，又变成了同时拥塞</li></ul><p>RTT增大（不稳定）主要是由于queuing delay</p><p>TCP改的版本很多？IP基本没人该，因为TCP是在end device里面的，IP out of control</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>无连接，不可靠</p><p>由应用层去处理丢包，重复，失序等问题</p><p>端口抽象：允许同一主机上面多个通信端口</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>源端口</li><li>目的端口</li><li>总长度</li><li>校验和</li><li>数据</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>接触TCP的话，需要接触其内核，各种编程地配置连接，所以传输层的软件是分成了两部分，一层对上， 一层对下，socket就是使用下层接口时候的东西</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>传输层：</p><p>可靠性：ACK + 重传</p><p>流量控制：rwnd</p><p>拥塞控制：cwnd</p><p>TCP：</p><p>三次握手，四次挥手</p><p>两个阶段（慢启动和拥塞避免），两个变量（cwnd和ssthresh），两个性能指标（公平和吞吐），两种方案：Tahoe和Reno</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>UDP协议，端口53，应用层处理重发</p><p>使用缓存</p><p>域名解析</p><p>DHCP是给主机分配host，注意区分</p><h2 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h2><p>TCP协议，端口25</p><p>MTA ：mail transfer agent</p><p>UA：user agent</p><p>SMTP主要是MAT给MTA传输时候用到的，UA其实是订阅了MTA</p><p>而M TA传给UA时，用的是其他协议，比如IMAP，POP3</p><h2 id="WWW"><a href="#WWW" class="headerlink" title="WWW"></a>WWW</h2><ul><li>URL：统一资源定位符</li><li>cookie：保留状态</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>TCP协议，80端口</p><p>支持管道化请求与缓存</p><p>使用持久连接来提高性能</p><h2 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h2><p>声音视频：ADC，模拟to数字转换</p><p>电话波特率是8000，每个样本8bit，总共64kbps</p><p>取样，量化，编码</p><p>H.264也是视频压缩格式</p><p>交织：将一个样本分布在不同的传输上，从而减少丢失的影响</p><h2 id="H-323"><a href="#H-323" class="headerlink" title="H.323"></a>H.323</h2><p>conferencing</p><h2 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h2><p>network management</p><h2 id="路由算法-1"><a href="#路由算法-1" class="headerlink" title="路由算法"></a>路由算法</h2><p>OSPF</p><ul><li>IGP, intra-AS routing</li><li>Link-state</li><li>dijkstra</li><li>no transport protocol</li></ul><p>RIP</p><ul><li>distance vector</li><li>Bellman-ford</li><li>UDP port 520</li></ul><p>BGP</p><ul><li>Inter-AS</li><li>TCP port179</li><li>dynamic</li></ul><h1 id="Network-Security"><a href="#Network-Security" class="headerlink" title="Network Security"></a>Network Security</h1><p>密码架构</p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>发送方和接收方使用一个key</p><p>使用相同的key加密和解密</p><h2 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h2><p>每个人都有一对key：公钥和私钥，公钥所有人都知道，私钥只有自己知道</p><p>text经过一次公钥再经过一次私钥会还原成text</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><ul><li>接收方可以验证发送方所声称的身份</li><li>发件人不能否认发送了信息</li><li>消息不能由其他人撰写</li></ul><p>如何实现？公钥算法</p><p>Alice发给Bob</p><p>先经过自己的私钥加密，然后经过Bob的公钥加密</p><p>这样Bob收到后，先经过自己的私钥解密，只有自己能解开，然后用Alice的公钥解密，如果能解开，那么就能确定是Alice发的，就像是Alice在上面签名了一样</p><h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>authentication</p><ul><li><p>回放攻击</p></li><li><p>中间人攻击</p></li></ul><p>使用KDC或者CA去解决，</p><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul><li>网络隔离</li><li>允许一些通过，阻止另一些</li><li>防止DOS攻击，比如SYN泛洪</li><li>防止非法修改数据</li><li>只允许授权访问内部网络</li></ul><p>三种防火墙</p><ul><li>无状态数据包过滤</li><li>状态包过滤</li><li>应用网关</li></ul><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p>因特网组成：</p><ul><li>接入网络 - 边缘<ul><li>ADSL非对称数字用户线</li><li>FTTH光纤入户</li><li>无线Wi-Fi（全名是IEEE 802.11 family）与蜂窝网络</li></ul></li><li>核心网<ul><li>IP</li></ul></li></ul><p>调制：</p><p>波特率 &#x3D; symbol rate</p><p>比特率 &#x3D; 数据率 &#x3D; 波特率 * X bit&#x2F;symbol</p><h2 id="传输介质-1"><a href="#传输介质-1" class="headerlink" title="传输介质"></a>传输介质</h2><ul><li>双绞线<ul><li>数据速率：5类100Mb，超5类传输速率1000M—使用8根（全部使用）</li><li>抗干扰：屏蔽双绞线能提高自己的抗干扰能力</li></ul></li><li>同轴电缆<ul><li>数据速率：10Mb&#x2F;s</li><li>抗干扰：良好</li></ul></li><li>光纤<ul><li>数据速率：2.5Gb&#x2F;s，10Gb&#x2F;s</li><li>抗干扰：优</li></ul></li></ul><p>传输介质的date rate，类型，限制范围</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>IP辅助协议，传达网络级错误的相关信息，只报告错误不做处理，封装在IP里面</p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>IPv4的地址耗尽</p><p>IPv6的安全性</p><p>IPv4到6的相互转换</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>IP 到 MAc的转换</p><p>RARP：MAC到IP的转换</p><p>TCP是可靠+有序，UDP是不可靠+无序</p><p>UDP支持单播&#x2F;多播传送，但TCP只有单播传送</p><p>MAC地址中01：00:5E开头的是组播地址</p><h2 id="网段"><a href="#网段" class="headerlink" title="网段"></a>网段</h2><p><strong>网段</strong>是指一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>中使用同一<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%B1%82">物理层</a>直接通讯的那一部分。</p><p>通常使用同一物理层的设备之间必然通过相同的传输介质直接相互连接，（如交叉双绞线直接连接的两台主机）；但是两组其传输介质并非直接相连的网络设备，如果它们的传输介质通过工作在物理层的扩展设备如中继器和集线器等转接连接，则仍然被视为同一物理层中的设备，是一个而非两个网段。另外，工作在数据链路层或更高层的设备如网桥、交换机、路由器等等，由它们连接起来的两组设备仍然分别处于各自独立的物理层，因此是两个网段。</p><p>在以太网环境中，一个网段其实也就是一个冲突域（碰撞域）。同一网段中的设备共享（包括通过集线器等设备中转连接）同一物理总线，在这一总线上执行CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）机制。不同网段间不共享同一物理层，因此不会跨网段发生冲突（碰撞）。</p><p>现代高速以太网通常使用交换机代替集线器，交换机是工作在数据链路层的设备，由它转接的两组设备不在同一网段中。事实上，交换机为连在其上的每一个独立设备各自划分出一个独立的网段，每个网段只包含两个设备——交换机本身，和这个独立设备。这样，交换机就能隔离冲突，提高网络的利用率和总体性能。</p><h2 id="应用层总结"><a href="#应用层总结" class="headerlink" title="应用层总结"></a>应用层总结</h2><p><img src="https://blog-image-store-73.oss-cn-shanghai.aliyuncs.com/images/image-20221227232642827.png" srcset="/img/loading.gif" lazyload alt="image-20221227232642827"></p><p>SNMP：网络管理协议</p><p>POP，IMAP：收邮件</p><p>RTP，RTSP：串流</p><p>注意DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议</p><p>调制解调器是物理层的设备</p><h2 id="NIC的四种模式"><a href="#NIC的四种模式" class="headerlink" title="NIC的四种模式"></a>NIC的四种模式</h2><ul><li>广播模式：接收全1的帧</li><li>多播模式：接收所有组播的帧</li><li>直连：接收目标地址为自己地址的帧</li><li>混杂模式：接收所有帧，wireshark这么做的，交换机和网桥的NIC也工作在这个模式</li><li>一般NIC的默认模式：广播模式 + 直连（direct）</li></ul><h1 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h1><p>该封面图片由<a target="_blank" rel="noopener" href="https://pixabay.com/zh/users/xiserge-15871962/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887">xiSerge</a>在<a target="_blank" rel="noopener" href="https://pixabay.com/zh//?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=7426887">Pixabay</a>上发布</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Geek/" class="category-chain-item">Geek</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%8A%80%E6%9C%AF/">#技术</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a></div></div><div class="license-box my-3"><div class="license-title"><div>Computer Network Notes</div><div>https://blogoasis.github.io/post/c78e5236.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>phInTJ</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年10月24日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/post/347fef97.html" title="C++空类大小的探讨"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">C++空类大小的探讨</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/post/e67bc23f.html" title="Algorithms"><span class="hidden-mobile">Algorithms</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="waline"></div><script type="text/javascript">Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.6.3/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.6.3/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://blog-comment-serve-g3f391jy6-main-voice.vercel.app/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":100000,"pageSize":100},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!0,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html>